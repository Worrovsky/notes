## 1. Advanced Class Design

### 1.1 Использование instanceof

**instanceof** - это оператор
   
`b instanceof B` возвращает `true`, если b это:

* экземпляр класса B
* экземпляр подкласса класса B (прямой или непрямой)
* экземпляр класса, реализующего интерфейс B (напрямую или опосредованно)

Работает только с ссылочными типами, с примитивными - ошибка компиляции
        
Для любого ссылочного объекта x:

* `x instanceof Object == true`, кроме случая когда `x == null`
* `null instanceof <любой класс>` всегда false

проверка на класс: `x instanceof Clazz` может сразу давать ошибку компиляции, если между типом переменной `x` и классом `Clazz` нет никакой связи

    class A {}
    class B {}
    class C extends A {}
    A a = new A();
    boolean test = a instanceof B; // ошибка компиляции
    boolean test = a instanceof C; // ок, false в данном случае

Проверка на интерфейс: `x instanceof Interface` всегда компилируется (кроме примитивных): подклассы могут реализовать интерфейс, компилятор об этом не знает
   
    interface I {}
    class A {}
    class B extends A implements I {}
    A x = ...;
    x instanceof I; // false, если х содержит объект класса A, true - если объект B

Часто применяется для проверки перед использованием cast, если неподдерживаемые - вбрасывать исключение. Но лучше не использовать в обычной практике

### 1.2 virtual method invocation

Просто прямое следствие переопределения методов: при вызове методов не важен тип переменной на этапе компиляции, а важен тип объекта в рантайме

    abstract class Animal {
        public abstract void feed();
    }
    class Cow extends Animal {
        public void feed() {
            System.out.println("nom-nom");
        }
    }
    public static void main(String[] args) {
        Animal an = new Cow();
        an.feed();  // будет вызван метод объекта Cow
    }

С полями это не работает (сокрытие полей): результат зависит от типа переменной, от которой вызывается поле

    abstract class Animal {
        String name = "???";
        public void printName() { System.out.println(name); }
    }
    class Cow extends Animal {
        String name = "Cow";
    }
    public static void main(String[] args) {
        Animal an = new Cow();
        an.printName();  // "Cow"
    }    

### 1.3 Аннотирование переопределенных методов @Override
 
Aннотация **@Override** указывает, что программист переопределяет метод (класса или интерфейса). При указании `@Override` на методе, который не переопределяется - ошибка компиляции

    class A {
        public void foo(){}
    }
    class B extends A {
        @Override
        public void foo(){}
        
        @Override 
        public void foo(int i){} // ошибка компиляции, это не переопределение
    }

Применяется только для методов, поля не переопределяются

Что может переопределяться:

* метод реализуемого интерфейса
* метод наследуемого класса
* методы класса Object: toString, hashCode, equals (частный случай предыдущего)

### 1.4 Методы toString, equals, hashCode

**toString**  
            
сигнатура `public String toString()`
        
**equals**
            
сигнатура `public boolean equals(Object obj)`  

требования к методу equals (подразумевается x, y, z не равны null):

* для любого x: `x.equals(x) -> true`
* для любых x, y `x.equals(y)` должно возвращать true только если `y.equals(x)` возвращает true
* для любых x,y,z: если `x.equals(y)=true` и `y.equals(z)=true`, тогда `x.equals(z)` должно возвращать true
* многократный вызов на одних и тех же объектах должен давать постоянный одинаковый результат
* для любого x: `x.equals(null) -> false` (не NPE)

Пример реализации

    public boolean equals(Object obj) {
        if (obj == null) { return false}
        if ( !(obj instanceof Clazz)) {return false}
        if (<сравнение>)
    }    

**hashCode**

сигнатура `public int hashCode()`

Основные требования:

* в рамках одной программы результат `hashCode()` не должен менятся, т.е. в хеш не должны влючаться изменяемые поля
* если `equals()` возвращает true для двух объектов, хеши этих объектов должны совпадать, т.е. `hashCode()` должен включать те поля, которые используются в `equals()`
* если `equals()` возвращает false для двух объектов, хеши этих не обязательно должны быть различными

### 1.5 Перечисления (Enums)

#### 1.5.1 Основы 

Фиксированный набор констант
 
Ключевое слово **emun**, элементы - в верхнем регистре (константы)
          
    public enum Season {
        WINTER, SUMMER, FALL, SPRING
    }

Использование: через точку просто. Допускают сравнение через `==`
            
    Season s = Season.WINTER;
    boolean t = s == Season.WINTER; // true

Методы:

* **values()** - возвращает массив элементов
* **name()** - имя значения
* **ordinal()** - возвращает числовое значение значения Enum

Пример:

    for (Season season : Season.values()) {
        System.out.println(season.name() + " " + season.ordinal());
    }
    // WINTER 0
    // SUMMER 1 ...

Хотя каждому значению перечисления соответствует числовое, сравнивать с ними нельзя:
            
    Season.Winter == 0 // ошибка

Можно получить элемент перечисления по строке по точному совпадению:
              
    Season s = Season.valueOf("SUMMER");
    Season s = Season.valueOf("summer");  // IllegalArgumentException

Наследовать нельзя

#### 1.5.2 Перечисления и switch

Enum можно использовать в switch

    switch (season) {
      case WINTER:
          System.out.println("w");
          break;
      case Season.SUMMER: { // ошибка компиляции, уже известен тип, не нужно уточнять
            ... 
      case 3: {..}  // ошибка компиляции, сравнение с другими типами не работает
    }

#### 1.5.3 Добавление конструкторов, полей, методов

    public enum Season {
        WINTER("Low"), SPRING("Medium"); // здесь ; обязательно - дальше есть код
        private String expectedVisitors;
        private Season(String expectedVisitors) {
            this.expectedVisitors = expectedVisitors;
        }
        public void print() { System.out.println(expectedVisitors); }
    }

Конструктор только `private` допустим: для перечисления конструктор вызывается только внутри самого перечисления. `public` конструктор - ошибка компиляции
           
Конструкторы будут сразу вызваны для всех значений при первом обращении к одному из значений

Вызов публичных методов

    Season.WINTER.print();

Внутри перечисления можно объявлять абстрактные методы, тогда каждый элемент должен переопределить

    public enum S {
        WINTER {
            public void foo() {...}
        }, 
        SUMMER {
            public void foo() {...}
        }; // ; обязательна

        public abstract void foo();
    }

Можно объявить и реализовать метод, а внутри элемента переопределить. Внутри элемента можно объявить метод, но вызвать его нельзя

### 1.6 Вложенные классы

#### 1.6.1 Основы

**Вложенный (nested)класс** - класс, определенный внутри другого класса
            
**Внутренний (inner) класс** - частный случай: не статический вложенный класс 

Типы вложенных классов:

* внутренний класс-член - класс, определенный на уровне переменных класса, не статический
* локальный внутренний класс - определенный внутри метода
* анонимный внутренний класс - локальный внутренний класс без имени
* статический вложенный класс - класс, определенный на уровне статических переменных

#### 1.6.2 Member Inner CLass 

* определен на том же уровне, что и поля, методы, конструкторы класса
* может иметь любой модификатор доступа
* может расширять и реализовывать любые классы, интерфейсы
* может быть abstract или final
* не может иметь статических методов, полей
* имеет доступ к элементам внешнего класса, в т. ч. private

Пример: 

    public class Outer {
        private String msg = "Hi";
      
        public class Inner {
            public void foo() {
                System.out.println(msg); // ok, внутренний имеет доступ к полям внешнего
            }
        }
        public void callInner() {
            Inner inner = new Inner();
            inner.foo();
        }
    }

Создавать экземпляр внутреннего класса можно так вне внешнего класса:
         
    Outer outer = new Outer();
    Inner inner = outer.new Inner();

Причем это можно сделать внутри статического метода внешнего класса

Можно объявлять переменные во внутреннем классе с таким же именем как во внешнем: работает сокрытие. 

Обратится к переменной внешнего класса из внутреннего можно по типу `Outer.this.msg`

Приватные интерфейсы: допустимы внутри класса, методы интерфейса конечно публичные. Такие интерфейсы вне класса не доступны

#### 1.6.3 Local Inner Class

Класс, определенный внутри метода.

Область действия - только внутри метода: создавать экземпляры можно только внутри метода, но можно возвращать как результат метода (но как тип Object)

Свойства:
* не имеют модификаторов доступа
* не может быть static и не имеет static полей/методов
* имеет доступ ко всем полям/методам внешнего класса
* имеет доступ к локальным переменным метода, только если они final или эффективно final (присваивание один раз или иначе: при добавлении final код остается корректным). При компиляции такие переменные помещаются как поля класса

    public class Outer {
        public void foo {
            int a = 5; // эффективно финальная переменная, можно заменить на final int a = 5;
            class Inner {
                public void bar() {System.out.println(a);}
            }
            Inner inner = new Inner();
            inner.bar()
        }
    }


#### 1.6.4 Anonymous Inner Class

Локальный внутренний класс без имени. 

Объявляется сразу через `new`. Обязан переопределять существующий класс или реализовывать интерфейс. Одновременно и класс, и интерфейс или несколько интерфейсов нельзя

    public class Outer{
        abstract class A {
            abstract void foo();
        }

        public void bar() {
            A a = new A() {
                void foo() { ...}
            };
            a.foo();
        }
    }

#### 1.6.5 Static Nested Class 

Статический класс, объявленный на уровне членов класса.

Не может иметь доступ к элементам внешнего класса без экземпляра класса. Через экземпляр имеет доступ к любым, в т.ч. приватным. 

Экземпляр вложенного статического класса можно создать без экземпляра внешнего.

Внешний класс имеет доступ к членам вложенного.

    public class Enclosing {
        static class Nested {
            private int price = 6;
        }
        public static void main(String[] args) {
            Nested nested = new Nested();
            System.out.println(nested.price);
        }
    }

#### 1.6.6  Сводная таблица

|                            |Member Inner|Local Inner|Anonymous|Static Nested|
|----------------------------|------------|-----------|---------|-------------|
|модификаторы доступа        |    любой   |     нет   |    нет  |    любой    |
|наслед-е классов/интерфейсов|    любые   |   любые   |   один  |    любые    |
|может быть абстрактным      |      да    |     да    |    N/A  |      да     |
|может быть final            |      да    |     да    |    N/A  |      да     |
|доступ к членам внешнего    |      да    |     да    |    да   | через экз-р |
|доступ к лок. переменным    |     нет    | эф. final |эф. final|     нет     |
|есть статические методы     |     нет    |    нет    |   нет   |     да      |

## 2. Design Patterns and Principles

### 2.1 Интерфейсы

### 2.2 Введение в функциональное программирование

#### 2.2.1 Функциональные интерфейсы

Интерфейс с единственным абстрактным методом.

Наличие методов по умолчанию, статических методов не снимает признак функциональности

Можно использовать аннотацию **@FunctionalInterface** как гарантию,что не будет изменен статус интерфейса

#### 2.2.2 Реализация функционального интерфейса через лямбда-выражения

    class Animal {
        public boolean canSwim() {return false}
    }
    public interface CheckTrait {
        public boolean test(Animal a);
    }
    class App {
        public static void check(Animal a, CheckTrait trait) {
            System.out.println(trait.test(a));
        }
        public static void main(String[] args) {
            Animal animal = new Animal();
            check(animal, a -> false);
            check(animal, a -> a.canSwim());
        }
    }

Когда передается параметром или присваивается переменной, проверяется соответствие типу переменной (методу функционального интерфейса):

* параметры метода должны соответствовать параметру лямбды
* возвращаемое значение - результату тела лямбда-выражения

Синтаксис лямбда-выражений:

* `параметры -> тело`
* параметры НЕ заключаются в `()`, только если он один и без указания типа
* тело если состоит из более одного выражения, должно быть в `{}`
* если есть `{}`:
    - все выражения должны завершаться ";"
    - если возвращаемый тип не `void` должен явно быть `return`
* если есть `return`, обязательны {}
* типы параметров опциональны, но или у всех, или ни у одного
* присваивать новые значения параметрам нельзя

#### 2.2.3 интерфейс Predicate

    package java.util.function
    public interface Predicate<T> {
        public boolean test(T t);
    }

### 2.3 Реализация полиморфизма

Object vs Reference:

* тип объекта определяет какие свойства имеет объект в памяти
* тип ссылки определяет к каким методам/переменным имеется доступ

Cмена типы ссылки может дать доступ к другим методам, хотя эти методы у объекта в памяти всегда есть.

Преобразование типов (cast):

* преобразование объекта от подкласса к суперклассу не требует явного
* преобразование от суперкласса к подклассу требует явного
* компилятор не пропустит преобразование несвязанных типов
* даже если компилятор разрешает преобразование, исключение может быть в рантайме

### 2.4 Design Principles

#### 2.4.1 Основы

Для чего нужны:

* облегчения понимания кода 
* повышения переиспользования классов
* облечения поддержки кода и внесения изменений

#### 2.4.2 Инкапсуляция

Сокрытие полей класса от непосредственного доступа извне.

Решается через объявление полей private и предоставления геттеров/сеттеров. Никто кроме самого класса, не должен иметь непосредственный доступ к данным класса.

Обеспечивает поддержку инвариантов класса (свойства, утверждения о данных)

#### 2.4.3 JavaBeans

Это соглашения об использовании полей:

* все поля должны быть private
* геттеры для свойств типа boolean могут начинаться с get- или is-
* геттеры для не-boolean типов (в т. ч. Boolean) - только с get-
* сеттеры должны начинаться с set-
* после префиксов - имя свойства с заглавной буквы

#### 2.4.4 Отношение Is-a (является)

Cвойство объекта быть экземпляров некого типа.

Например класс Cat наследует класс Pet, тогда Cat Is-a Pet (класс Cat является классом Pet)

Можно проверять иерархию классов при разработке, задавая вопрос  `Is <subclass> a <superclass>`?

#### 2.4.5 Отношение Has-a

Cодержит ли объект некое свойство/значение.

Причем если объект содержит protected или public поле, тогда все дочерние классы также содержат это поле.

#### 2.4.6 Композиция объектов

Свойство класса содержать другой класс для использования методов этого класса.

По сути работает отношение **Has-a**, альтернатива наследованию

### 2.5 Design Patterns
 
Общие решения для частых проблем при разработке        

### 2.5.1 Singleton Pattern

Создание объекта класса в единственном экземпляре для использования в нескольких местах.

    public class Singleton {
        private static final Singleton instance = new Singleton();
        
        public static Singleton getInstance() { return instance;}
        
        private Singleton() {}
    }

Ключевые моменты:
* обязателен приватный конструктор без параметров (запрещаем создавать экземпляры через конструкторы, что делает этот класс финальным (дочерние не смогут вызвать super())
* статическая финальная переменная для хранения единственного экземпляра
* статический метод для получения этого экземпляра
* инициализировать переменную instance можно не при объявлении, а в статическом блоке

Ленивая инициализация:

Статическая инициализация происходит при загрузке класса в JVM, можно отложить до первого вызова метода getInstance():

    private static Singleton instance; // уже не final !!!
    public static Singleton getInstance() {
        if (instance == null) 
            instance = new Singleton(); // не потокобезопасно
        return instance;
    }

#### 2.5.2 Immutable Objects

Создание объектов, состояние которых не меняется после того, как объект был создан

Основные мероприятия:

* все свойства объекта только через конструктор
    - причем аккуратно с передачей ссылочных мутабельный объектов в конструктор
    - после создания объекта внешний код может их изменить, т.е. в объект копировать внешние мутабельные объекты нужно
* все переменные экземпляра должны быть `private` и `final`
* не создаются сеттеры
* не позволять, чтобы мутабельные изменяемые объекты-свойства изменялись через методы или непосредственно (доступ к списку через геттер напр.). иначе: нельзя давать ссылки на мутабельные объекты в составе немутабельного. Выход - возвращать копию, использовать неизменяемые коллекциии или обеспечить итерацию
* запретить переопределение методов, иначе подклассы могут нарушить иммутабельность. Решение: сделать класс финальным.

#### 2.5.3 Builder Pattern

Как создать объект, требующий установки большого количества параметров при создании.
            
Использование сеттеров имеет минусы:

* как быть с иммутабельными объектами (неизменны после создания)
* сеттеры разобщены и не позволяют контролировать корректность создания

Суть: использование объекта, в который параметры передаются постепенно через цепочку методов, а объект создается последним вызовом метода `build()`

    public class ClazzBuilder{
        private String a;
        private List l;
        public ClazzBuilder setA(String a) {
            this.a = a;
            return this;
        }
        public ClazzBuilder setL(List l) { ...}
        public Clazz build() {return new Clazz(a, l)}
    }
    ClazzBuilder builder = new ClazzBuilder()
    Clazz cl = builder.setA("").setL(null).build();

Обычно builder делают вложенным статическим классом:

* вместе легче изменять
* конструкторы основного класса теперь могут быть приватными

#### 2.5.4 Factory Pattern

Как создавать объекты, чей тип неизвестен на этапе компиляции?

В основе использование класса-фабрики, который создает объекты на основе своих входных параметров:

    public abstract class Food {}
    public class Hay extends Food {}
    public class Meat extends Food {}
    public class FoodFactory {    // имя класса содержит Factory
        public static getFood(String animalType) {
            switch (animalType) {
                case "zebra": return new Hay();
                case "Tiger": return new Meat();
            }
            throw new UnsupportedOperationException; // практика вбрасывать исключение
                                                    // если нет подходящего типа
        }
    }
    Food f = FoodFactory.getFood("Tiger");

В этом примере объекты можно создавать минуя фабрику. Чтобы запретить это нужно помещать фабрику и объекты в один пакет, и исключать публичные конструкторы, оставляя `protected` или `default`

## 3. Generics and Collections

### 3.1 Универсальные типы

#### 3.1.1 Универсальные классы

Классы с указанием формальных типов
                
    public class Foo <T> {private T someVar;}
      
Теперь `T` можно поставить вместо любого типа внутри класса.
            
Использование универсального класса:

    Foo<String> f = new Foo<>();

Конвенции именования для формальных типов: заглавные одиночные буквы E(element), K(key), V(value), N(number), T(общий тип), S, U, V, .. (для множественных)

#### 3.1.2 Стирание типов (Type Erasure)

Универсальные типы дают компилятору дополнительные возможности для проверки, но во время компиляции все формальные типы заменяются на `Object`.

Т.е. класс после компиляции: 

    public class Foo {private Object someVar;}

При получении данных универсального типа выполняется приведение типов:
 
    String s = (String) new Foo<String>().getSomeVar();

#### 3.1.3 Универсальные интерфейсы

Как и у классов указание формального типа при объявлении
    
    public interface Bar<T> {
        void foo(T t);
    }

Три способа реализовать такой интерфейс:

1. Указать конкретный тип в классе при реализации интерфейса, тогда и при реализации метода указываем конкретный тип
                    
    public class Clazz implements Bar<String>{
        void foo(String t) {...}
    }
    
2. Создать универсальный класс

    public class Clazz<U> implements Bar<U>{
        void foo(U t) {...}
    }

3. Не указывать универсальный тип вообще, получим предупреждение компилятора, вместо универсального типа придется использовать `Object`
    
    public class Clazz implements Bar{
        void foo(Object t) {...}
    }

#### 3.1.4 Ограничения универсальных типов

Что нельзя делать с универсальными типами (основные ограничения - следствие стирания типов):

* нельзя создавать объекты `new T()` (в рантайме это было бы `new Object()`)
* нельзя создавать массивы с универсальным типом (опять же `Object`)
* нельзя использовать с оператором `instanceof`
* нельзя использовать примитивные типы
* нельзя использовать универсальный тип в статическом контексте (все варианты будут преобразовываться к единственному случаю)

Пример:

    public static T foo() {} // ошибка
    private static T someVar; // ошибка

#### 3.1.5 Универсальные методы

Метод с универсальным типом. Тип указывается перед возвращаемым значением:

    public <T> T foo(T t) {return t;}

Вызывать можно без указания конкретного типа или с указанием:

    new Clazz().<String>foo("..");

#### 3.1.6 legacy code, предупреждения компилятора

Код с использованием сырых (raw) типов без конкретизации типа:
                
    List list = new ArrayList();

В такой список можно вставить любой `Object`, но при извлечении в специализированный тип можем получить `ClassCastException`

Любое обращение к сырому типу потенциально может привести к ошибке:

    List<Clazz> mylist = ...;
    public void foo(List mylist) {
        mylist.add(new String("66")); // компиляция без ошибок(но с предупреждением)
                                     // в рантайме ClassCastException
    }

#### 3.1.7 Границы типов

##### 3.1.7.1 Основы

**wildcard generic type** - неизвестный тип, обозначаемый `?`
                
Можно накладывать ограничения:
                    
* сверху: `? extends type`
* снизу: `? super type`

wildcard без ограничений (подстановочные типы)

Например такой код 
                   
    List<String> list1 = ...;
    List<Object> list2 = list1; // ошибка компиляции, хотя String подтип Object

Если бы было можно, тогда проходило бы такое:
                    
    List<Integer> numbers = ..;
    List<Object> objs = numbers; // не пройдет, но если бы можно было, тогда
    objs.add("bla"); // в список Object вроде бы и можно, но там по факту Integer ??

А с массивами:
    
    Integer[] nums = {new Integer(42)};
    Object objs[] = nums; // ok
    objs[0]  = "43"; // ArrayStoreException
    // тип массива знает в рантайме JVM, несмотря на смену типа переменной
    // с универсальными типами такого нет (стирание), поэтому сразу запрещает

Для решения проблемы из первого примера и введены wildcard:

    void foo(List<?> list) {
        for(Object x : list) { System.out.println(x);}
    }
    List<String> l1 = ..;
    foo(l1);
    List<Integer> l2 = ..;
    foo(l2);

##### 3.1.7.2 wildcard с верхней границей

    List<? extends Number> = new ArrayList<Integer>();

Означает любой наследник `Number` или сам `Number`, по прежнему при компиляции `Object`

Проблема с добавлением элементов: в списки с wildcard, wildcard с верхней границей нельзя добавлять элементы. Объект какого бы типа не добавляли, нельзя сказать что это будет соответствовать переданному списку:

    void foo(List<?> list) {
        list.add("bla"); // ошибка компиляции, список может быть не List<String>
        list.add(new Object()); // ошибка компиляции, аналогично
        list.add(<что угодно>); // ошибка компиляции
    }

##### 3.1.7.3 wildcard с нижней границей

    List<? super Integer> list = new ArrayList<Number>();

Означает сам `Integer` или его родительские классы (`Number`, `Object`)

В такие списки можно добавлять новые элементы:

    list.add(new Integer(10));
    list.add(new Number(10)); // ошибка компиляции (list может быть List<Integer>)
    list.add(new <дочерний Integer>());
    list.add(new Object());       // ошибка компиляции
    но list.add(new Double(1.3)); // ошибка компиляции

##### 3.1.7.4 Итоги

Выражение типа `<?>`, `<? extends T>`, `<? super U>` не является типом, поэтому нельзя напр. `public <? extends String> foo() {..}`
   
    <B extends A> B method3(List<B> list) {
        return new B(); // DOES NOT COMPILE
    }

### 3.2 Коллекции

Общее
            java.util.*
            List - упорядоченный набор элементов, доступ по индексу
            Set - набор уникальных элементов
            Map - отображения ключей в значения, дубли ключей не разрешены
            Queue - располагает элементы в определенном порядке для обработки

            интерфейс Collection    |-- List
                                    |-- Map
                                    |-- Queue
                                    (отдельно) Map

        Общие методы Collection
            boolean add(E element)
                List возвращает true всегда
                Set возвращает false при попытке вставки дубля

            boolean remove(Object obj)
                удалет элемент, возращает истина, если был удален
                у List есть перегруженный метод E remove(int index)
            boolean isEmpty()
            int size()
            void clear()
                очистка коллекции
            boolean contains(Object o)
                содержит ли коллекция элемент (через вызов equals())

        интерфейс List
            реализации:
                ArrayList
                    вставка - линейное время
                    доступ по индексу - константа
                LinkedList
                    вставка/удаление в конец/начало - константное время
                    доступ по индексу - линейное
                устаревшие Vector, Stack

            Методы
                void add(int index, E elem)
                E get(int index)
                int indexOf(E elem)         - индекс первого вхождения или -1
                int lastIndexOf(E elem)     - индекс последнего вхождения или -1
                E set(int index, E elem)    - заменяет элемент, возвращает прежний

        интерфейс Set

            Реализации
                HashSet - константное время вставки, проверки
                    порядка нет
                TreeSet - отсортирован, вставка/проверка - O(log n)
                    реализует интерфейс NavigableSet
            особых методов по сравнению с Collection не добавляет

        интерфейс Queue
           
            LinkedList, ArrayDeque

            методы:
                два вида методов:
                    вызывающие исключение
                        boolean add(E elem)
                        E element() - возвращает следующий элемент (не удаляя) 
                            или исключение, если очередь пустая
                        E remove() - возвращает и удаляет следующий элемент, 
                            исключение если пустая очередь

                    возвращающие особое значение (null, false)
                        boolean offer(E e) - добавляет элемент в конец очереди, true если успешно
                        void push(E e) - добавляет элемент в начало очереди
                        E poll() - удаляет и возвращает следующий элемент 
                            или null если очередь пустая
                        E peek() - возвращает следующий элемент (null если пустая)

        интерфейс Map
           
            реализации
                HashMap - в хеш-таблице без сортировки
                TreeMap - в дереве, отсортированны 

            методы
                т. к. не наследует Collection имеет собственные методы

                V get(Object key)       значение по ключу или null
                V put(K key, V value)   помещает/замещает значение по ключу
                                            возвращает прежнее или null
                Set<K> keySet()         возвращает ключи
                Collection<V> values()  возвращает значения

        сводные таблицы

            ======/=============/==============/===================/===============
            Тип   /  Дубликаты? / Упорядочены? / Ключи и значения? / Удаление/добавление в особом порядке
            ======/=============/==============/===================/===============            
            List  /      +      /+(по индексу) /         -         /         -
            Map   /   +(values) /     -        /         +         /         -
            Queue /      +      /     +        /         -         /         +
            Set   /      -      /     -        /         -         /         -

            ===========/============/============/====================/================
            тип        / интерфейс  / сортирован / вызывает hashCode  / вызывает compareTo
            ===========/============/============/====================/================
            ArrayList  /   List     /     -      /         -          /         -
            ArrayDeque /   Queue    /     -      /         -          /         -
            HashMap    /   Map      /     -      /         +          /         -
            HashSet    /   Set      /     -      /         +          /         -
            Hashtable  /   Map      /     -      /         +          /         -
            LinkedList / List, Queue/     -      /         -          /         -
            TreeMap    /   Map      /     +      /         -          /         +
            TreeSet    /   Set      /     +      /         -          /         +

        Допустимость null

            сортированные коллекции не допускают null:
                TreeSet, TreeMap (ключи нельзя null, значения можно)

            ArrayDeque не допускает null (методы типа poll() возвращают null как
                индикатор пустой очереди)

            Hashtable не допускает null

    Comparator vs Comparable

        Comparable
            интерфейс java.lang.Comparable

            public interface Comparable<T> {
                public int compareTo(T o);
            }

            метод compareTo() возращает:
                0 - если одинаковы объекты
                меньше нуля - если текущий объект меньше параметра
                больше нуля - если текущий объект больше параметра

            обычно реализация Comparable должна быть совместима с equals():
                compareTo() возвращает 0 только, если equals() возвращает null

        Comparator
            функциональный интерфейс java.util.Comparator
            применяется если Comparable не реализован или нужен другой порядок

            можно как анонимный класс:
                Comparator<Duck> byWeight = new Comparator<Duck>() {
                    public int compare(Duck d1, Duck d2) {
                        return d1.getWeight() - d2.getWeight();
                    }
                }
            можно через лямбды
                Comparator<Duck> byWeight = (d1, d2) -> d1.getWeight() - d2.getWeight();
                Comparable тоже функциональный интерфейс, но он реализуется 
                    внутри класса обычно и лямбды не используются

        Сравнение
            ================/=============/============
                            /  Comparable / Comparator
            ================/=============/============
            пакет           /  java.lang  / java.util
            метод           /  compareTo  / compare
            параметры       /      1      /     2
            обычно с лямбда /      нет    /     да

    Сортировка / сравнение

        методы типа sort используют метод compareTo()
            вызов с параметром не типа Comparable - ошибка компиляции

        но также есть эти методы для вызова с Comparator

        сортированные коллекции типа TreeSet также используют compareTo(),
            но это не проверяется на этапе компиляции: add(E e) - на тип нет ограничений

            class Foo {} // не реализует Comparable
            TreeSet<Foo> set = new TreeSet<>();
            set.add(new Foo()); // в рантайме ClassCastException при попытке преобразовать в Comparable

        сортированные коллекции также можно на основе Comparator
            TreeSet<Foo> set = new TreeSet<>(new Comparator<Foo>(){...});

    Новое в Java 8

        Method Reference
            другая форма лямбда-выражения(и не только), в котором просто параметры
                передаются в некоторый метод:

                a -> b.method(a)            ~   b::method
                (a, b) -> a.method(b)       ~   TypeA::method
                a -> a.method()             ~   TypeA::method
                a -> StaticObj.method(a)    ~   StaticObj::method

            форматы Method Reference:
                статические методы
                    Consumer<List<Integer>> methodRef = Collections::sort;
                    Consumer<List<Integer>> lambda = l -> Collections.sort(l);

                методы экземпляра на конкретном экземпляре
                    String str = "abc";
                    Predicate<String> methodRef = str::startsWith;
                    Predicate<String> lambda = s -> str.startsWith(s);

                методы экземпляра на экземпляре, определенном в рантайме
                    Predicate<String> methodRef = String::isEmpty; // это не статический метод
                    Predicate<String> lambda = s -> s.isEmpty();

                конструкторы
                    Supplier<ArrayList> methodRef = ArrayList::new;
                    Supplier<ArrayList> lambda = () -> new ArrayList();

        Новые методы коллекций

            Удаление элементов по условию
          
            метод интерфейса Collection 
                boolean removeIf(Predicate <? super E> filter)

            List<String> list = ...
            list.removeIf(s -> s.startsWith("A")); // с помощью method reference нельзя: параметр лямбды не передается в метод

            Обновление всех элементов

            метод интерфейса Collection

            void replaceAll(UnaryOperator<E> o)

            List<Integer> list = ...;
            list.updateAll(x -> x * 2);

            Обход элементов
                List<String> list = ...;
                list.forEach(System.out::println);

        Новые методы Map

            putIfAbsent()
                обычный метод put() заменяет значение если ключ уже есть в коллекции
                putIfAbsent помещает значение в коллекцию только если ключ отстутствует
                    или значение было null

            merge() 
                сигнатура
                    V merge(K key, V value, BiFunction<? super V, ? super V, ? super V> mapper)
                суть метода:
                    проверяет наличие ключа key
                    если нет - просто вставляет значение value
                    если есть: применяет функцию mapper к старому значению и новому значению value
                    если результат функции null - удаляет пару ключ/значение
                    иначе вставляет результат функции по ключу

                напр.:
                    map.merge(key, msg, String::concat) // добавление строки к существующей

            computeIfPresent()
                сигнатура
                    V computeIfPresent(K key, BiFunction<? super K, ? super V, ? super V> mapper)
                суть метода:
                    если ключ есть и значение по ключу не null применяет функцию к ключу 
                        и значению
                    если результат функции null - удаляет ключ, значение из коллекции
                    иначе помещает новое значение

            computeIfAbsent()
                сигнатура
                    V computeIfAbsent(K key, Function<? super K, ? extends V> mapper)
                суть метода:
                    если ключ отсутствует или значение по ключу null применяет функцию к ключу 
                    если результат функции не null - вставляет полученное значение в коллекцию
                    если результат функции null - ничего не происходит

## 4. Функциональное программирование

    Переменные в лямбда-выражениях

        внутри лямбда-выражения есть доступ к локальным переменным или 
            параметрам методов, если они являются финальными или эффективно финальными

    Функциональные интерфейсы

        пакет java.util.function

        сводная таблица
            ====================/============/===================/========
            Интерфейс           /  Параметры / Возвращаемый тип  /  Метод
            ====================/============/===================/========
            Supplier<T>         /  0         /      T            /   get
            Consumer<T>         /  1(T)      /      void         /   accept
            BiConsumer<T, U>    /  2(T, U)   /      void         /   accept
            Predicate<T>        /  1(T)      /      boolean      /   test
            BiPredicate<T, U>   /  2(T, U)   /      boolean      /   test
            Function<T, R>      /  1(T)      /      R            /   apply
            BiFunction<T, U, R> /  2(T, U)   /      R            /   apply
            UnaryOperator<T>    /  1(T)      /      T            /   apply
            BinaryOperator<T>   /  2(T, T)   /      T            /   apply

        заметки:
            - имеют методы по умолчанию типа and(), negate(), которые 
                позволяют комбинировать реализации интерфейсов 
            - Predicate использует именно boolean, не Boolean
            - можно не специализировать тип у интерфейса, при этом тип будет
                Object, и в теле вызывать можно только методы Object:
                Predicate p = String::isEmptry; // не компилируется

    Optional

        используется, когда нужно показать отсутствие результата
            если он есть, значение просто завертывается в экземпляр Optional

        аналог null?
            - более явно указывает на особое значение/отсутствие значения
            - удобно в функциональном коде (потоках)


        основные методы
            создание:
                static <T> Optional<T> empty()
                    возвращает пустой экземпляр 
                static <T> Optional<T> of(T value)
                    создает экземпляр с указанным не null значением
                static <T> Optional<T> ofNullable(T value)
                    эквивалент (value == null)? Optional.empty(): Optional.of(value)
            
            проверка / получение значения:
                boolean isPresent()
                    true, если есть значение
                T get()
                    возвращает значение, если отсутствует - NoSuchElementException
            
            использование:  
                void ifPresent(Consumer<? super T> c)
                    если не пустое значение, вызывает функцию с
                T orElse(T other)
                    возвращает значение непустого Optional или значение other
                T orElseGet(Supplier<? extends T> s) 
                    возвращает значение непустого, иначе вызывает supplier для получения значения
                <X extends Throwable> T orElseThrow(Supplier<? extends X> s) throws X extends Throwable
                    возвращает значение непустого, иначе генерирует исключение, которое производит supplier

            примеры:
                Optional<Double> emptyOpt = Optional.empty();
                Double d = emptyOpt.orElse(Double.NaN);
                d = emptyOpt.orElseGet(() -> Math.random());
                d = emptyOpt.orElseThrow(IllegalArgumentException::new);

    Потоки (Streams)

        основные понятия
            stream - последовательность данных
            stream pipeline - операция над потоком для получения результата
            потоки могут быть конечными и бесконечными
            части stream pipeline:
                - источник
                - промежуточные операции
                - терминальные операции

            сравнение операций:
                ==============================/=================/===========
                характеристики                /  промежуточные  / терминальные
                ==============================/=================/===========
                требуют предыдущих частей     /      нет        /     да
                несколько раз можно применять /      да         /     только один
                результатом возвращает поток  /      да         /     нет       
                выполняется сразу при вызове  /      нет        /     да 
                поток после вызова доступен   /      да         /     нет

        создание

            Stream<String> s = Stream.empty();
            Stream<Integer> s = Stream.of(1);
            Stream<Integer> s = Stream.of(1, 2, 3); // varargs / массивы

            List<String> list = Arrays.asList("a", "b");
            Stream<String> fromList = list.stream();

            бесконечные потоки:
                Stream<Double> ds = Stream.generate(Math::random);
                Stream<Integer> is = Stream.iterate(1, n -> n + 2);

        Типичные терминальные операции

            Редукция - особый тип терминальных операций, при котором все элементы потока
                преобразуются в единственное значение

            count()

                long count()
                считает количество элементов
                для бесконечных потоков - не завершается
                редукция

                Stream<String> s = Stream.of("a", "b", "c");
                long c = s.count(); // 3

            min() / max()

                Optional<T> min(<? super T>comparator)
                Optional<T> max(<? super T>comparator)
                
                возвращает Optional: может не быть значений (для пустого например)
                для бесконечных потоков - не завершается
                редукция

            findAny() / findFirst()

                Optional<T> findAny()
                Optional<T> findFirst()

                для пустых потоков возвращают пустой Optional
                работают с бесконечными потоками
                findAny() удобен для параллельных потоков, когда не важен элемент

                не редукция (не обходят все элементы)

            allMatch() / anyMatch() / noneMatch()

                boolean anyMatch(<? super T> predicate)
                boolean allMatch(<? super T> predicate)
                boolean noneMatch(<? super T> predicate)

                проверяют выполнение Predicate для элементов (не обязательно для всех)
                для бесконечных может завершится, может нет
                не редукция (не обходят все элементы)

                List list = Arrays.asList("monk", "2", "chik");
                Predicate<String> pred = x -> Character.isLetter(x.charAt[0]);
                boolean test = list.stream().anyMatch(pred) ; // true
                test = list.stream().allMatch(pred) ; // false
                test = list.stream().noneMatch(pred) ; // false

                Stream<String> infinite = Stream.generate(() -> "foo");
                test = infinite.anyMatch(pred) ; // true

            forEach()
                обход потока
                для бесконечных не завершается
                не редукция

                void forEach(Consumer<? super T> action)

                Stream<String> s = Stream.of("a", "b", "c");
                s.forEach(System.out::println);

                обычный forEach для потока не применим (не iterable)

            reduce()

                комбинирует элементы потока в один объект
                редукция по определению

                T reduce(T identity, BinaryOperator<T> accumulator)
                Optional<T> reduce(BinaryOperator<T> accumulator)
                <U> U reduce (U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner)

                вариант 1: начать с начального значения, комбинировать его с элементами потока

                    String rezult = s.reduce("", (s, c) -> s + c));
                    или то же самое s.reduce("", String::concat)

                    если поток пустой - вернет начальное значение

                вариант 2: тот же вариант 1, но без указания начального значения
                    если поток пустой - вернет пустой Optional
                    если поток с одним элементом - вернет его в Optional
                    
                    Optional<String> rezult = s.reduce(String::concat);

                вариант 3: для параллельных потоков:
                    accumulator - комбинирует элементы в одном треде
                    combiner - объединияет результат разных тредов

                    можно применять для обычных не параллельных потоков
                    BinaryOperator<Integer> op = (a, b) -> a * b;
                    int prod = stream.reduce(1, op, op); // произведение

            collect()

                особый тип редукции - мутабельная 
                в процессе комбинирования используется один и тот же мутабельный объект
                    напр. StringBuilder, ArrayList
                позволяет преобразовать данные потока в другую форму

                <R> R collect(Supplier<R> supplier,
                                 BiConsumer<R, ? super T> accumulator,
                                 BiConsumer<R, R> combiner)

                <R, A> R collect(Collector<? super T, A, R> collector)




## 5. Dates, String, Localization

    Date, time

        Создание
            LocalDate
            LocalTime
            LocalDateTime
            ZonedDateTime (использовать, когда действительно нужны зоны)

            зоны
                UTC, GMT - одно и тоже
                обозначается разными способами: +02:00, GMT+2, UTC+2
                напр.
                    2015–06–20 07:50+02:00[Europe/Paris] -> GMT 2015-06-20 05:50

            создание через конструкторы:
                все конструкторы приватные
                нельзя

            создание через статические методы now()
                LocalDate date = LocalDate.now();

            создание через статические методы of()
                в качестве месяца можно передавать или int, или перечисление Month
                месяца начинаются с 1
                указание неверных значений (13 для месяца, 32 для дня)- исключения

                напр. для ZonedDateTime:
                    ZonedDateTime.of(int y, int m, int d, int h, int min, int s, int ns, ZoneId zone)
                    ZonedDateTime.of(LocalDate date, LocalTime time, ZoneId zone)
                    ZonedDateTime.of(LocalDateTime dateTime, ZoneId zone)

                зону можно получить тоже через статический метод 
                    ZoneId zone = ZoneId.of("US/Eastern");

        Использование

            объекты иммутабельны, поэтому всегда нужно присваивать:
                date = date.plusDays(2); // просто date.plusDays(2) - потеря значения

        Period

            период между двумя датами (без времени)
            создание:
                статические методы
                    ofYears(int)
                    ofMonths(int)
                    ofWeek(int)
                    ofDays(int)
                    of(int y, int m, int d)

            представление строковое:
                "P1Y2M3D"
                "P" - от Period
                если какая-то часть равна 0 - соответствующий блок отсутствует

            используется в методах типа plus(), minus() у переменных типа LocalDate и LocalDateTime

        Duration

            аналог периода для времени
            создание:
                ofDays(int)
                ofHours(int)
                ofMinutes(int)
                ofSeconds(int)
                ofMilis(int)
                ofNanos(int)

                несмотря на наличие метода ofDays, внутри хранит в часах, 
                    минутах, секундах с дробной частью

            представление
                "PT23H"
                "PT" - от period of time

            создание через методы с TemporalUnit
                TemporalUnit - интерфейс, реализация - ChronoUnit
                Duration.of(int i, TemporalUnit unit)
                    Duration.of(1, ChronoUnit.DAYS);
                    Duration.of(1, ChronoUnit.MINUTES); 
                    и т. п.

            используется в методах типа plus(), minus() у переменных типа LocalTime, LocalDateTime

        Instant
            представляет определенный момент времени в GMT

            Создание
                Instant now = Instant.now();
                Instant instant1 = Instant.ofEpochSecond(epochSecond)

            может использоваться для получения Duration
                Duration.between(instant1, instant2)

            ZonedDateTime можно преобразовать в Instant, но не LocalDateTime
                zonedDateTime.toInstant()

            можно добавлять/вычитать ChronoUnit, но не больше дней:
                Instant nextDay = instant1.plus(1, ChronoUnit.DAYS);
                Instant nextHour = instant1.plus(1, ChronoUnit.HOUR);

    Internalization, Localization

        Locale

            локаль - определенный георгафический, культурный или политический регион
            класс java.util.Locale
            получение локали по умолчанию 
                Locale locale = Locale.getDefault();

            представление:
                язык            "fr", "en"
                язык_СТРАНА     "en_US", "fr_CA"
                остальные варианты (только страна, СТРАНА_язык, страна_ЯЗЫК и т. п.)
                    не корректны

            создание:
                через константы 
                    Locale.GERMAN - "de", Locale.GERMANY - "de_DE"
                конструктором
                    new Locale("fr"); new Locale("hi", "IN")
                    создать можно неверную локаль
                через билдер
                    new Locale.Builder()
                        .setRegion("US")
                        .setLanguage("en")
                        .build();
                    порядок region / language произвольный, регистр выправляет,
                        можно создать пустую локаль, но лучше держаться правильного

            установка локали:
                Locale.setDefault(locale)
                влияет только на конкретный экземпляр программы
                редко когда используется

        Resource Bundle

            содержит локальные специфичные данные
            можно трактовать как набор ключ-значение
            содержится в файле или в классе

            Resource Bundle в виде файла

                имя файла: Произвольное_Локаль.properties
                    Zoo_en.properties
                    Zoo_fr.properties
                содержимое:
                    <свойство>=<значение>
                        Hello=Hello (Zoo_en)
                        Hello=Bonjour (Zoo_fr)
                    другие варианты:
                        <свойство>:<значение>
                        <свойство> <значение>

                теперь можно читать данные из файла:
                    Locale locale = ...;
                    ResourceBundle bundle = ResourceBundle.getBundle("Zoo", locale);
                    String hello = bundle.getString("Hello");
                    значение зависит от переданной локали

                синтаксис файла:
                    строка с "#" или "!" - комментарий
                    пробелы перед/после разделителя игнорируются
                    пробелы в начале строки игнорируются
                    пробелы в конце строки НЕ игнорируются
                    разделить строки можно обратным слешем
                    обычные "/t" и "/n" работают

            Resource Bundle в виде класса

                обычно хватает файла
                но в файле значения - только строки
                resource bundle в виде класса позволяет:
                    - хранить любые типы
                    - создавать значения в рантайме

                создать:
                    новый класс (имя как и для файлов с языком/регионом)
                    унаследовать ListResourseBundle

                        public class Zoo_en_US extends ListResourseBundle {
                            protected Object[][] getContents() {
                                return new Object[][]{{"hello", "Hi"}};
                            }
                        }

                получение значений:
                    метод getObject(String key)

        Определение подходящего Resource Bundle

            ResourceBundle.getBundle("name"); // получает bundle с локалью по умолчанию
            ResourceBundle.getBundle("name", locale);

            Общие правила:
                - ищется наиболее специфичный bundle
                - сначала ищется для конкретной локали ресурсы, 
                    затем для локали по умолчанию, затем ресурсы без указания локали
                - на каждом шаге отбрасывается по части: "fr_FR", "fr"
                - bundle-класс имеет больший приоритет чем bundle-файл
                - если ничего не найдено - исключение MissingResourceException

            Даже если определен конкретный bundle, значения по ключам не
                обязательно будут из него:

                при отсутствие - поиск будет в менее специфичных 
                    напр. цепочка "prop_fr_FR.properties" - "prop_fr.properties" - "prop.properties"

            Иначе:
                при определении bundle выстраивается иерархия подходящих
                    ресурсов (классов и файлов) от наиболее специфичных к менее
                при получении значения по ключу - обход этой иерархии до первого совпадения
        
    Форматирование 

        Форматирование чисел

            Получение экземпляра NumberFormat
                
                используется для форматирования и для парсинга

                NumberFormat.getInstance()                 
                NumberFormat.getInstance(Locale)                 
                
                NumberFormat.getCurrencyInstance()                 // для денежных чисел
                NumberFormat.getCurrencyInstance(Locale)                 
                
                NumberFormat.getPercentInstance()                 // для процент чисел
                NumberFormat.getPercentInstance(Locale)                 


            Форматирование
                вызов метода format
                    NumberFormat us = NumberFormat.getInstance(new Locale("en", "US"));
                    String formatted =  us.format(42.0);

            Парсинг
                NumberFormat us = NumberFormat.getInstance(new Locale("en", "US"));
                us.parse("42.0");

                генерирует проверяемое исключение ParseException
                парсит до тех пор пока не встретит неподходящий символ
                    напр. fr.parse("42.43"); // результат - 42: "." - не разделитель для fr

        Форматирование дат

            класс java.time.format.DateTimeFormatter

            использование: 
                - передать экземпляр в метод format() классов LocalTime, LocalDate, LocalDateTime
                - вызвать format() у экземпляра DateTimeFormatter

            получение:
                DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE;
                DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_TIME;
                DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;

                через методы 
                    ofLocalizedDate(FormatStyle style)
                    ofLocalizedTime(FormatStyle style)
                    ofLocalizedDateTime(FormatStyle style)

                стили:
                    FormatStyle.SHORT
                    FormatStyle.MEDIUM

                можно собственный:
                    DateTimeFormatter.ofPattern("MM yyyy");

## 7. Concurrency

    Основы потоков

        Типы потоков
            системные потоки 
                создаются JVM, напр. сборщик мусора
            пользовательские потоки
                создаются программно: main() и другие потоки

        Runnable
            функциональный интерфейс
            interface Runnable {
                public void run();
            }
            используется для указания задания для потока

        Создание потока
            
            класс java.lang.Thread
            2 шага:
                - определить Thread и указать задачу для выполнения
                    - передать Runnable в конструктор
                    - унаследовать класс Thread и переопределить метод run()
                - запустить поток: Thread.start() (фактический запуск - когда решит ОС)

            наследовать Thread или реализовывать Runnable:
                - программируйте на уровне интерфейсов, а не реализаций
                - множественного наследования нет, унаследовав Thread, больше не сможем
                - реализация Runnable дает доступ к Concurrency API
                - наследовать приходится, если нужно переопределить поведение класса 

        Периодический опрос (polling) через Sleep

            нужно периодически проверять переменную, напр. счетчик на достижение
                граничного значения (один поток изменяет, второй проверяет)
                проверка идет в цикле
                    while(true) {
                        check...
                    }
                простой цикл без задержек - расходование ресурсов системы
                реализуем задержку через Thread.sleep(inMillis);

    Cоздание потоков с помощью ExecutorService

        рекомендуется использовать всегда, когда нужны потоки, даже в 
            случае одного задания

        интерфейс java.util.concurrent.ExecutorService

        Single Thread Executor

            import java.util.concurrent.*;
            ExecutorService service = null;
            try {
                service = Executors.newSingleThreadExecutor();
                service.execute(() -> System.out.println("first task"));
                service.execute(() -> System.out.println("second task"));
            } finally {
                if (service!= null) 
                    service.shutdown();
            }

            здесь создается экземпляр
            в методы execute() передается Runnable и поочередно выполняется в одном потоке
            выполняется именно в том порядке в котором вызывается
                для других видов executor такое не гарантируется
                и лучше не привыкать

        Shut Down Executor

            потоки создаются не демоны
            нужно явно завершать использование service - метод shutdown()
            после вызова shutdown() два этапа:
                - продолжает выполнять запущенные потоки, но новые задачи 
                        отклоняются (исключение RejectedExecutionException на execute())
                    метод isShutdown() возвращает true
                    метод isTerminated() возращает false
                - когда активные потоки завершены
                    isShutdown() и isTerminated() возвращают true

            try {
                executor.execute(...);
            } finally {
                executor.shutdown();
            }

            shutdown() не прерывает потоки сразу, а ждет их завершения

            метод shutdownNow() пытается сразу прервать выполнение потоков
                (через установку флага interrept, поэтому задачи должны проверять Thread.isInterrupted())

            ресурсы подобные ExecutorService нужно освобождать:
                не реализует AutoClosable, поэтому нужно явно
                вызов метода shutdown()
                можно в блоке try-finally
                на момент закрытия программы должны быть освобождены,
                    поэтому нужно на закрытие программы обрабатывать

        Submitting Tasks

            Варианты запуска задач

                void execute(Runnable command) - асинхронно запускает задачу
                    без результата

                <T> Future<T> submit(Callable<T> task) - асинхронно запускает задачу,
                    возвращает Future представление
                Future<?> submit(Runnable task) - вариант для Runnable, пустой Future

                <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException
                    синхронно выполняет список заданий, возвращает список объектов Future
                        в том же порядке, что и список задач

                <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException
                    выполняет список задач, синхроннно, возвращает результат одной из завершившихся
                        отменяя остальные незавершившиеся

                submit() vs execute()
                    рекомендуется всегда использовать submit() даже если не нужен результат

            Запуск коллекции задач

                invokeAny() и invokeAll()
                    оба метода синхронные (держат поток управления до завершения)

                invokeAll() - выполняет все задачи и только потом возвращает управление
                invokeAny() - выполняет хотя бы одну и возвращает управление (возвращается не
                    обязательно первое выполненное)

                есть варианты вызова методов с таймаутом

            Future
            
                методы интерфейса Future
                    boolean isDone() - возвращает true если задача завершена 
                        (нормально, исключение или отменена)   
                    
                    boolean isCanceled() - true, если задача отменена
                    
                    boolean cancel(boolean mayInterrupt) - попытка отменить задачу, 
                        возвращает false, если не может отменить (обычно если уже завершена, отменена)
                        возращает true - при успешной отмене
                        обычно отменяет еще не запущенную задачу
                        с флагом mayInterrupt=true попытается отменить уже запущенную задачу
                    
                    V get() - получает результат задачи, ждет до окончания 

                    V get(long timeout, TimeUnit unit) - ждет и получает результат задачи,
                        при превышении таймаута - исключение TimeoutException

 
                Пример:
                    ExecutorService service = null;
                    try {
                        service = Executor.newSingleThreadExecutor();
                        Future<?> result = service.submit(() -> {
                            for (int i=0; i<; i++) {
                                counter++
                            }
                        }); // задача не возвращает ничего (null), поэтому Future<?>
                        result.get(10, TimeUnit.SECONDS);
                    } catch (TimeoutException e) {
                        System.out.println("timeout");
                    } finally {
                        if (service != null) {
                            service.shutdown();
                        }
                    }

            Callable

                java.util.concurrent.Callable

                @FunctionalInterface
                public interface Callable<V> {
                    V call() throws Exception;
                }

                в отличие от Runnable:
                    - возвращает результат
                    - может выбрасывать исключение

                Callable vs Supplier

                    имеют почти общую сигнатуру, кроме исключения
                    в некоторых случаях лямбда-выражение нельзя различить
                    напр.
                        void useCallable(Callable<Integer> expr) {}
                        void useSupplier(Supplier<Integer> expr) {}

                        useCallable(() -> {throw new Exception()}); // OK
                        useSupplier(() -> (throw new Exception())); // doesn`t compile: supplier doesn`t support exception

                        void use(Callable<Integer> expr) {}
                        void use(Supplier<Integer> expr) {}

                        use(() -> {throw new Exception()}); // doesn`t compile, can`t resolve method, ambiguous lambda-expression

                Future<Integer> result = service.submit(() -> 42);
                int i = result.get();

        Ожидание завершения всех задач

            вариант 1:
                каждый метод submit() возвращает Future
                для каждого Future вызываем get() и ждем

            вариант 2:
                если не нужны результаты задач
                вызываем метод shutdown() у executor
                вызываем метод awaitTermination(long timeout, TimeUnit unit)

                ExecutorService service = null;
                try {
                    service = Executor.newSingleThreadExecutor();
                    service.submit(...);
                    ...
                } finally {
                    if (service != null) {
                        service.shutdown();
                    }
                }
                service.awaitTermination(1, TimeUnit.MINUTES)
                if (service.isTerminated()) {
                    System.out.println("all tasks terminated");
                } else {
                    System.out.println("At least one task is still running");
                }



        Управление очередью задач

            ScheduledExecutorService service = Executor.newSingleThreadScheduledExecutor();

            наследник ExecutorService, имеет дополнительные методы

                schedule(Callable<V> c, long delay, TimeUnit unit) -
                    запускает задачу после задержки
                schedule(Runnable r, long delay, TimeUnit unit) -
                    запускает задачу после задержки
                scheduleAtFixedRate(Runnable r, long initDelay, long period, TimeUnit unit) -
                    запускает задачу после задержки и создает новую с указанной периодичностью
                scheduleAtFixedDelay(Runnable r, long initDelay, long delay, TimeUnit unit) -
                    запускает задачу после задержки и затем продолжает запускать
                    с указанной задержкой от окончания предыдущей
                
                первые два метода возвращают ScheduledFuture - обычный Future, 
                    но с методом getDelay() (показывает оставшуюся задержку)

                пример:
                    ScheduledExecutorService service = Executor.newSingleThreadScheduledExecutor();
                    Runnable task1 = () -> System.out.println("Hello");
                    Callable<String> task2 = () -> "Hell";

                    Future<?> result1 = service.schedule(task1, 20, TimeUnit.SECONDS);
                    Future<?> result2 = service.schedule(task2, 2, TimeUnit.MINUTES);

                методы выставляют задачи в очередь в будущем, точное время запуска 
                    зависит от ОС или ScheduledExecutorService может быть остановлен до 
                    истечения задержки (shutdown), тогда задача не будет запушена

                методы scheduleAtFixed... запускают задачу после начальной задержки
                    и продолжают запускать с некоторой периодичностью
                scheduleAtFixedDelay: с заданным периодом от окончания предыдущего
                scheduleAtFixedRate: с заданной периодичностью, независимо закончилось предыдущее или нет
                    если задачи не успевают завершится, все равно будет ставить в очередь
                    возможно накопление

                    не возвращают результат, поэтому только Runnable

        Пулы потоков

            пул потоков - группа преднастроенных потоков для переиспользования

            ExecutorService Executor.newSingleThreadExecutor() -
                executor с одним потоком, задачи обрабатываются в порядке поступления
            ScheduledExecutorService Executor.newSingleThreadScheduledExecutor() -
                executor с одним потоком, задачи могут ставится в очередь
            ExecutorService Executor.newCachedThreadPool() - 
                пул потоков, создает новый поток если нужно, но может использовать уже освободивщиеся
            ExecutorService Executor.newFixedThreadPool(int nThreads) -
                пул потоков с фиксированным числом переиспользуемых потоков
            ScheduledExecutorService Executor.newScheduledThreadPool(int nThreads) -
                аналогично предыдущему, но с очередью

            однопоточные executor будет ждать, если уже запущенно задание
            executor с пулом запускает следующий поток из пула, если нет свободных 
                - также ждет

            newCachedThreadPool() создает неограниченное количество потоков
                опасно для длительных частых операций

            Определение размера пула

                смотреть на основной используемый ресурс
                если это CPU-затратная операция, создавать потоков больше чем ядер
                    может быть не очень
                    Runtime.getRuntime().availableProcessors();
                если работа с базой данных, сетью, диском можно создавать пул с большим
                    размером чем число ядер

## 8. IO

### 8.1 Основы файлов / директорий

#### 8.1.1 Файловая система

**файл** - запись в файловой системе, содержащая данные
**директория** - запись в файловой системе, содержащая файлы и другие директории
**корневая директория** - в Win имя диска 'c:\\', Lin - '/'
**путь** - строковое представление файла/директории в файловой системе

#### 8.1.2 Класс File

java.io.File
        
Представляет файл или директорию. Сам не читает / не записывает данные

Основные методы:

* exists()
* getName()
* getAbsolutePath()
* isDirectory()
* isFile()
* length()
* lastModified() - в милисекундах от начала эпохи
* delete() - если удаляется директория, должна быть пуста
* renameTo(File)
* mkdir()
* mkdirs() - создает директорию и все родительские
* getParent()
* listFiles() 

### 8.2 Потоки

#### 8.2.1 Номерклатура потоков

**Байтовые** потоки vs **символьные** потоки

* потоки, имеющие `Stream` в названии, - байтовые. Читают/пишут любые данные или байты
* потоки, имеющие `Reader`/`Writer` в названии, - символьные. Работают только с символами, строками 

Напр. `FileInputStream` и `FileReader`

**Input** vs **Output**
                
* обычно любой **Input** поток имеет соответствующий **Output** и наоборот
* аналогично для **Reader**/**Writer**
* есть исключения (напр. **PrintWriter**)

**Low-level** vs **High-level**

* низкоуровневые потоки непосредственно подключаются к источнику данных (файлу, строке и т.п.).  Напр. `FileInputStream` побайтово читает файл
* высокоуровневые потоки подключаются к другим потокам через обертывание. Например `BufferedReader b = new BufferedReader(new FileInputStream("1.txt"));`
* в реальных проектах всегда использовать потоки с буферами. Не использовать низкоуровневые `FileInputStream` / `FileOutputStream`.

#### 8.2.2 Иерархия потоков

В основе абстрактные классы **InputStream**, **OutputStream**, **Reader**, **Writer**. Наследники обычно имеют их в именах как суффиксы

Параметры в конструкторах высокоуровневых потоков имеют тип абстрактных классов. Но при использовании нужен реальный класс. Например:

    new BufferedInputStream(new FileReader()) // DOES NOT COMPILE (reader vs inputStream)
    new BufferedInputStream(new InputStream()) // DOES NOT COMPILE (abstract class)

|Поток              |       |Описание                   |
|-------------------|-------|---------------------------|
|InputStream        |   -   |абстрактные классы         |
|OutputStream       |   -   |                           |
|Reader             |   -   |                           |
|Writer             |   -   |                           |
|                   |       |                           |
|FileInputStream    |  Low  |байтовый файловый поток    |
|FileOutputStream   |  Low  |                           |
|FileReader         |  Low  |символьный файловый поток  |
|FileWriter         |  Low  |                           |
|                   |       |                           |
|BufferedReader     |  High |поток с буфером            |
|BufferedWriter     |  High |                           |
|                   |       |                           |
|ObjectInputStream  |  High |десериализация объетов     |
|ObjectOutputStream |  High |                           |
|                   |       |                           |
|InputStreamReader  |  High |символьный поток           |
|OutputStreamWriter |  High |                           |
|                   |       |                           |
|PrintStream        |  High |форматированный символьный |
|PrintWriter        |  High |                           |

#### 8.2.3 Общие операции над потоками 

**Закрытие потоков** - обязательная операция. Через try-with-resourses или блок `finally`. Ошибка при закрытии файла например, блокирует с ним работу до закрытия приложения.

**flush** - отправка данных в выходной поток (например файловый) не значит, что данные попадают сразу на диск. Могут хранится в памяти, кешах и т. п. Метод `flush()` принудительно сбрасывает данные на диск. Но это затратно. Может имеет смысл для больших файлов периодически (не на каждую запись) вызывать `flush`. При закрытии потока `flush` вызывается автоматически.

**mark** - комбинация методов `markSupported()`, `mark(int)`, `reset()` для возврата к уже пройденным блокам потока

**skip** - пропуск части потока

### 8.3 Работа с потоками

#### 8.3.1 FileInputStream, FileOutputStream

Потоки для работы с файлами.
Конструкторы принимают файл или строку.

Основные методы `int read()`, `write(int)`

Чтение файла обычно или пока будет возвращено -1(EOF), или просто прервав цикл.

Из-за необходимости возврата -1, метод `read()` возвращает `int`, а не `byte`.
Для совместимости `write()` также работает с `int`.

Читать можно в массив `int read(byte[])`. Возвращает количество реально прочитанных байт. Запись также есть из массива. 

Пример использования (копирование файлов, не оптимально):

    public void copy(File source, File dest) {
        try (InputStream in = new FileInputStream(source);
                      OutputStream out = new FileOutputStream(dest)) {
            int b;
            while ((b = in.read()) != -1) {
                out.write(b);
            }
        }  // try-with-resource (close() не нужен)
    }

#### 8.3.2 BufferedInputStream, BufferedOutputStream

Обертки для низкоуровневых потоков.

Чтение/запись через массивы байтов:

* **long read(byte[])** - читает данные из потока в массив. Возвращает количество прочитанных. `0` - если конец потока.
* **write(byte[], int offset, int length)** - записывает из массива

Размер буфера обычно степень 2 (ОС также работают по степеням). 1024 обычный размер. Увеличение / уменьшение размера буфера может влиять на производительность, но менее значительно чем переход к буферизированным потокам от обычных.

    public void copy(File source, File dest) {
        try ( InputStream in 
                = new BufferedInputStream(new FileInputStream(source));
            OutputStream out 
                = new BufferedOutputStream(new FileOutputStream(dest))) {
            byte[] buffer = new byte[1024];
            int lengthRead;
            while ((lengthRead = in.read(buffer)) > 0) {
                out.write(buffer, 0, lengthRead);
                out.flush();
            }
        }
    }

#### 8.3.3 FileReader, FileWriter

Для работы с текстовыми файлами

Методы:

* **int read()**
* **int read(char[])**
* **write(int)**
* **write(char[], off, len)**
* **write(String, off, len)**

#### 8.3.4 BufferedReader, BufferedWriter

Дополнительно имеет метод String readLine() (возвращает null в конце файла)

Запись:

* **write(String)**
* **newLine()**

#### 8.3.5 ObjectInputStream, ObjectOutputStream

Для сохранения / восстановления объектов классов через сериализацию.

Интерфейс Serializable:

* маркерный интерфейс без методов
* можно отмечать класс, при этом его свойства также должны быть сериализуемы

В процессе сериализации может возникать исключение.

#### 8.3.6 PrintStream, PrintWriter

Классы для записи java-объектов в текстовые потоки. Например `System.out` и `System.err` это `PrintStream`

Наследуют методы **OutputStream** и **Writer**, плюс свои методы `print()`, `println()`, `format()`, `printf()`
        
Эти методы не генерируют исключений, вместо этого метод **checkError()**

**print()** - переопределен для объектов через `String.valueOf()` или `toString()`
**println()** - аналог **print()**, но добавляет перенос строки
**format()** и **printf()** - аналоги `String.format()`
**printf()** - из С

#### 8.3.7 Иерархия потоков

**Writer** 

* абстрактный
* запись символьных потоков

**OutputStreamWriter** --> Writer
            
* конструкторы: OutputStream, кодировка
* связывает байтовые потоки с символьными (внутри байтовый, внешне символьный)
* символы, переданные в этот поток преобразуются в байты в соответствии с кодировкой
* методы: `write(char[])`

**FileWriter** --> OutputStreamWriter

* конструкторы: File, строка-имя, флаг append
* для записи символьных потоков в файл
* методы: `write(char[])`

**BufferedWriter** --> Writer

* конструкторы: `Writer`, размер буфера
* методы: `newLine()`


**PrintWriter** --> Writer

* конструкторы: File, строка-имя файла, Writer, OutputStream
* методы: print(), println(), format()
* нет исключений, checkError(), autoFlush


**OutputStream**
    
* абстрактный

**FileOutputStream** --> OutputStream
    
* конструкторы: File, строка-имя, пересоздавать файл или нет

**ObjectOutputStream** --> OutputStream
    
* конструкторы: `OutputStream`
* сериализация объектов
* методы `writeInt()` и т.п., `writeObject()`

**FilterOutputStream** --> OutputStream
   
* реализация абстрактного
* конструкторы: `OutputStream`

**BufferedOutputStream** --> FilterOutputStream
   
* конструкторы: `OutputStream`, размер буфера

**DataOutputStream** --> FilterOutputStream
  
* конструкторы: `OutputStream`
* для записи примитивных типов: `writeByte()`, `writeInt()` и т.п.

**PrintStream** --> FilterOutputStream

* конструкторы: File, строка-имя, OutputStream, флаг autoFlush
* не вбрасывает `IOException`, вместо - внутренний флаг и `checkError()`
* можно настроить flush автоматически
* методы `print()` (переопределенные), `println()`













## 9. NIO.2

### 9.1 Введение в NIO.2

#### 9.1.1 История развития

Этапы развития:

* Java 1.1 - java.io: использование байтовых потоков для взаимодействия с файлами
* Java 1.4 - NIO (non-blocking): buffers и channels для замены байтовых потоков (позволяют перемещаться по потоку без блокировки ресурса)
* Java 7 - NIO.2: замена `java.io.File` - более логичная, производительная и т. п.

#### 9.1.2 Интерфейс Path

Это представление пути файла / директории в файловой системе. В этой части аналог `java.io.File`. Но в отличие от `java.io.File` поддерживает работу с сивольными ссылками.

Почему интерфейс: разные реализации под разные файловые системы / операционные системы.

Создается через фабричный класс `java.nio.Paths`.

Используется в методах вспомогательного класса `java.nio.Files`.

Еще есть вспомогательный класс `java.nio.FileSystems`, через который можно получать экземпляр `java.nio.FileSystem`, который также взаимодействует с `Path`.

#### 9.1.3 Создание Path

##### 9.1.3.1 Использование класса Paths

фабричный класс `java.nio.files.Paths`, статический метод **get(String)**

    Path path1 = Paths.get("pandas/cuddly.png");
    Path path2 = Paths.get("c:\\zooinfo\\November\\employees.txt");
    Path path3 = Paths.get("/home/zoodirector");

Абсолютный vs относительный путь: начинается или нет путь с корневой директории (платформозависимо)

Вариант метода с списком строк **get(String...)**: создает путь, используя платформозависимый разделитель

Вариант через URI: **get(URI)**

    Path path1 = Paths.get(new URI("file://pa/1.png")); // Runtime exception
    Path path2 = Paths.get(new URI("file:///c:/zoo-info/November/emps.txt"));
    Path path3 = Paths.get(new URI("file:///home/zoodirectory"));

Путь должен быть абсолютным, иначе исключение в рантайме. Можно передавать не только файлы, а `http://`, `ftp://` и др.

Есть обратный метод у класса Path **URI toUri()**

##### 9.1.3.2 Доступ к объекту FileSystem

Аналог создания пути через объект **FileSystem**

    Path p = FileSystems.getDefault().getPath("p/1.txt");

`Paths.get()` использует его же

Можно подключаться к другой файловой системе, например: 

    FileSystem fileSystem = FileSystems.getFileSystem(
        new URI("http://www.selikoff.net"));


##### 9.1.3.3 Взаимодействие с legacy

В класс `File` добавлен метод **toPath()**:

    File file = new File("pandas/cuddly.png");
    Path path = file.toPath();

Аналогично из `Path` можно получить `File`

    Path path = Paths.get("cuddly.png");
    File file = path.toFile();






### 9.2 Взаимодействие с путями и файлами

#### 9.2.1 Опциональные аргументы методов

Часть методов NIO.2 API принимают дополнительные флаги в форме vararg

|Опция           |Когда применяется      |Что значит                          |
|----------------|-----------------------|------------------------------------|
|NOFOLLOW_LINKS  |Проверка существования,|Не переходить по ссылкам, а их самих|
|                |чтение, копи-е и др.   |обрабатывать                        |
|FOLLOW_LINK     |Обход дерева           |Переход по ссылкам                  |
|COPY_ATTRIBUTES |Копирование            |Копировать и атрибуты файлов        |
|REPLACE_EXISTING|Копирование, перемещ-е |Заменять, если уже есть             |
|ATOMIC_MOVE     |Перемещение            |Атомарное, если поддерживается      |

Даже если метод использует единственную опцию, сделано именно через vararg, а не например `boolean` для совместимости с будущими изменениями. Сигнатуру метода не придется менять.

#### 9.2.2 Использование Path

##### 9.2.2.1 Просмотр пути

**String toString()** - вывод представление

**int getNameCount()** и **getName(int)** - для обхода по частям пути. Индекс с 0, корневой элемент не входит в эти части.

    Path path = Paths.get("/land/hippo/harry.happy");
    System.out.println("The Path Name is: "+path);
    for(int i=0; i<path.getNameCount(); i++) {
        System.out.println(" Element " + i + " is: " + path.getName(i));
    }

##### 9.2.2.2 Доступ к частям пути через методы

**Path getRoot()** - возвращает корневую директорию (или null если относительный путь)
**Path getParent()** - возвращает родительский путь. Не достраивает пути, если это например односительный путь.
**Path getFileName()** - возвращает последний элемент в пути (не обязательно файл)





##### 9.2.2.3 Проверка isAbsolute() и toAbsolutePath()

**isAbsolute()** - проверяет абсолютный или нет. Платформозависимый

**toAbsolutePath()** - преобразует в абсолютный добавлением текущей рабочей директории. Если уже абсолютный - просто копию возвращает. 

Так можно получить текущую рабочую директорию:

    Path cwd = Paths.get("").toAbsolutePath();


##### 9.2.2.4 Создание пути через subpath()

**Path subpath(int start, int end)** - создает путь из элементов. Корневой не включается (его нет в элементах). Последний индекс не включается.

    Path p2 = p1.subpath(0, 3);

Если индексы выходят за количество элементов - исключение в рантайме.
Также исключение если стартовый индекс и конечный равны.

##### 9.2.2.5 Метод relativize()

Вычисляет путь между двумя путями

    Path path1 = Paths.get("fish.txt");
    Path path2 = Paths.get("birds.txt");
    Path path3 = path1.relativize(path2)); // ../bird.txt

Пути или оба относительные, или оба абсолютные, иначе исключение в рантайме.

Если пути на разных корневых директориях, также исключение

##### 9.2.2.6 Объединение путей через resolve()

Использует исходный путь как базу, добавляя путь, переданный параметром

     final Path path1 = Paths.get("/cats/../panther");
     final Path path2 = Paths.get("food");
     System.out.println(path1.resolve(path2)); // "/cats/../panther/food"

Не очищает символы в путях. 

Если конечный путь уже абсолютный, он и будет возвращен.

##### 9.2.2.7 Очистка пути через normalize()

Сокращает путь при наличии `.` и `..`.

    Path p = Paths.get("E:\data\..\user\home").normalize(); // E:\user\home

##### 9.2.2.7 Проверка существования файла через toRealPath

Возращает нормализованный абсолютный путь, если файл существует. Иначе вызывает исключение.

Это единственный метод, который реально взаимодействует с файловой системой.



#### 9.2.3 Работа с Files

##### 9.2.3.1 Проверка существования exists()

**Files.exists(Path)** - истина, если файл существует. Не вызывает исключения, если файла нет.

##### 9.2.3.2 Проверка уникальности isSameFile()

Сначала проверяется равенство путей, если они одинаковы (equals) возвращается true (даже если файлы не существуют). Если разные - вычисляются нормализованные пути и сравниваются. При этом проверяется существование файлов. Если нет - исключение.

Содержимое файлов никак не анализируется, т. е. проверка одинаковых файлов в разных директориях даст false.

Точно также проверяет директории.

##### 9.2.3.3 Создание директорий createDirectory() и createDirectories()

**createDirectory(Path)** - создает директорию по указанному пути. Предполагается что, все родительские директории уже существуют. Иначе - `IOException`. Если сама директория уже существует - также исключение

**createDirectories(Path)** - создает директорию и родительские директории, указанные в пути. Если они существуют или конечная директория существует, исключение не вызывается.



##### 9.2.3.4 Копирование copy()

