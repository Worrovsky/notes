<!-- MarkdownTOC autolink="true" uri_encoding="false" levels="2,3" -->

- [1. Основы](#1-Основы)
    - [1.1 Установка и настройка](#11-Установка-и-настройка)
    - [1.2 Образы \(Images\)](#12-Образы-images)
    - [1.3 Запуск контейнеров](#13-Запуск-контейнеров)
    - [1.4 Проброс портов](#14-Проброс-портов)
    - [1.5 Тома](#15-Тома)
    - [1.6 Логи](#16-Логи)
    - [1.7 Переменные окружения](#17-Переменные-окружения)
- [2. Удаленное подключение к docker](#2-Удаленное-подключение-к-docker)
    - [2.1 Внутреннее устройство](#21-Внутреннее-устройство)
    - [2.2 Docker socket](#22-docker-socket)
    - [2.3 Настройка демона Docker](#23-Настройка-демона-docker)
    - [2.4 Настройка удаленного подключения к демону](#24-Настройка-удаленного-подключения-к-демону)
    - [2.5 Работа с разными подключениями на клиенте \(context\)](#25-Работа-с-разными-подключениями-на-клиенте-context)
    - [2.6 Другие варианты подключений](#26-Другие-варианты-подключений)
    - [2.7 Защищенное удаленное подключение к докеру](#27-Защищенное-удаленное-подключение-к-докеру)
- [3. Сети в Docker](#3-Сети-в-docker)
    - [3.1 Обзор](#31-Обзор)
    - [3.2 Сеть типа bridge](#32-Сеть-типа-bridge)
    - [3.3 Сеть типа host](#33-Сеть-типа-host)
    - [3.4 Команды работы с сетями в Docker](#34-Команды-работы-с-сетями-в-docker)
    - [3.5 Пример запуска контейнера и настройка сети](#35-Пример-запуска-контейнера-и-настройка-сети)
    - [3.6 Настройка сети](#36-Настройка-сети)
    - [3.7 Пример объединения контейнеров в несколько сетей](#37-Пример-объединения-контейнеров-в-несколько-сетей)
- [4. Логгирование](#4-Логгирование)
    - [4.1 Основы](#41-Основы)
    - [4.2 Драйверы логгирования](#42-Драйверы-логгирования)
    - [4.3 Настройки драйвера для контейнера](#43-Настройки-драйвера-для-контейнера)
    - [4.4 Чтение логов \(dual logging\)](#44-Чтение-логов-dual-logging)
    - [4.5 Настройка вывода идентификатора контейнера в логах](#45-Настройка-вывода-идентификатора-контейнера-в-логах)
- [5. Хранение данных](#5-Хранение-данных)
    - [5.1 Основы](#51-Основы)

<!-- /MarkdownTOC -->

[coursera](https://www.coursera.org/learn/docker-osnovy)

[habr](https://habr.com/ru/post/310460/)

## 1. Основы

### 1.1 Установка и настройка

#### 1.1.1 Установка

[docs](https://docs.docker.com/engine/install/ubuntu/)

#### 1.1.2 Удаление

    sudo apt-get purge docker-ce docker-ce-cli containerd.io
    # дополнительно
    sudo rm -rf /var/lib/docker
    sudo rm -rf /var/lib/containerd

#### 1.1.3 Сервисы

[docs](https://docs.docker.com/engine/install/linux-postinstall/#configure-docker-to-start-on-boot)

Два сервиса: **docker.service** и **containerd**. По умолчанию - автозапуск. Можно управлять через systemctl:

    sudo systemctl disable docker.service
    sudo systemctl disable containerd.service

#### 1.1.4 Управление без прав root

[docs](https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user)

Демон Docker запускается от имени root, поэтому запуск контейнеров должен выполнятся от root:

    sudo docker run hello-world

Варианты обхода:

* создание группы `docker` (большие привилегии)
* Rootless mode

#### 1.1.5 Что слушает демон Docker

По умолчанию - через сокет Unix

Можно настроить удаленные команды через TCP, но нужна защита (TLS)


### 1.2 Образы (Images)

#### 1.2.1 Запуск образа

**Образ** - файл, представляющий операционную систему с компонентами и файлами. Используется для запуска контейнера. Только для чтения.

Запуск контейнера:

    docker run --name <имя для конейнера> <координаты образа> 

Координаты образа в двух вариантах (имя обязательно): 

    NAME[:TAG]
    NAME[@DIGEST]

Например:

    docker run --name test nginx:latest

#### 1.2.2 docker pull

Скачивает образ из репозитория 

    docker pull <координаты образа>

По умолчанию - из центрального хранилища Docker Hub

Команда `run` сама скачивает образ, если не находит локально

#### 1.2.3 docker images / docker image ls

Просмотр образов на локальной машине

    # только просмотр
    docker images
    # универсальная команда для работы с образами
    docker image ls|rm|pull

Опции:

* `-a` - все образы, в том числе скрытые
* `--digests` - выводить хеш-сумму образов
* `--filter`, `-f` - применить фильтр
* `--format` - форматировать вывод
* `--quiet`, `-q` - только id образов (для скриптов)

#### 1.2.4 docker tag

Назначает тег образу.

Обычная практика для docker переназначение тегов. Например при выходе новой версии, ей назначается тег `latest`.

Уникальным всегда остается `image id`

Если у образа нет тега - по умолчанию `latest`.

#### 1.2.5 docker inspect

Выводит инфо (JSON) по образу или контейнеру.

Например в `.[0].GraphDriver.Data.UpperDir` указана локальная директория, где хранятся файлы образа: `/var/lib/docker/overlay2/`

#### 1.2.6 docker image rm

Удаление образов с локальной машины

`--force`, `-f` - принудительное удаление


### 1.3 Запуск контейнеров

#### 1.3.1 docker run

Запуск изолированного контейнера, с собственной файловой и сетевой системами. Запуск на локальной машине или удаленном сервере (настройки docker CLI).

    docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]

По умолчанию - в режиме `foreground` (привязан к терминалу). Прервать - `Ctrl + C`

Запуск в фоновом (detached) режиме. Возвращает UUID контейнера. Присваивает случайное имя:

    docker run -d nginx

Запуск в интерактивном режиме (с запуском например bash):

    docker run -it ubuntu bash

Запуск с заданием имени контейнера

    docker run --name my_container ubuntu

#### 1.3.2 Просмотр состояния контейнеров

    docker ps -as

#### 1.3.3 docker start / docker stop

Запуск остановленного контейнера
    
    docker ps -a
    docker start nginx

Остановка контейнера:

    docker stop nginx

#### 1.3.4 docker wait

ожидает завершения работы контейнера и выводит exit code

использовать для скриптов??

#### 1.3.5 docker pause

Останавлиет выполнение контейнера, посылая `SIGSTOP`

#### 1.3.6 Опция рестарт

Задает политику при остановке контейнера:

* `no` - по умолчанию не перезапускать контейнер
* `on-failure[:max-retries]` - перезапускать, если завершился с кодом отличным от 0
* `always` - всегда перезапускать, также при запуске демона (при перезапуске сервера)
* `unless-stopped` - аналогично `always`, но при `docker stop` останавливается

Пример:

    docker run -d --name=my_cont --restart=always

#### 1.3.7 docker inspect

Инфо (JSON) о запущенном контейнере:

    docker inspect my_container

#### 1.3.8 docker attach

Присоединение потоков ввода / вывода к запущенному контейнеру

    # запускаем в фоновом режиме
    docker run -d --name topdemo ubuntu

    # подключаемся
    docker attach topdemo

Выход из контейнера:

* `Ctrl + C` - останавливает контейнер
* `Ctrl + p, Ctrl + q` - отключается от контейнера, контейнер продолжает работать
* `exit CODE` - завершение контейнера с указанным кодом

#### 1.3.9 docker exec

Запуск нового процесса внутри запущенного контейнера

Опции:

* `--detach` , `-d` - запуск в фоновом режиме
* `--env` , `-e` - задать переменные окружения
* `--interactive` , `-i` - подключить STDIN
* `--tty` , `-t` - назначить TTY

Пример:

    docker exec -ti nginx bash


### 1.4 Проброс портов

#### 1.4.1 Настройка типа сети

По умолчанию изолирована от сети.

Типы сети при запуске контейнера:

* `none` - отсутствует
* `bridge` - подключение через интерфейс типа мост (NAT). Значение по умолчанию
* `host` - сеть хоста используется
* `container <имя:id>` - используется сеть указанного контейнера
* `network` - подключение к docker-сети, созданной ранее через `docker network create`

Пример:

    docker run --network="bridge" nginx

Посмотреть сетевые интерфейсы в контейнере: 

    apt update
    apt install iproute2 # для ip
    apt install iputils-ping # для ping
    ip address

#### 1.4.2 Проброс портов

Примеры:

    -p 8080:80                  80 порт контейнера в порт 8080 хоста
    -p 192.168.1.100:8080:80    то же, но при обращении на конкретный адрес хоста
    -p 8080:80/udp              по udp только

    docker run -p 8080:80 nginx


Посмотреть какие порты открыты:

* `docker ps`, колонка POSTS
* `docker inspect`

### 1.5 Тома

Типы томов (volumes):

* **bind mount** - просто директория или файл с хоста
* **volume** - именованный том, управляемый докером
* **tmpfs** - временные файлы, существующие только в памяти

Два типа синтаксиса:

* `-v`, `--volume`
* `--mount`

Примеры:

    # web1 на хосте отображается в in в контейнере
    docker run -d --name web1 -v /data/web1:/in nginx

    # аналогично для --mount
    docker run --mount type=bind,src=/data/web1,dst=/in nginx

### 1.6 Логи

Логи в docker'е - это сообщения, которые приложения внутри контейнера отправляют в STDOUT и STDERR. Docker их дополнительно агреггирует и выдает через `docker logs`

Работает с разными типами драйверов, например: **json-file** и **journald**

Примеры:
    
    # просмотр всех логов контейнера web:
    docker logs web
    # последние несколько записей: 
    docker logs --tail=5 web
    # выводить логи в реальном времени:
    docker logs -f web
    # последние за 5 мин
    docker logs --since=5m web
    # c выводом времени:
    docker logs -t web
    
Какой тип драйвера у контейнера - см. `docker inspect`. Можно менять.

По сути перехватывает сообщения и сохраняет их в файл`/var/lib/docker/<container id>/` или сервису.

### 1.7 Переменные окружения

    # передача переменной из хостовой машины
    docker run -e MYVAR1 nginx

    # установка переменной окружения
    docker run --env MYVAR2=foo nginx

    # установка переменных окружения из файла (ключ=значение)
    docker run --env-file ./env.list nginx


## 2. Удаленное подключение к docker

### 2.1 Внутреннее устройство

Составные части:

* runC - низкоуровневая среда выполнения контейнера. Быстрая, легкая, только запускает контейнеры.
* containerd-shim - вспомогательная среда
* containerd - высокоуровневая среда выполнения контейнеров: контроль, управление, создание сети и т. п.
* движок докера - создание контейнера из образа, передача его в containerd

### 2.2 Docker socket

Демон `dockerd` имеет интерфейс (socket), который обслуживает REST-запросы.

3 типа сокетов:

* **unix**: например `/var/run/docker.sock`
* **tcp**
* **fd** - сокет, которым управляет systemd. Настройки сокета описываются в файле `docker.socket` (по умолчанию там `/var/run/docker.sock`)

По умолчанию слушает `/var/run/docker.sock`. Запускается через `dockerd -H fd://`

При запуске через `-H` можно настроить прослушку других сокетов, tcp портов

    !! Открытие tcp порта демона без защиты = root доступ к хосту 

Просмотр версии клиента и сервера (демона):

    docker version

Через API демона можно создавать, запускать контейнеры, реагировать на события. 

Можно смонтировать `docker.sock` в контейнер. В контейнере тогда можно управлять демоном на хосте (опасно).

### 2.3 Настройка демона Docker

Настройка демона dockerd:

* через JSON файл конфигурации
* через флаги запуска dockerd

Можно оба способа. При совпадении параметров - ошибка запуска.

Создать файл настроек `/etc/docker/daemon.json`.

Пример файла:

    {
        "debug": true,
        "tls": true,
        "tlscert": "/var/docker/server.pem",
        "tlskey": "/var/docker/serverkey.pem",
        "hosts": ["tcp://192.168.59.3:2376"]
    }

При изменении конфигурации может перезагрузка:

    sudo kill -SIGHUP $(pidof dockerd)

Если что - см. логи. Ubuntu - `/var/log/syslog`

### 2.4 Настройка удаленного подключения к демону

Нужно включить tcp сокет (по умолчанию будет незашифрованный и неаутентифицированный).

Незашифрованный демон обычна на порту **2375**, зашифрованный - **2376**

Включение через запуск демона с флагом `-H`:

    # все сетевые интерфейсы
    -H tcp://0.0.0.0:2375
    # или конкретный сетевой интерфейс
    -H tcp://192.168.57.241:2375

**Первый способ настройки**: через systemd
    
    # редактируем конфигурационный файл
    systemctl edit docker
    # например usr/bin/dockerd -H tcp://0.0.0.0:2375
    # перезапускаем демон systemd
    systemctl daemon-reload
    # перезапускаем docker
    systemctl restart docker

Проверить: 

    # смотрим ключи запуска докера
    ps aux | grep docker
    # проверяем порт
    netstat -nl| grep 2375

**Второй способ настройки**: через конфигурационный файл

Cоздаем / редактируем `/etc/docker/daemon.json`

Добавляем записи в файл

    {
        "hosts": ["unix:///var/run/docker.sock",
        "tcp://127.0.0.1:2375"]
    }

Ключей запуска не будет видно, но можно порты проверить

### 2.5 Работа с разными подключениями на клиенте (context)

Со стороны клиента просмотр доступных подключений:
    
    docker context ls

`*` обозначен текущий используемый.

Добавить новое подключение

    doсker context create my-server --docker "host=tcp://83.43.1.123:2375"

Переключиться на использование:

    docker context use my-server

### 2.6 Другие варианты подключений

(без подробностей пока)

Использовать готовые контейнеры с настроенными подключениями

Пробросить сокет через ssh

### 2.7 Защищенное удаленное подключение к докеру

Все предыдущие примеры дают свободный доступ к демону любому, кто сможет подключиться к порту

Защищенное соединение использует сертификаты.

[Подробнее](https://docs.docker.com/engine/security/protect-access/)

## 3. Сети в Docker

### 3.1 Обзор

В основе - Container Network Model. Docker предоставляет набор драйверов, но система расширяемая. Внутри работает через `iptables` или подобные

Стандартные драйвера / типы сетей докера:

* **bridge** - драйвер по умолчанию. Служит для объединения нескольких контейнеров в сеть, но эта сеть изолирована от сети хоста.
*  **host** - контейнеры соединены с сетью хоста. Производительней чем **bridge**: не нужно обрабатывать NAT-трафик
*  **overlay** - соединяет несколько демонов докера в одну сеть
*  **macvlan** - позволяет назначать MAC адреса контейнерам, считая их физическими устройствами.
*  **none** - польностью изолирует контейнер от сети. Можно подключать сторонние сетевые драйверы

### 3.2 Сеть типа bridge

Докер создает программный мост с именем `docker0`:

    ip addr 

Сетевой обмен между контейнерами, подключенными к одному мосту, разрешен. Контейнеры, подключенные к разным мостам - изолированы

По умолчанию при запуске контейнер присоединяется к сети типа bridge с именем `bridge`. Можно создать пользовательскую сеть и при запуске контейнера указать ее, или поключить работающий контейнер к сети.

Предпочтительнее - создавать сеть явно, не использовать сеть по умолчанию

Различия между пользовательской сетью и сетью по умолчанию:

* пользовательская сеть обеспечивает DNS разрешение имен контейнеров
    - доступ можно по именам контейнеров получать
    - в сети по умолчанию - только по ip или доп. настройки (`/etc/hosts` например)
* пользовательская сеть - более изолирована: контейнер без явного указания подключается к сети по умолчанию - неявно можно неожиданное поведение
* к пользовательской сети можно подключать / отключать контейнеры на лету
* пользовательская сеть - больше возможностей настроек. У сети по умолчанию нужно переопределять файл настроек и перезапускать демон
* контейнеры в сети по умолчанию разделяют переменные окружения

Контейнеры в одной сети видят порты друг друга. Для контейнеров другой сети или не Docker-хостов - явно нужно публиковать порты `-p` или `--publish`


### 3.3 Сеть типа host

Контейнер разделяет одно сетевое пространство имен с хостом:

* контейнер и хост-система имеют один ip-адрес
* возрастает производительность:
    - не надо выполнять NAT и проксировать порты

Контейнер или докер не могут изменять настройки сети.

Работает только на Linux-системах

Не получится запустить несколько контейнеров, используюших одинаковые порты (например nginx)

### 3.4 Команды работы с сетями в Docker

Основная - `docker network`

Просмотр списка сетей:

    docker network ls
    # по умолчанию есть bridge, host и none

Анализ сети (настройки сети, присоединенные контейнеры):

    docker network inspect <имя сети>

Создание сети: 

    docker network create <имя сети>
    docker network create --driver bridge <имя сети>


Разные параметры: тип (bridge по умолчанию), ip адреса и др.

Удаление сети:

    docker network rm <имя сети>

Подключение запущенного контейнера к сети:

    docker network connect <имя сети> <имя контейнера>

Отключение от сети:

    docker network disconnect <имя сети> <имя контейнера>

### 3.5 Пример запуска контейнера и настройка сети

[docs](https://docs.docker.com/network/network-tutorial-standalone/)

#### 3.5.1 Сеть по умолчанию

    # запуск образа apline с терминалом ash, подключена к сети по умолчанию
    docker run -dit --name alpine1 alpine ash
    docker run -dit --name alpine2 alpine ash

    # просмотр сети     
    docker network inspect bridge

    # работа из первого контейнера:
    docker attach alpine1
    ip addr show
    ping -c 2 google.com
    # ко второму может подключиться только зная ip адрес
    ping -c 2 172.17.0.3
    # по имени нельзя
    ping -c 2 alpine2
        bad address

    docker container stop alpine1 alpine2
    docker container rm alpine1 alpine2

#### 3.5.2 Пользовательская сеть

    # создаем сеть
    docker network create --driver bridge alpine-net

    # запускаем контейнеры с подключением к созданной сети
    docker run -dit --name alpine1 --network alpine-net alpine ash
    docker run -dit --name alpine2 --network alpine-net alpine ash

    # можем увидеть подключения к сети
    docker network inspect alpine-net

    # можно по имени контейнера подключаться внутри сети
    docker container attach alpine1
    ping -c 2 alpine2

    docker container stop alpine1 alpine2
    docker container rm alpine1 alpine2
    docker network rm alpine-net

### 3.6 Настройка сети

[docs](https://docs.docker.com/config/containers/container-networking/)

#### 3.6.1 Проброс портов внутрь контейнера

Из контейнера можно обращаться во внешний мир, но по умолчанию из внешнего мира к контейнеру нельзя обратиться.

 Есть **открытие (exposing) порта** - просто документация факта использования порта (например для систем оркестрации) и **публикация (publishing) порта** - доступность порта извне.

Если запустить контейнер без ключа `p`, будет только окртытие портов:

    docker run -d nginx
    docker container ls
        ID   IMAGE   STATUS         PORTS     
        45.. nginx   Up 2 seconds   80/tcp 

Если явно указать - произойдет публикация:
    
    docker run -d -p 8080:80 nginx
    docker container ls
        ID   IMAGE   STATUS         PORTS     
        45.. nginx   Up 2 seconds   0.0.0.0:8080->80/tcp, :::8080->80/tcp  

Порты могут автоматически назначаться из диапазона свободных портов, если запускаем с `-P` или `--publish-all=true`. Посмотреть настройку диапазона свободных портов:

    sysctl -a | grep port_range
        net.ipv4.ip_local_port_range = 32768    60999

Просмотр проброшенных портов:

    docker ports <контейнер>

По умолчанию порты пробрасываются с любого ip-адреса (0.0.0.0:8080->80). Можно ограничивать, например только локальные обращения:

    docker run ... -p 127.0.0.1:8080:80

Docker при запуске контейнеров создает правила в iptables. Можно добиться того же эффекта создав нужные правила в iptables

#### 3.6.2 IP адреса

Каждая сеть имеет адрес шлюза и маску подсети.

При подключении контейнера к сети, ему выдается адрес из пула адресов. 

Можно явно задать адрес (только для пользовательских сетей и при явной конфигурации подсети):

    # подключая работающий контейнер
    docker network connect <сеть> <контейнер> --ip ...
    # или при запуске
    docker run --network .. --ip ...

Имя хоста (`hostname`) для контейнера по умолчанию - контейнера.

Можно переопределять:

    docker run ... --hostname ...
    docker network connect --alias ...

### 3.7 Пример объединения контейнеров в несколько сетей

Задача: построить архитектуру: веб-приложение, база данных и связующий сервер приложений.

Можно все включить в один контейнер - но это нарушает философию Docker **один процесс - один контейнер**.

Минусы одного контейнера:

* сложность остановки / запуска
* обновление отдельного приложения - сборка всего контейнера

Решение: создать три контейнера и объединить их в 2 сети: front (веб-приложение и сервер приложений) и back (база данных и сервер приложений)

    docker network create front
    docker network create back

Создаем контейнеры и подключаем к сетям. Одновременно к двум при запуске нельзя подключить. Поэтому подключаем после запуска:

    docker run -dit --name web --net front alpine ash
    docker run -dit --name db --net back alpine ash
    docker run -dit --name app --net front alpine ash
    docker network connect back app

Контейнер, подключенный к нескольким сетям, будет иметь несколько сетевых интерфейсом. Проверить можно внутри контейнера:

    ipconfig
    ip addr

Если нужно несколько сетей прямо при запуске иметь, можно сначала создать контейнер, подключить сети, потом запустить:

    docker create ...
    docker network connect..
    docker container start ...

## 4. Логгирование

[docs](https://docs.docker.com/config/containers/logging/)

### 4.1 Основы

Это про логи приложений из контейнера. Логи самого демона докера - см. `/var/log/syslog`

Каждый процесс в Linux открывает 3 потока STDIN, STDOUT и STDERR.

Команды `docker logs` или `docker service logs` выводят содержимое потоков STDOUT и  STDERR, как если бы приложения контейнера запускались в терминале.

Команда `docker logs` может не показывать информации если:

* логирующий драйвер отправляет сообщения в файл, внешний сервис и игнорирует потоки вывода
* запущенное в контейнере приложение не выводит сообщения в потоки вывода, использует файлы, внешние сервисы и т. п.

Во втором случае можно перенаправлять сообщения в стандартные потоки.

[Пример из образа nginx](https://github.com/nginxinc/docker-nginx/blob/8921999083def7ba43a06fabd5f80e4406651353/mainline/jessie/Dockerfile#L21-L23)

[Пример из образа httpd](https://github.com/docker-library/httpd/blob/b13054c7de5c74bbaa6d595dbe38969e6d4f860c/2.2/Dockerfile#L72-L75)

### 4.2 Драйверы логгирования

Демон имеет драйвер по умолчанию, но контейнеру можно указать использовать другой драйвер.

Драйвер по умолчанию - `json-file`. Ротация по умолчанию отключена, возможно переполнение (можно настроить). Можно использовать драйвер `local` - по умолчанию включена ротация файлов. 

Настройка драйвера по умолчанию - файл `/etc/docker/daemon.json` ([docs](https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file)). `log-driver` задает тип драйвера, в `log-opts` - параметры устанавливаются:

    {
      "log-driver": "json-file",
      "log-opts": {
        "max-size": "10m",
        "max-file": "3"
      }
    }

После изменения файла - рестарт демона и новые контейнеры создавать:

    systemctl restart docker

Просмотр текущих настроек: 

    # возможно выводится только при переопределении конфигурации
    docker info

Если драйвера пишут логи в файлы, файлы хранятся в `/var/lib/docker/<container id>/`

### 4.3 Настройки драйвера для контейнера

#### 4.3.1 Установка драйвера при запуске

Параметры `--log-driver` и `--log-opt` при создании/запуске контейнера:

    docker run --log-driver none alpine

Просмотр настроек контейнера:

    docker inspect <контейнер>


#### 4.3.2 Режим доставки сообщений от контейнера драйверу

Два варианта:

* **блокирующий**
    - приостанавливается выполнение, пока сообщение не достигнет цели (файл, сетевой сервис)
* **не блокирующий**
    - сообщение записывается в буфер конечного размера, отдельный процесс доставляет сообщения
    - возможна потеря сообщений при переполнении буфера

Настройка:

    docker run -it --log-opt mode=non-blocking --log-opt max-buffer-size=4m alpine ping 127.0.0.1

#### 4.3.3 Переменные окружения и метки в логах

Некоторые драйверы могут выводить переменные `--env|-e` или метки `--label` в логи. Например так может `json-file` драйвер:

    docker run -dit --label production_status=testing -e os=ubuntu alpine sh
    # в логах будет содержаться:
        "attrs":{"production_status":"testing","os":"ubuntu"}


### 4.4 Чтение логов (dual logging)

До v 20.10 команда `docker logs` могла читать логи только драйверов `local`, `json-file`, `journald`.

С версии 20.10 можно читать логи любых драйверов за счет **dual logging**: дополнительно к заданному драйверу (???) используется драйвер `local` ( по умолчанию ротация, 5 файлов, 20 МБ) как кеш.

**dual logging** автоматически включается, если драйвер не обеспечивает возможность чтения логов (это все драйвера кроме `local`, `json-file`, `journald`)

Настройка **dual logging** - опции `--log-opt`:

* `cache-disabled` - установить в `true` для отключения. Для драйверов с поддержкой чтения не влияет ни на что.
* `cache-max-size` - 20m по умолчанию
* `cache-max-file` - 5 по умолчанию
* `cache-compress` - `true`

### 4.5 Настройка вывода идентификатора контейнера в логах

[docs](https://docs.docker.com/config/containers/logging/log_tags)

По умолчанию идентификатор - 12 символов идентификатора контейнера.

Можно переопределить через `--log-opt tag`. Например

    docker run --log-opt tag="{{.ImageName}}/{{.Name}}/{{.ID}}"

Перечень идентификаторов - в документации





## 5. Хранение данных

[docs](https://docs.docker.com/storage/)

### 5.1 Основы

#### 5.1.1 Обзор

По умолчанию все файлы создаются внутри контейнера в особом слое:

* данные не сохраняются, когда контейнер не существует
* слой контейнера, куда сохраняются данные, тесно связан с хостом; нельзя просто переместить данные куда-либо
* запись в слой выполняется через специальный драйвер-абстракцию. Другой вариант - запись напрямую в файловую систему хоста

Варианты хранилищ для контейнеров:

* **volumes**
* **bind mounts**
* **tmpfs mount** (linux только)
* **named pipe** (win только)

С точки зрения процессов внутри контейнера, все варианты равнозначны.

#### 5.1.2 Типы хранилищ

##### 5.1.2.1 Тип хранилищ volume

Часть ФС хоста, управляются (создаются / удаляются) docker'ом.

Обычно расположена в `/var/lib/docker/volumes`. Не-docker процессы не должны напрямую взаимодействовать.

Создаются командой `docker volume create` или в процессе создания контейнера. Конкретный экземпляр **volume** может монтироваться в несколько контейнеров. 

После удаления контейнеров не удаляется автоматически. Можно удалить командой `docker volume prune`

Можно назначить имя. Если не заданы - считается анонимным, docker назначает уникальное.

##### 5.1.2.2 Тип хранилища bind mounts

Просто часть ФС (файл или директория) хоста, доступная контейнеру.

Указывается по полному пути. Может не существовать, будет создан по требованию. 

Эффективны, но Docker CLI слабо может работать с такими.

Можно дать доступ к любым файлам, в т. ч. системным и управлять из контейнера работой хоста. Опасно. 

##### 5.1.2.3 Тип хранилища tmpfs mounts

Данные не сохраняются на диск, только в памяти.

Может использоваться для хранения например секретов (паролей, ключей и т. п.)



#### 5.1.3 Use case

**volume** - предпочтительный способ организации хранилищ. Когда использовать:

* данные нужно расшарить между несколькими контейнерами. **volume** остается после удаления контейнера. К нему можно подключать новые контейнеры
* не гарантируется, что хост содержит указанную директорию/файлы. Тома - прослойка между хостом и контейнером
* нужно сохранять данные на удаленном хосте или в облаке
* когда нужно делать резервные копии, перемещать хранилища