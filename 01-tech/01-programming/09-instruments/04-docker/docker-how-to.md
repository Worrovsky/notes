## Содержание

<!-- MarkdownTOC autolink="true" uri_encoding="false" levels="2,3" -->

- [1. Основы](#1-Основы)
    - [1.1 Установка и настройка](#11-Установка-и-настройка)
    - [1.2 Образы \(Images\)](#12-Образы-images)
    - [1.3 Запуск контейнеров](#13-Запуск-контейнеров)
    - [1.4 Проброс портов](#14-Проброс-портов)
    - [1.5 Тома](#15-Тома)
    - [1.6 Логи](#16-Логи)
    - [1.7 Переменные окружения](#17-Переменные-окружения)
- [2. Удаленное подключение к docker](#2-Удаленное-подключение-к-docker)
    - [2.1 Внутреннее устройство](#21-Внутреннее-устройство)
    - [2.2 Docker socket](#22-docker-socket)
    - [2.3 Настройка демона Docker](#23-Настройка-демона-docker)
    - [2.4 Настройка удаленного подключения к демону](#24-Настройка-удаленного-подключения-к-демону)
    - [2.5 Работа с разными подключениями на клиенте \(context\)](#25-Работа-с-разными-подключениями-на-клиенте-context)
    - [2.6 Другие варианты подключений](#26-Другие-варианты-подключений)
    - [2.7 Защищенное удаленное подключение к докеру](#27-Защищенное-удаленное-подключение-к-докеру)
- [3. Сети в Docker](#3-Сети-в-docker)
    - [3.1 Обзор](#31-Обзор)
    - [3.2 Сеть типа bridge](#32-Сеть-типа-bridge)
    - [3.3 Сеть типа host](#33-Сеть-типа-host)
    - [3.4 Команды работы с сетями в Docker](#34-Команды-работы-с-сетями-в-docker)
    - [3.5 Пример запуска контейнера и настройка сети](#35-Пример-запуска-контейнера-и-настройка-сети)
    - [3.6 Настройка сети](#36-Настройка-сети)
    - [3.7 Пример объединения контейнеров в несколько сетей](#37-Пример-объединения-контейнеров-в-несколько-сетей)
- [4. Логгирование](#4-Логгирование)
    - [4.1 Основы](#41-Основы)
    - [4.2 Драйверы логгирования](#42-Драйверы-логгирования)
    - [4.3 Настройки драйвера для контейнера](#43-Настройки-драйвера-для-контейнера)
    - [4.4 Чтение логов \(dual logging\)](#44-Чтение-логов-dual-logging)
    - [4.5 Настройка вывода идентификатора контейнера в логах](#45-Настройка-вывода-идентификатора-контейнера-в-логах)
- [5. Хранение данных](#5-Хранение-данных)
    - [5.1 Основы](#51-Основы)
    - [5.2 Флаги -v и --mount](#52-Флаги--v-и---mount)
    - [5.3 Работа с volume](#53-Работа-с-volume)
    - [5.4 Работа с bind mount](#54-Работа-с-bind-mount)
    - [5.5 Работа с tmpfs mount](#55-Работа-с-tmpfs-mount)
    - [5.6 Драйвера хранилищ, образы и слои](#56-Драйвера-хранилищ-образы-и-слои)

<!-- /MarkdownTOC -->

[coursera](https://www.coursera.org/learn/docker-osnovy)

[habr](https://habr.com/ru/post/310460/)

## 1. Основы

### 1.1 Установка и настройка

#### 1.1.1 Установка

[docs](https://docs.docker.com/engine/install/ubuntu/)

#### 1.1.2 Удаление

    sudo apt-get purge docker-ce docker-ce-cli containerd.io
    # дополнительно
    sudo rm -rf /var/lib/docker
    sudo rm -rf /var/lib/containerd

#### 1.1.3 Сервисы

[docs](https://docs.docker.com/engine/install/linux-postinstall/#configure-docker-to-start-on-boot)

Два сервиса: **docker.service** и **containerd**. По умолчанию - автозапуск. Можно управлять через systemctl:

    sudo systemctl disable docker.service
    sudo systemctl disable containerd.service

#### 1.1.4 Управление без прав root

[docs](https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user)

Демон Docker запускается от имени root, поэтому запуск контейнеров должен выполнятся от root:

    sudo docker run hello-world

Варианты обхода:

* создание группы `docker` (большие привилегии)
* Rootless mode

#### 1.1.5 Что слушает демон Docker

По умолчанию - через сокет Unix

Можно настроить удаленные команды через TCP, но нужна защита (TLS)


### 1.2 Образы (Images)

#### 1.2.1 Запуск образа

**Образ** - файл, представляющий операционную систему с компонентами и файлами. Используется для запуска контейнера. Только для чтения.

Запуск контейнера:

    docker run --name <имя для конейнера> <координаты образа> 

Координаты образа в двух вариантах (имя обязательно): 

    NAME[:TAG]
    NAME[@DIGEST]

Например:

    docker run --name test nginx:latest

#### 1.2.2 docker pull

Скачивает образ из репозитория 

    docker pull <координаты образа>

По умолчанию - из центрального хранилища Docker Hub

Команда `run` сама скачивает образ, если не находит локально

#### 1.2.3 docker images / docker image ls

Просмотр образов на локальной машине

    # только просмотр
    docker images
    # универсальная команда для работы с образами
    docker image ls|rm|pull

Опции:

* `-a` - все образы, в том числе скрытые
* `--digests` - выводить хеш-сумму образов
* `--filter`, `-f` - применить фильтр
* `--format` - форматировать вывод
* `--quiet`, `-q` - только id образов (для скриптов)

#### 1.2.4 docker tag

Назначает тег образу.

Обычная практика для docker переназначение тегов. Например при выходе новой версии, ей назначается тег `latest`.

Уникальным всегда остается `image id`

Если у образа нет тега - по умолчанию `latest`.

#### 1.2.5 docker inspect

Выводит инфо (JSON) по образу или контейнеру.

Например в `.[0].GraphDriver.Data.UpperDir` указана локальная директория, где хранятся файлы образа: `/var/lib/docker/overlay2/`

#### 1.2.6 docker image rm

Удаление образов с локальной машины

`--force`, `-f` - принудительное удаление


### 1.3 Запуск контейнеров

#### 1.3.1 docker run

Запуск изолированного контейнера, с собственной файловой и сетевой системами. Запуск на локальной машине или удаленном сервере (настройки docker CLI).

    docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]

По умолчанию - в режиме `foreground` (привязан к терминалу). Прервать - `Ctrl + C`

Запуск в фоновом (detached) режиме. Возвращает UUID контейнера. Присваивает случайное имя:

    docker run -d nginx

Запуск в интерактивном режиме (с запуском например bash):

    docker run -it ubuntu bash

Запуск с заданием имени контейнера

    docker run --name my_container ubuntu

Запуск с удалением контейнера после остановки

    docker run --rm --name my-cont nginx

#### 1.3.2 Просмотр состояния контейнеров

    docker ps -as

#### 1.3.3 docker start / docker stop

Запуск остановленного контейнера
    
    docker ps -a
    docker start nginx

Остановка контейнера:

    docker stop nginx

Посылает сигнал `SIGTERM`, если не остановлен после некоторого таймаута `SIGKILL`. 

Таймаут можно задать:
    
    --time , -t  по умолчанию 10 сек

Приложение в контейнере может не реагировать на `SIGTERM`. [подробнее](./dockerfile.md/#815-Правильно-выбирайте-команду-для-запуска-основного-процесса-внутри-контейнера)

#### 1.3.4 docker wait

ожидает завершения работы контейнера и выводит exit code

использовать для скриптов??

#### 1.3.5 docker pause

Останавлиет выполнение контейнера, посылая `SIGSTOP`

#### 1.3.6 Опция рестарт

Задает политику при остановке контейнера:

* `no` - по умолчанию не перезапускать контейнер
* `on-failure[:max-retries]` - перезапускать, если завершился с кодом отличным от 0
* `always` - всегда перезапускать, также при запуске демона (при перезапуске сервера)
* `unless-stopped` - аналогично `always`, но при `docker stop` останавливается

Пример:

    docker run -d --name=my_cont --restart=always

#### 1.3.7 docker inspect

Инфо (JSON) о запущенном контейнере:

    docker inspect my_container

#### 1.3.8 docker attach

Присоединение потоков ввода / вывода к запущенному контейнеру

    # запускаем в фоновом режиме
    docker run -d --name topdemo ubuntu

    # подключаемся
    docker attach topdemo

Выход из контейнера:

* `Ctrl + C` - останавливает контейнер
* `Ctrl + p, Ctrl + q` - отключается от контейнера, контейнер продолжает работать
* `exit CODE` - завершение контейнера с указанным кодом

#### 1.3.9 docker exec

Запуск нового процесса внутри запущенного контейнера

Опции:

* `--detach` , `-d` - запуск в фоновом режиме
* `--env` , `-e` - задать переменные окружения
* `--interactive` , `-i` - подключить STDIN
* `--tty` , `-t` - назначить TTY

Пример:

    docker exec -ti nginx bash


### 1.4 Проброс портов

#### 1.4.1 Настройка типа сети

По умолчанию изолирована от сети.

Типы сети при запуске контейнера:

* `none` - отсутствует
* `bridge` - подключение через интерфейс типа мост (NAT). Значение по умолчанию
* `host` - сеть хоста используется
* `container <имя:id>` - используется сеть указанного контейнера
* `network` - подключение к docker-сети, созданной ранее через `docker network create`

Пример:

    docker run --network="bridge" nginx

Посмотреть сетевые интерфейсы в контейнере: 

    apt update
    apt install iproute2 # для ip
    apt install iputils-ping # для ping
    ip address

#### 1.4.2 Проброс портов

Примеры:

    -p 8080:80                  80 порт контейнера в порт 8080 хоста
    -p 192.168.1.100:8080:80    то же, но при обращении на конкретный адрес хоста
    -p 8080:80/udp              по udp только

    docker run -p 8080:80 nginx


Посмотреть какие порты открыты:

* `docker ps`, колонка POSTS
* `docker inspect`

### 1.5 Тома

Типы томов (volumes):

* **bind mount** - просто директория или файл с хоста
* **volume** - именованный том, управляемый докером
* **tmpfs** - временные файлы, существующие только в памяти

Два типа синтаксиса:

* `-v`, `--volume`
* `--mount`

Примеры:

    # web1 на хосте отображается в in в контейнере
    docker run -d --name web1 -v /data/web1:/in nginx

    # аналогично для --mount
    docker run --mount type=bind,src=/data/web1,dst=/in nginx

### 1.6 Логи

Логи в docker'е - это сообщения, которые приложения внутри контейнера отправляют в STDOUT и STDERR. Docker их дополнительно агреггирует и выдает через `docker logs`

Работает с разными типами драйверов, например: **json-file** и **journald**

Примеры:
    
    # просмотр всех логов контейнера web:
    docker logs web
    # последние несколько записей: 
    docker logs --tail=5 web
    # выводить логи в реальном времени:
    docker logs -f web
    # последние за 5 мин
    docker logs --since=5m web
    # c выводом времени:
    docker logs -t web
    
Какой тип драйвера у контейнера - см. `docker inspect`. Можно менять.

По сути перехватывает сообщения и сохраняет их в файл`/var/lib/docker/<container id>/` или сервису.

### 1.7 Переменные окружения

    # передача переменной из хостовой машины
    docker run -e MYVAR1 nginx

    # установка переменной окружения
    docker run --env MYVAR2=foo nginx

    # установка переменных окружения из файла (ключ=значение)
    docker run --env-file ./env.list nginx


## 2. Удаленное подключение к docker

### 2.1 Внутреннее устройство

Составные части:

* runC - низкоуровневая среда выполнения контейнера. Быстрая, легкая, только запускает контейнеры.
* containerd-shim - вспомогательная среда
* containerd - высокоуровневая среда выполнения контейнеров: контроль, управление, создание сети и т. п.
* движок докера - создание контейнера из образа, передача его в containerd

### 2.2 Docker socket

Демон `dockerd` имеет интерфейс (socket), который обслуживает REST-запросы.

3 типа сокетов:

* **unix**: например `/var/run/docker.sock`
* **tcp**
* **fd** - сокет, которым управляет systemd. Настройки сокета описываются в файле `docker.socket` (по умолчанию там `/var/run/docker.sock`)

По умолчанию слушает `/var/run/docker.sock`. Запускается через `dockerd -H fd://`

При запуске через `-H` можно настроить прослушку других сокетов, tcp портов

    !! Открытие tcp порта демона без защиты = root доступ к хосту 

Просмотр версии клиента и сервера (демона):

    docker version

Через API демона можно создавать, запускать контейнеры, реагировать на события. 

Можно смонтировать `docker.sock` в контейнер. В контейнере тогда можно управлять демоном на хосте (опасно).

### 2.3 Настройка демона Docker

Настройка демона dockerd:

* через JSON файл конфигурации
* через флаги запуска dockerd

Можно оба способа. При совпадении параметров - ошибка запуска.

Создать файл настроек `/etc/docker/daemon.json`.

Пример файла:

    {
        "debug": true,
        "tls": true,
        "tlscert": "/var/docker/server.pem",
        "tlskey": "/var/docker/serverkey.pem",
        "hosts": ["tcp://192.168.59.3:2376"]
    }

При изменении конфигурации может перезагрузка:

    sudo kill -SIGHUP $(pidof dockerd)

Если что - см. логи. Ubuntu - `/var/log/syslog`

Перенос каталога `/var/lib/docker` (тома, образы и т. п.): параметр в конфигурации `data-root` или сделать симлинк.

### 2.4 Настройка удаленного подключения к демону

Нужно включить tcp сокет (по умолчанию будет незашифрованный и неаутентифицированный).

Незашифрованный демон обычна на порту **2375**, зашифрованный - **2376**

Включение через запуск демона с флагом `-H`:

    # все сетевые интерфейсы
    -H tcp://0.0.0.0:2375
    # или конкретный сетевой интерфейс
    -H tcp://192.168.57.241:2375

**Первый способ настройки**: через systemd
    
    # редактируем конфигурационный файл
    systemctl edit docker
    # например usr/bin/dockerd -H tcp://0.0.0.0:2375
    # перезапускаем демон systemd
    systemctl daemon-reload
    # перезапускаем docker
    systemctl restart docker

Проверить: 

    # смотрим ключи запуска докера
    ps aux | grep docker
    # проверяем порт
    netstat -nl| grep 2375

**Второй способ настройки**: через конфигурационный файл

Cоздаем / редактируем `/etc/docker/daemon.json`

Добавляем записи в файл

    {
        "hosts": ["unix:///var/run/docker.sock",
        "tcp://127.0.0.1:2375"]
    }

Ключей запуска не будет видно, но можно порты проверить

### 2.5 Работа с разными подключениями на клиенте (context)

Со стороны клиента просмотр доступных подключений:
    
    docker context ls

`*` обозначен текущий используемый.

Добавить новое подключение

    doсker context create my-server --docker "host=tcp://83.43.1.123:2375"

Переключиться на использование:

    docker context use my-server

### 2.6 Другие варианты подключений

(без подробностей пока)

Использовать готовые контейнеры с настроенными подключениями

Пробросить сокет через ssh

### 2.7 Защищенное удаленное подключение к докеру

Все предыдущие примеры дают свободный доступ к демону любому, кто сможет подключиться к порту

Защищенное соединение использует сертификаты.

[Подробнее](https://docs.docker.com/engine/security/protect-access/)

## 3. Сети в Docker

### 3.1 Обзор

В основе - Container Network Model. Docker предоставляет набор драйверов, но система расширяемая. Внутри работает через `iptables` или подобные

Стандартные драйвера / типы сетей докера:

* **bridge** - драйвер по умолчанию. Служит для объединения нескольких контейнеров в сеть, но эта сеть изолирована от сети хоста.
*  **host** - контейнеры соединены с сетью хоста. Производительней чем **bridge**: не нужно обрабатывать NAT-трафик
*  **overlay** - соединяет несколько демонов докера в одну сеть
*  **macvlan** - позволяет назначать MAC адреса контейнерам, считая их физическими устройствами.
*  **none** - польностью изолирует контейнер от сети. Можно подключать сторонние сетевые драйверы

### 3.2 Сеть типа bridge

Докер создает программный мост с именем `docker0`:

    ip addr 

Сетевой обмен между контейнерами, подключенными к одному мосту, разрешен. Контейнеры, подключенные к разным мостам - изолированы

По умолчанию при запуске контейнер присоединяется к сети типа bridge с именем `bridge`. Можно создать пользовательскую сеть и при запуске контейнера указать ее, или поключить работающий контейнер к сети.

Предпочтительнее - создавать сеть явно, не использовать сеть по умолчанию

Различия между пользовательской сетью и сетью по умолчанию:

* пользовательская сеть обеспечивает DNS разрешение имен контейнеров
    - доступ можно по именам контейнеров получать
    - в сети по умолчанию - только по ip или доп. настройки (`/etc/hosts` например)
* пользовательская сеть - более изолирована: контейнер без явного указания подключается к сети по умолчанию - неявно можно неожиданное поведение
* к пользовательской сети можно подключать / отключать контейнеры на лету
* пользовательская сеть - больше возможностей настроек. У сети по умолчанию нужно переопределять файл настроек и перезапускать демон
* контейнеры в сети по умолчанию разделяют переменные окружения

Контейнеры в одной сети видят порты друг друга. Для контейнеров другой сети или не Docker-хостов - явно нужно публиковать порты `-p` или `--publish`


### 3.3 Сеть типа host

Контейнер разделяет одно сетевое пространство имен с хостом:

* контейнер и хост-система имеют один ip-адрес
* возрастает производительность:
    - не надо выполнять NAT и проксировать порты

Контейнер или докер не могут изменять настройки сети.

Работает только на Linux-системах

Не получится запустить несколько контейнеров, используюших одинаковые порты (например nginx)

### 3.4 Команды работы с сетями в Docker

Основная - `docker network`

Просмотр списка сетей:

    docker network ls
    # по умолчанию есть bridge, host и none

Анализ сети (настройки сети, присоединенные контейнеры):

    docker network inspect <имя сети>

Создание сети: 

    docker network create <имя сети>
    docker network create --driver bridge <имя сети>


Разные параметры: тип (bridge по умолчанию), ip адреса и др.

Удаление сети:

    docker network rm <имя сети>

Подключение запущенного контейнера к сети:

    docker network connect <имя сети> <имя контейнера>

Отключение от сети:

    docker network disconnect <имя сети> <имя контейнера>

### 3.5 Пример запуска контейнера и настройка сети

[docs](https://docs.docker.com/network/network-tutorial-standalone/)

#### 3.5.1 Сеть по умолчанию

    # запуск образа apline с терминалом ash, подключена к сети по умолчанию
    docker run -dit --name alpine1 alpine ash
    docker run -dit --name alpine2 alpine ash

    # просмотр сети     
    docker network inspect bridge

    # работа из первого контейнера:
    docker attach alpine1
    ip addr show
    ping -c 2 google.com
    # ко второму может подключиться только зная ip адрес
    ping -c 2 172.17.0.3
    # по имени нельзя
    ping -c 2 alpine2
        bad address

    docker container stop alpine1 alpine2
    docker container rm alpine1 alpine2

#### 3.5.2 Пользовательская сеть

    # создаем сеть
    docker network create --driver bridge alpine-net

    # запускаем контейнеры с подключением к созданной сети
    docker run -dit --name alpine1 --network alpine-net alpine ash
    docker run -dit --name alpine2 --network alpine-net alpine ash

    # можем увидеть подключения к сети
    docker network inspect alpine-net

    # можно по имени контейнера подключаться внутри сети
    docker container attach alpine1
    ping -c 2 alpine2

    docker container stop alpine1 alpine2
    docker container rm alpine1 alpine2
    docker network rm alpine-net

### 3.6 Настройка сети

[docs](https://docs.docker.com/config/containers/container-networking/)

#### 3.6.1 Проброс портов внутрь контейнера

Из контейнера можно обращаться во внешний мир, но по умолчанию из внешнего мира к контейнеру нельзя обратиться.

Есть **открытие (exposing) порта** - просто документация факта использования порта (например для систем оркестрации) и **публикация (publishing) порта** - доступность порта извне.

Если запустить контейнер без ключа `p`, будет только открытие портов:

    docker run -d nginx
    docker container ls
        ID   IMAGE   STATUS         PORTS     
        45.. nginx   Up 2 seconds   80/tcp 

Если явно указать - произойдет публикация:
    
    docker run -d -p 8080:80 nginx
    docker container ls
        ID   IMAGE   STATUS         PORTS     
        45.. nginx   Up 2 seconds   0.0.0.0:8080->80/tcp, :::8080->80/tcp  

Порты могут автоматически назначаться из диапазона свободных портов, если запускаем с `-P` или `--publish-all=true`. Посмотреть настройку диапазона свободных портов:

    sysctl -a | grep port_range
        net.ipv4.ip_local_port_range = 32768    60999

Просмотр проброшенных портов:

    docker ports <контейнер>

По умолчанию порты пробрасываются с любого ip-адреса (0.0.0.0:8080->80). Можно ограничивать, например только локальные обращения:

    docker run ... -p 127.0.0.1:8080:80

Docker при запуске контейнеров создает правила в iptables. Можно добиться того же эффекта, просто создав нужные правила в iptables без Docker

#### 3.6.2 IP адреса

Каждая сеть имеет адрес шлюза и маску подсети.

При подключении контейнера к сети, ему выдается адрес из пула адресов. 

Можно явно задать адрес (только для пользовательских сетей и при явной конфигурации подсети):

    # подключая работающий контейнер
    docker network connect <сеть> <контейнер> --ip ...
    # или при запуске
    docker run --network .. --ip ...

Имя хоста (`hostname`) для контейнера по умолчанию - контейнера.

Можно переопределять:

    docker run ... --hostname ...
    docker network connect --alias ...

### 3.7 Пример объединения контейнеров в несколько сетей

Задача: построить архитектуру: веб-приложение, база данных и связующий сервер приложений.

Можно все включить в один контейнер - но это нарушает философию Docker **один процесс - один контейнер**.

Минусы одного контейнера:

* сложность остановки / запуска
* обновление отдельного приложения - сборка всего контейнера

Решение: создать три контейнера и объединить их в 2 сети: front (веб-приложение и сервер приложений) и back (база данных и сервер приложений)

    docker network create front
    docker network create back

Создаем контейнеры и подключаем к сетям. Одновременно к двум при запуске нельзя подключить. Поэтому подключаем после запуска:

    docker run -dit --name web --net front alpine ash
    docker run -dit --name db --net back alpine ash
    docker run -dit --name app --net front alpine ash
    docker network connect back app

Контейнер, подключенный к нескольким сетям, будет иметь несколько сетевых интерфейсом. Проверить можно внутри контейнера:

    ipconfig
    ip addr

Если нужно несколько сетей прямо при запуске иметь, можно сначала создать контейнер, подключить сети, потом запустить:

    docker create ...
    docker network connect..
    docker container start ...

## 4. Логгирование

[docs](https://docs.docker.com/config/containers/logging/)

### 4.1 Основы

Это про логи приложений из контейнера. Логи самого демона докера - см. `/var/log/syslog`

Каждый процесс в Linux открывает 3 потока STDIN, STDOUT и STDERR.

Команды `docker logs` или `docker service logs` выводят содержимое потоков STDOUT и  STDERR, как если бы приложения контейнера запускались в терминале.

Команда `docker logs` может не показывать информации если:

* логирующий драйвер отправляет сообщения в файл, внешний сервис и игнорирует потоки вывода
* запущенное в контейнере приложение не выводит сообщения в потоки вывода, использует файлы, внешние сервисы и т. п.

Во втором случае можно перенаправлять сообщения в стандартные потоки.

[Пример из образа nginx](https://github.com/nginxinc/docker-nginx/blob/8921999083def7ba43a06fabd5f80e4406651353/mainline/jessie/Dockerfile#L21-L23)

[Пример из образа httpd](https://github.com/docker-library/httpd/blob/b13054c7de5c74bbaa6d595dbe38969e6d4f860c/2.2/Dockerfile#L72-L75)

### 4.2 Драйверы логгирования

Демон имеет драйвер по умолчанию, но контейнеру можно указать использовать другой драйвер.

Драйвер по умолчанию - `json-file`. Ротация по умолчанию отключена, возможно переполнение (можно настроить). Можно использовать драйвер `local` - по умолчанию включена ротация файлов. 

Настройка драйвера по умолчанию - файл `/etc/docker/daemon.json` ([docs](https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file)). `log-driver` задает тип драйвера, в `log-opts` - параметры устанавливаются:

    {
      "log-driver": "json-file",
      "log-opts": {
        "max-size": "10m",
        "max-file": "3"
      }
    }

После изменения файла - рестарт демона и новые контейнеры создавать:

    systemctl restart docker

Просмотр текущих настроек: 

    # возможно выводится только при переопределении конфигурации
    docker info

Если драйвера пишут логи в файлы, файлы хранятся в `/var/lib/docker/<container id>/`

### 4.3 Настройки драйвера для контейнера

#### 4.3.1 Установка драйвера при запуске

Параметры `--log-driver` и `--log-opt` при создании/запуске контейнера:

    docker run --log-driver none alpine

Просмотр настроек контейнера:

    docker inspect <контейнер>


#### 4.3.2 Режим доставки сообщений от контейнера драйверу

Два варианта:

* **блокирующий**
    - приостанавливается выполнение, пока сообщение не достигнет цели (файл, сетевой сервис)
* **не блокирующий**
    - сообщение записывается в буфер конечного размера, отдельный процесс доставляет сообщения
    - возможна потеря сообщений при переполнении буфера

Настройка:

    docker run -it --log-opt mode=non-blocking --log-opt max-buffer-size=4m alpine ping 127.0.0.1

#### 4.3.3 Переменные окружения и метки в логах

Некоторые драйверы могут выводить переменные `--env|-e` или метки `--label` в логи. Например так может `json-file` драйвер:

    docker run -dit --label production_status=testing -e os=ubuntu alpine sh
    # в логах будет содержаться:
        "attrs":{"production_status":"testing","os":"ubuntu"}


### 4.4 Чтение логов (dual logging)

До v 20.10 команда `docker logs` могла читать логи только драйверов `local`, `json-file`, `journald`.

С версии 20.10 можно читать логи любых драйверов за счет **dual logging**: дополнительно к заданному драйверу (???) используется драйвер `local` ( по умолчанию ротация, 5 файлов, 20 МБ) как кеш.

**dual logging** автоматически включается, если драйвер не обеспечивает возможность чтения логов (это все драйвера кроме `local`, `json-file`, `journald`)

Настройка **dual logging** - опции `--log-opt`:

* `cache-disabled` - установить в `true` для отключения. Для драйверов с поддержкой чтения не влияет ни на что.
* `cache-max-size` - 20m по умолчанию
* `cache-max-file` - 5 по умолчанию
* `cache-compress` - `true`

### 4.5 Настройка вывода идентификатора контейнера в логах

[docs](https://docs.docker.com/config/containers/logging/log_tags)

По умолчанию идентификатор - 12 символов идентификатора контейнера.

Можно переопределить через `--log-opt tag`. Например

    docker run --log-opt tag="{{.ImageName}}/{{.Name}}/{{.ID}}"

Перечень идентификаторов - в документации


## 5. Хранение данных

[docs](https://docs.docker.com/storage/)

### 5.1 Основы

#### 5.1.1 Обзор

По умолчанию все файлы создаются внутри контейнера в особом слое:

* данные не сохраняются, когда контейнер не существует
* слой контейнера, куда сохраняются данные, тесно связан с хостом; нельзя просто переместить данные куда-либо
* запись в слой выполняется через специальный драйвер-абстракцию. Другой вариант - запись напрямую в файловую систему хоста

Варианты хранилищ для контейнеров:

* **volumes**
* **bind mounts**
* **tmpfs mount** (linux только)
* **named pipe** (win только)

С точки зрения процессов внутри контейнера, все варианты равнозначны.

#### 5.1.2 Типы хранилищ

##### 5.1.2.1 Тип хранилищ volume (том)

Часть ФС хоста, управляются (создаются / удаляются) docker'ом.

Обычно расположена в `/var/lib/docker/volumes`. Не-docker процессы не должны напрямую взаимодействовать.

Создаются командой `docker volume create` или в процессе создания контейнера. Конкретный экземпляр **volume** может монтироваться в несколько контейнеров. 

После удаления контейнеров не удаляется автоматически. Можно удалить командой `docker volume prune`

Можно назначить имя. Если не заданы - считается анонимным, docker назначает уникальное.

##### 5.1.2.2 Тип хранилища bind mounts (привязка)

Просто часть ФС (файл или директория) хоста, доступная контейнеру.

Указывается по полному пути. Может не существовать, будет создан по требованию. 

Эффективны, но Docker CLI слабо может работать с такими.

Можно дать доступ к любым файлам, в т. ч. системным и управлять из контейнера работой хоста. Опасно. 

##### 5.1.2.3 Тип хранилища tmpfs mounts

Данные не сохраняются на диск, только в памяти.

Может использоваться для хранения например секретов (паролей, ключей и т. п.)



#### 5.1.3 Use case

**volume** - предпочтительный способ организации хранилищ. Когда использовать:

* данные нужно расшарить между несколькими контейнерами. **volume** остается после удаления контейнера. К нему можно подключать новые контейнеры
* не гарантируется, что хост содержит указанную директорию/файлы. Тома - прослойка между хостом и контейнером
* нужно сохранять данные на удаленном хосте или в облаке
* когда нужно делать резервные копии, перемещать хранилища
* тома внутри докера имеет большую производительность в Docker Desktop (Mac и Win)

**Bind mounts** - менее предпочтительный способ:

* когда нужно передать конфигурационные файлы с хоста в контейнер. Так например для DNS по умолчанию передается `/etc/resolv.conf
* передача исходников или скомпилированных файлов между хостом, на котором ведется разработка, и контейнером, где выполняется запуск. Например - расшаривание папки `target` от Maven

**tmpfs**:

* когда не нужно сохранять данные ни в контейнере, ни на хосте
* нужна высокая происводительность без необходимости хранения

### 5.2 Флаги -v и --mount

Два варианта синтаксиса. Предпочтительнее `--mount` (более полный)

Флаг `-v` или `--volume`:

* значение содержит 3 поля разделенных `:`
    - имя тома (для именованных томов), опускается для анонимных томов
    - путь внутри контейнера
    - перечень опций
    
Флаг `--mount` - набор пар ключ-значение, разделенных `,` (порядок не важен):

* `type` - тип хранилища (`bind`, `volume`, `tmpfs`)
* `source`, `src` - источник. Для именованных томов - имя, для анонимных не используется
* `destination`, `dst`, `target` - путь внутри контейнера
* `readonly`, `ro` - только для чтения
* `volume-opt` - пары ключ-значения

Если несколько опций, разделенных зпт - нужно экранировать. Значения `--mount` в одинарные, знвчения `volume-opt` - в двойные:

    $ docker service create /
        --mount 'type=volume, src=<VOLUME-NAME>,dst=<CONTAINER-PATH>,
                    volume-opt=type=nfs,
                    "volume-opt=o=addr=<nfs-address>,vers=4,tcp,rw"'
        --name myservice


### 5.3 Работа с volume

**Создание/удаление/просмотр**:

    docker volume create my-vol
    docker volume ls
    docker volume inspect my-vol
    docker volume rm my-vol

**Запуск контейнера с томом**:

    docker run -d --name dev --mount source=my-vol,target=/app nginx

Результат можно видеть через `docker inspect dev` в секции `Mounts` 

**Передача данных из одного контейнера в другой**:

    # создаем том
    docker volume create my-volume
    # запускаем контейнер с томом, монтируем в сущестующую папку в контейнере
    docker run -d --name=ng 
        --mount source=nginx-vol,destination=/usr/share/nginx/html nginx:latest
    # второй контейнер с тем же томом
    docker run -d --mount source=nginx-vol,dst=/app nginx
    # в /app второй контейнер видит файлы первого

**Запуск в режиме только для чтения**

Через опцию `readonly`:

    docker run -d --name=ng 
        --mount src=nginx-vol,dst=/usr/share/nginx/html,readonly nginx
   
Через `docker inspect ng` в блоке `Mounts` можно увидеть `"RW": false`

**Удаление томов**

Общая команда удаления всех томов, не подключенных к контейнерам:

    docker volume prune

С флагом `--rm` будут удаляться анонимные тома, создаваемые при старте контейнера:

    docker run --rm -v /foo -v my-vol:/bar busybox top
 
Здесь том `/foo` будет удален после остановки контейнера, том `my-vol:/bar` - нет (не анонимный)

**Передача данных из хоста в контейнер**

Создаем том
    
    docker volume create my-volume

Содержимое тома - директория `/var/lib/docker/volumes/my-volume/_data`. Можно использовать стандартные команды для передачи файлов.

**Запуск контейнера с томами от другого контейнера**

Через флаг `--volume-from`:

    docker run  --volume-from some-container alpine

**Что если примонтировать том в непустую директорию контейнера**

Файлы из тома будут видны в контейнере + файлы контейнера останутся. Если по имени совпадают - файлы тома будут видны, а файлы контейнера - нет.

В том (`/var/lib/docker/volumes/...`) будут скопированы файлы контейнера.

Для привязок - другая стратегия: хост всегда в приоритете, из контейнера ничего не копируется, директории хоста полностью перекрывают директории контейнера.

### 5.4 Работа с bind mount

Директория или файл хоста монтируется в контейнер. По абсолютному пути. Может не существовать, будет создан по требованию.

**Запуск контейнера с привязкой** (`/target` из текущей директории монтируется в `/app` в контейнере):

    docker run -d -it --name devtest \
        --mount type=bind,source="$(pwd)"/target,target=/app nginx

**Что если смонтировать директорию в непустую директорию контейнера**

Содержимое директории контейнера будет полностью перекрыто. Никакие файлы контейнера видны не будут.

### 5.5 Работа с tmpfs mount

Временные хранилища в памяти. Только для Linux.

**Запуск контейнера с временным хранилищем**

    docker run --mount type=tmpfs,destination=/app nginx

Реквизит `source` не указывается.

**Запуск с ограничением памяти**
    
Задается в байтах, без указания - не ограничено

    docker run --mount type=tmpfs,destination=/app,tmpfs-size=1000000 nginx






### 5.6 Драйвера хранилищ, образы и слои

#### 5.6.1 Основы

Драйвер хранилища (storage driver, ДХ) обеспечивает:

* взаимодействие между слоями образа 
* запись данных в верхний (записываемый) слой контейнера

Образы состоят из набора слоев. Слои - только для чтения. Каждый слой настраивается над предыдущим и включает только отличия от предыдущего. При запуске контейнера создается **верхний записываемый слой**, уникальный для каждого контейнера. Слои только для чтения могут расшариваться между несколькими образами и контейнерами.

#### 5.6.2 Просмотр размера контейнеров

    docker ps -s

Колонка `size` - объем верхнего записываемого слоя контейнера.

Колонка `virtual size` - объем нижних только для чтения слоев + объем верхнего слоя. По сути - объем всего контейнера. Сложить объемы всех контейнеров нельзя - могут быть общие слои.

В показываемые объемы не входят:

* логи
* тома и привязки
* размер файлов подкачки и т. п.

#### 5.6.3 Стратегия Copy-on-Write

Стратегия Copy-on-Write (CoW): если слою нужно прочитать файл из нижележащего слоя - он просто читает этот файл. Если нужно изменить файл - файл копируется в этот (в верхний записываемый) слой и изменяется в нем.

Слои хранятся в `/var/lib/docker/<имя ДХ>`

Посмотреть слои:

    docker image history <имя образа>
    docker image inspect <имя образа>

Слои обычно создаются при создании образа (команды Docker-файла).

Пример алгоритма при изменении файла (на примере ДХ `overlay2`):

* ищет файл, начиная с верхних слоев вниз. Найденные кеширует
* найденный файл копирует в верхний записываемый слой и модифицирует
* контейнер больше не может видеть копии файла из нижних слоев






#### 5.6.4 Выбор драйвера

Посмотреть текущий драйвер:

    docker info

Есть разные варианты, зависят от ФС хоста. По умолчанию - `overlay2`, заморачиваться не стоит.
