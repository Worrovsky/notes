## Содержание

<!-- MarkdownTOC autolink="true" uri_encoding="false" levels="2,3" -->

- [0. Кратко](#0-Кратко)
    - [0.1 Ссылки](#01-Ссылки)
    - [0.2 Создание образа](#02-Создание-образа)
    - [0.3 Команды Dockerfile](#03-Команды-dockerfile)
    - [0.4 Использование `"`, `/`](#04-Использование--)
    - [0.5 CMD vs ENTRYPOINT](#05-cmd-vs-entrypoint)
    - [0.6 ADD vs COPY](#06-add-vs-copy)
- [1. Основы](#1-Основы)
- [2. Использование \(docker build\)](#2-Использование-docker-build)
- [3. Формат файла](#3-Формат-файла)
- [4. Директивы](#4-Директивы)
- [5. Переменные окружения](#5-Переменные-окружения)
- [6. Файл .dockerignore](#6-Файл-dockerignore)
- [7. Команды](#7-Команды)
    - [7.1 FROM](#71-from)
    - [7.2 RUN](#72-run)
    - [7.3 CMD](#73-cmd)
    - [7.4 LABEL](#74-label)
    - [7.5 EXPOSE](#75-expose)
    - [7.6 ENV](#76-env)
    - [7.7 ADD](#77-add)
    - [7.8 COPY](#78-copy)
    - [7.9 ENTRYPOINT](#79-entrypoint)
    - [7.10 VOLUME](#710-volume)
    - [7.11 USER](#711-user)
    - [7.12 WORKDIR](#712-workdir)
    - [7.13 ARG](#713-arg)
    - [7.14 ONBUILD](#714-onbuild)
    - [7.15 STOPSIGNAL](#715-stopsignal)
    - [7.16 HEALTHCHECK](#716-healthcheck)
    - [7.17 SHELL](#717-shell)
- [8. Best practices: общие рекомендации](#8-best-practices-общие-рекомендации)
    - [8.1 Создавайте эфемерные контейнеры](#81-Создавайте-эфемерные-контейнеры)
    - [8.2 Понимайте контекст \(build context\)](#82-Понимайте-контекст-build-context)
    - [8.3 Dockerfile через конвейер \(pipe\) stdin](#83-dockerfile-через-конвейер-pipe-stdin)
    - [8.4 Исключайте лишние файлы через .dockerignore](#84-Исключайте-лишние-файлы-через-dockerignore)
    - [8.5 Используйте multi-stage build](#85-Используйте-multi-stage-build)
    - [8.6 Не используйте ненужные зависимости](#86-Не-используйте-ненужные-зависимости)
    - [8.7 Декомпозируйте контейнеры/приложения](#87-Декомпозируйте-контейнерыприложения)
    - [8.8 Минимизируйте количество слоев](#88-Минимизируйте-количество-слоев)
    - [8.9 Сортируйте агрументы по алфавиту](#89-Сортируйте-агрументы-по-алфавиту)
    - [8.10 Следите за порядком команд \(кеширование\)](#810-Следите-за-порядком-команд-кеширование)
    - [8.11 Используйте непривилегированных пользователей](#811-Используйте-непривилегированных-пользователей)
    - [8.12 Версионирование образов](#812-Версионирование-образов)
    - [8.13 Не храните секреты в образах](#813-Не-храните-секреты-в-образах)
    - [8.14 Используйте статический анализ Dockerfile и сканеры уязвимости](#814-Используйте-статический-анализ-dockerfile-и-сканеры-уязвимости)
    - [8.15 Правильно выбирайте команду для запуска основного процесса внутри контейнера](#815-Правильно-выбирайте-команду-для-запуска-основного-процесса-внутри-контейнера)
    - [8.16 Уменьшайте размер образов \(сводные рекомнедации\)](#816-Уменьшайте-размер-образов-сводные-рекомнедации)
- [9. Best practices: команды](#9-best-practices-команды)
    - [9.1 FROM](#91-from)
    - [9.2 LABEL](#92-label)
    - [9.3 RUN](#93-run)
    - [9.4 CMD](#94-cmd)
    - [9.5 ENV](#95-env)
    - [9.6 COPY или ADD](#96-copy-или-add)
    - [9.7 ENRTYPOINT](#97-enrtypoint)
    - [9.8 USER](#98-user)
    - [9.9 WORKDIR](#99-workdir)

<!-- /MarkdownTOC -->

## 0. Кратко

### 0.1 Ссылки

[1. docs best practices](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)

[2. reference](https://docs.docker.com/engine/reference/builder/)

[3. примеры файлов](https://github.com/docker/awesome-compose)

[4. blog CMD vs ENTRYPOINT](https://www.ctl.io/developers/blog/post/dockerfile-entrypoint-vs-cmd/)

[5. habr best practices python](https://habr.com/ru/company/wunderfund/blog/586778/)

[6. best practices nodejs](https://snyk.io/blog/10-best-practices-to-containerize-nodejs-web-applications-with-docker/)

[7. docker for java](https://snyk.io/blog/docker-for-java-developers/)

[8. курс по docker](https://devopswithdocker.com)

[9. best practices java](https://snyk.io/blog/best-practices-to-build-java-containers-with-docker/)

### 0.2 Создание образа

    mkdir test-build
    cd test-build
    touch Dockerfile

 Содержимое:
    
    FROM alpine

    docker build -t myrepo/myapp:latest .

### 0.3 Команды Dockerfile

Список команд:

* `FROM` - задает исходный образ
* `RUN` - выполняет команду, создает слой образа
* `CMD` - задает команду, выполняемую при старте контейнера (параметры переопределить можно в `docker run`), или  задает параметры для `ENTRYPOINT`
* `LABEL` - задает метаданные образа
* `EXPOSE` - обозначает факт использования порта (не публикация порта)
* `ENV` - задает переменные окружения для контейнера и Dockerfile
* `ADD` - добавляет файлы в котнейнер (лучше `COPY` использовать)
* `COPY` - добавляет файлы в контейнер
* `ENTRYPOINT` - задает команду, выполняемую при старте контейнера без возможности переопределения параметров
* `VOLUME` - создает том для контейнера
* `USER` - определяет пользователя / группу
* `WORKDIR` - задает рабочую директорию для команд Dockerfile
* `ARG` - параметры для передачи в `docker build`
* `ONBUILD` - команды для образов на основе текущего образа
* `STOPSIGNAL` - сигнал для остановки контейнера 
* `HEALTHCHECK` - подключает проверку статуса запущенного контейнера 
* `SHELL` - устанавливает оболочку для команд Dockerfile 

### 0.4 Использование `"`, `/`

Работа с пробелами: обернуть в `"`.

`/` - в конце строки означает перенос на новую строку.

Комадны могут иметь 2 формы: `execform` и `shellform`:

    CMD ["exec", "param1", "param2"]
    CMD exec, ,param1, param2

В execform кавычки `"` обязательны, в shellform - можно для сокрытия пробелов.

### 0.5 CMD vs ENTRYPOINT

[blog CMD vs ENTRYPOINT](https://www.ctl.io/developers/blog/post/dockerfile-entrypoint-vs-cmd/)

#### 0.5.0 Кратко правила анализа

1. Docker всегда использует последние вхождения `CMD` и `ENTRYPOINT`
2. shell-форма запускается через оболочку `/bin/sh -c` (если не переопределена через `SHELL`), exec-форма - напрямую
3. `CMD` переопределяется параметрами при запуске контейнера
4. Итоговая команда - результат простой конкатенации `ENTRYPOINT` и `CMD` (не последовательное выполнение!)

Примеры:

    ENTRYPOINT /bin/ping -c 3
    CMD localhost
        -> /bin/sh -c ‘/bin/ping -c 3’ /bin/sh -c localhost

    ENTRYPOINT [“/bin/ping”,”-c”,”3”]
    CMD localhost
        -> /bin/ping -c 3 /bin/sh -c localhost

    ENTRYPOINT [“/bin/ping”,”-c”,”3”]
    CMD [“localhost”]
        -> /bin/ping -c 3 localhost


#### 0.5.1 Использование CMD или ENTRYPOINT

Обе задают команды, которые будут исполнены при запуске контейнера без аргументов:

    docker run alpine 
        не запустится, в dockerfile образа не заданы CMD или ENTRYPOINT

Нужно явно указывать исполняемую команду

    docker run alpine sh

Если задана **CMD**, можно переопределять параметры при запуске. Удобно использовать, если контейнер будет запускаться с разными параметрами:

    # создаем образ demo
    FROM ubuntu:trusty
    CMD ping localhost
    # запускаем без параметров, выполняется ping localhost
    docker run -t demo
    # можно переопределять
    docker run demo google.com

**ENTRYPOINT** - жестко задает команду, которую нельзя сменить при запуске контейнера. Например для запуска скрипта через контейнер.

#### 0.5.2 Shellform vs execform

Предпочтительнее использовать `execform`, т. к. исполняемый процесс запускается с PID = 1, а не оболочка.

#### 0.5.3 Совместное использование CMD и ENTRYPOINT

**ENTRYPOINT** задает исполняемую команду для контейнера, **CMD** задает параметры по умолчанию и позволяет их менять во время запуска.

    FROM ubuntu:trusty
    ENTRYPOINT ["/bin/ping","-c","3"]
    CMD ["localhost"]

Итоговая команда при запуске - соединение ENTRYPOINT и CMD. Так как CMD может перезаписываться параметрами из `docker run`, получаем возможность настраивать выполнение контейнера.

Обязательно использование execform обоих команд.


### 0.6 ADD vs COPY

[blog](https://www.ctl.io/developers/blog/post/dockerfile-add-vs-copy/)

Кратко: использовать **COPY**.

Команда **ADD** слишком много берет на себя (разархивирование: иногда да, иногда нет).

## 1. Основы

`Dockerfile` - текстовый файл, содержащий команды, нужные для создания образа. 

Команда `docker build` использует `dockerfile` и создает образ.

## 2. Использование (docker build)

[docs](https://docs.docker.com/engine/reference/commandline/build/)

Команда `docker build` строит образ на основе `Dockerfile` и *контекста*.

Контекст задается путем или url (git-репозиторий). Это набор файлов, нужных для создания образа (например в команде `COPY`). Dockerfile обычно располагают в корне контекста.

    docker build .
    docker build https://github.com/docker/rootfs.git#container:docker

Можно задать явно расположение докер-файла:

     docker build -f /path/to/a/Dockerfile .

Сначала содержимое контекста рекурсивно копируется в демон докера. Для ограничения - файл `.dockerignore`.

Назначить тег и репозиторий для образа (несколько можно):

    docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .

Демон докера последовательно выполняет команды из докер-файла. Каждая команда выполняется независимо от предыдущих (например нельзя `RUN cd /tmp`). Результаты могут кешироваться. Результаты команд помещаются в слои образа.


## 3. Формат файла

    # Comment
    INSTRUCTION arguments

Регистронезависим, но по соглашению команды - заглавными.

Должен начинаться с команды `FROM` - исходного образа. Перед командой `FROM`  могут быть директивы, комментарии или глобальные аргументы `ARGS`.

Пример комментарий, перенос строк:

    # This is comment
    RUN echo "\
            Hello\
            , world"


## 4. Директивы

Формат 

    # directive=value

Только в начале файла и в единственном экземпляре. Как только докер обработает любую строку или директиву, больше их рассматривать не будет (считать будет комментарием)

Варианты директив:

* `syntax` - при использовании **BuildKit** (отдельный бекэнд для выполнения `build`) (docs)[https://docs.docker.com/engine/reference/builder/#buildkit]
* `escape` - устанавливает экранирующий символ.

Экранирующий символ:

* перевод на новую строку
* экранирование других символов

По умолчанию - `/`. Другой вариант - `' (backtick)`. Для Windows можно использовать, где `/` - часть пути.

    # escape=`
    FROM microsoft/nanoserver
    COPY testfile.txt c:\
    RUN dir c:\


## 5. Переменные окружения

Объявляются командой `ENV`.

Могут использоваться через `$variable_name` или `${variable_name}`

Дополнительный синтаксис:

* `${varible:-word}` - если `variable` не установлена, результат выражения - `word`
* `${varible:+word}` - если `variable` установлена, результат выражения - `word`, иначе - пустая строка

Экранирование через `\`:

    COPY \$foo /tmp        # COPY $foo /tmp 

Замена переменных: внутри инструкции переменные не устанавливаются:

    ENV abc=hello
    ENV abc=bye def=$abc    # здесь def = hello
    ENV ghi=$abc            # здесь ghi = bye

## 6. Файл .dockerignore

[docs](https://docs.docker.com/engine/reference/builder/#dockerignore-file)

## 7. Команды

### 7.1 FROM

    FROM [--platform=<platform>] <image> [AS <name>]
    FROM [--platform=<platform>] <image>[:<tag>] [AS <name>]
    FROM [--platform=<platform>] <image>[@<digest>] [AS <name>]

Начинает этап построения образа, определяет базовый образ:

* с этой команды должен начинаться валидный `Dockerfile`
* `ARG` - может находиться перед `FROM`
* `FROM` может несколько раз - создание нескольких образов или основа для других этапов
* для идентификации - ID или можно назначить имя через `AS`
* если не указаны `tag` или `digest` - используется `:latest`

`--platform` задает платформу, если для разных создается `linux/amd64`, `windows/amd64`. По умолчанию - текущая платформа демона, выполняющего билд.

### 7.2 RUN

2 формы:

    RUN <command> # (shellform) выполняется в оболочке /bin/sh -c или cmd /S /C
    RUN ["executable", "param1", "param2"]  # (execform)

Выполняет команды в новом слое образа и коммитит результат.

**execform** позволяет например выполнять команды в начальных образах без оболочек (обязательны двойные `"`, не одинарные, JSON-формат):

    RUN ["echo", "$HOME"] # переменная
    RUN ["/bin/bash", "-c", "echo hello"]

**execform** выполняет команды не через оболочку, поэтому переменные окружения не будут установлены.

Команда `SHELL` может установить оболочку, которую использует `RUN`

Символ `/` - перенос строк:

    RUN /bin/bash -c 'source $HOME/.bashrc; \
        echo $HOME


### 7.3 CMD

3 формы:

    CMD ["executable","param1","param2"]    # execform, JSON-формат
    CMD ["param1","param2"]                 # параметры для ENTRYPOINT
    CMD command param1 param2               # shellform

Должна быть только одна комадна `CMD` в Dockerfile. Если несколько - только последняя будет учтена.

Задача: задать исполняемую команду и параметры по умолчанию для контейнера (что будет выполнено при старте контейнера).

Может задавать только параметры (форма # 2) для команды `ENTRYPOINT`.

Как и для `RUN` запуск execform - без оболочки, переменные окружения недоступны

    CMD [ "echo", "$HOME" ] # после запуска контейнера выведет $HOME

Параметры, указываемые в `docker run` после имени контейнера, будут перекрывать параметры команды `CMD`, указанные в dockerfile.

### 7.4 LABEL

Задает метаданные образа: ключ-значение.

    LABEL <key>=<value> <key>=<value> <key>=<value> ...

Разные примеры переноса строк, работы с пробелами:
    
    LABEL "com.example.vendor"="ACME Incorporated"
    LABEL com.example.label-with-value="foo"
    LABEL version="1.0"
    LABEL description="This text illustrates \
            that label-values can span multiple lines."

При создании образ наследует метки из базовых образов. При совпадении имен - поздние будут перезаписывать.

Посмотреть метки:
    
    docker image inspect <имя>

### 7.5 EXPOSE

    EXPOSE <port> [<port>/<protocol>...]

Заявление, что контейнер слушает на указанном порту. Для публикации нужно запускать контейнер с флагом `-p` или `-P`.

Примеры:

    EXPOSE 80/tcp
    EXPOSE 80/udp

### 7.6 ENV

    ENV <key>=<value> ...

Задает переменные окружения для последующих команд и запущенного контейнера.

Для экранирования пробелов - `"` или `\`:

    ENV MY_NAME="John Doe"
    ENV MY_DOG=Rex\ The\ Dog
    ENV MY_CAT=fluffy

Установленные переменные видны в запущенном контейнере. Посмотреть можно в `docker inspect`. Изменить во время запуска `docker run --env <key>=<value>`.

Если переменные нужны только во время билда и не нужны в контейнере - использовать `ARG`

### 7.7 ADD

    ADD [--chown=<user>:<group>] <src>... <dest>
    ADD [--chown=<user>:<group>] ["<src>",... "<dest>"]

Копирует файлы с текущей системы из пути `src` в контейнер по пути `dest`.

`src` - всегда относительный путь (относительно контекста), `dest` - абсолютный или относительный путь в контейнере (относительно `WORKDIR`).

Примеры:

    ADD test.txt relativeDir/
    ADD test.txt /absoluteDir/

Можно использовать wildcards для `src`.

Файлы добавляются с UID = 0 и GID = 0, если не задан `--chown`. Можно задать имя группы/пользователя или ID. Работает через стандартные `/etc/passwd` и `/etc/group`

Особенности:

* если `dest` заканчивается на `/` - это директория, иначе - файл
* если `src` - tar архив, будет распакован
* если `src` - директория, содержимое будет скопировано, не сама директория
* `src` - только внутри контекста, нельзя например `../smthng` (контекст копируется в демон)


### 7.8 COPY

    COPY [--chown=<user>:<group>] <src>... <dest>
    COPY [--chown=<user>:<group>] ["<src>",... "<dest>"]

Просто копирует файлы, без возможностей команды `ADD`: разархивирование, работа с url.

Дополнительно есть флаг `--from=<name>`. Позволяет в качестве источника задавать предыдущий этап создания образа (`FROM ... as <name>`).

### 7.9 ENTRYPOINT

    ENTRYPOINT ["executable", "param1", "param2"]   # execform
    ENTRYPOINT command param1 param2                # shellform

Задает исполняемую команду для контейнера.

При использовании shellform, команды выполняются через `/bin/sh -c`. Это значит, что внутри контейнера с PID = 1 будет запущена оболочка и сигналы (например об остановке (docker stop)) не будут передаваться исполняемой команде.

Переопределить можно через `--entrypoint` команды `docker run` (но без использования оболочки, только execform).


### 7.10 VOLUME

    VOLUME ["/data"]
    VOLUME /data

Указывает, что при запуске контейнера будет создан том и смонтирован в контейнер. Можно копировать файлы в том:

    FROM ubuntu
    RUN mkdir /myvol
    RUN echo "hello world" > /myvol/greeting
    VOLUME /myvol

Все изменения с томом (копирование файлов и т. п.) должны выполнятся до создания (до команды `VOLUME`).

### 7.11 USER

    USER <user>[:<group>]
    USER <UID>[:<GID>]

Задает пользователя / группу:

* для использования при запуске контейнера
* для всех последующих команд `RUN`, `CMD`, `ENTRYPOINT`

Если у пользователя группа не установлена, будет использована группа `root`

### 7.12 WORKDIR

    WORKDIR /path/to/workdir

Задает рабочую директорию для последующих `RUN`, `CMD`, `ENTRYPOINT`, `COPY` и `ADD`. Работает относительно контекста.

Можно несколько последовательных (первая - абсолютный путь, остальные - относительный):

    WORKDIR /a
    WORKDIR b
    WORKDIR c
    RUN pwd         # a/b/c

Может работать с переменными окружения, но только установленными командой `ENV`:

    ENV DIRPATH=/path
    WORKDIR $DIRPATH/$DIRNAME
    RUN pwd                         # /path/$DIRNAME

### 7.13 ARG

    ARG <name>[=<default value>]

Задает параметры, которые можно передать во время создания образа в команду `docker build`:

    docker build --build-arg <varname>=<value>

Исользование аргумента - `$<name>`. Область видимости - только после объявления:

    FROM busybox
    USER ${user:-some_user}     # здесь еще неизвестна
    ARG user
    USER $user                  # здесь будет использовать переданное значение

Нельзя передавать секреты - видны через `docker history`.

Если объявлены `ENV` и `ARG` с одинаковыми именами, `ENV` перекрывает всегда.

### 7.14 ONBUILD

    ONBUILD <INSTRUCTION>

Задает команду-триггер, которая будет выполнена, когда этот образ будет базовым при создании другого образа (сразу после `FROM`).

Например создаем образ с интерпретатором Python, на его основе будем строить образы с скриптами:

    ONBUILD ADD . /app/src
    ONBUILD RUN /usr/local/bin/python-build --dir /app/src

### 7.15 STOPSIGNAL

    STOPSIGNAL signal

Задает сигнал для остановки контейнера. По умолчанию это `SIGTERM`.

Другой способ - задать через флаг `--stop-signal` для `docker run` или `docker create`.

### 7.16 HEALTHCHECK

    HEALTHCHECK [OPTIONS] CMD command
    HEALTHCHECK NONE                    # отключить совсем

Указывает Докеру, как проверять, что контейнер работает в нормальном режиме. Если задано, у контейнера появляется **health status**: 

* `starting` - начальное состояние 
* `healthy` - после того, как пройдена проверка
* `unhealthy` - после нескольких неудачных попыток

Опции:

* `--interval=DURATION` - интервал опроса (30 сек по умолчанию)
* `--timeout=DURATION` - интервал одного опроса, до провала (30 сек по умолчанию)
* `--start-period=DURATION` - период на инициализацию, проваленные проверки в этот период не учитываются (0 сек по умолчанию)
* `--retries=N` - количетво попыток до изменения статуса (3 по умолчанию)
 
Команда - любая исполняемая или в execform. Возвращает 0 (успешно) или 1. Можно еще текстовое сообщение в stdout или stderr (будет сохранено и видно через `docker inspect`).

Пример (проверка web-сервера):

    HEALTHCHECK --interval=5m --timeout=3s \
        CMD curl -f http://localhost/ || exit 1
    
### 7.17 SHELL

    SHELL ["executable", "parameters"]

Задает оболочку для shellform разных команд.

По умолчанию: `["/bin/sh", "-c"]` и `["cmd", "/S", "/C"]`.

## 8. Best practices: общие рекомендации

### 8.1 Создавайте эфемерные контейнеры

Легкоперезапускаемые, с минимумом настроек, в соответствии с 12-факторной разработкой

### 8.2 Понимайте контекст (build context)

Текущая директория с содержимым, откуда запускается `docker build` передается в Docker-демон. 

Это не зависит от расположения Dockerfile, которое можно менять через `-f`

### 8.3 Dockerfile через конвейер (pipe) stdin

#### 8.3.1 Конвейер (pipe)

Варианты конвейеров:

* `|`
* `<<` ([bash docs](https://tldp.org/LDP/abs/html/here-docs.html))

Можно использовать любой способ.

Примеры:

    echo -e 'FROM busybox\nRUN echo "hello world"' | docker build -

    docker build -<<EOF
    FROM busybox
    RUN echo "hello world"
    EOF

#### 8.3.2 Dockerfile из stdin без отправки контекста

Используется флаг `-` для указания чтения Dockerfile из stdin:

    docker build -t myimage:latest -<<EOF
    FROM busybox
    RUN echo "hello world"
    EOF

#### 8.3.3 Dockerfile из stdin с локальным контекстом

    docker build [OPTIONS] -f- PATH

`-f` - флаг для указания Dockerfile, `-` - чтение из stdin.

    docker build -t myimage:latest -f- . <<EOF
    FROM busybox
    COPY somefile.txt ./
    RUN cat /somefile.txt
    EOF

#### 8.3.4 Dockerfile из stdin с удаленным контекстом

Тот же формат

    docker build [OPTIONS] -f- PATH

В качестве `PATH` - удаленный репозиторий. Делает `git clone` локально.

    docker build -t myimage:latest -f- https://github.com/docker-library/hello-world.git <<EOF
    FROM busybox
    COPY hello.c ./
    EOF

### 8.4 Исключайте лишние файлы через .dockerignore

### 8.5 Используйте multi-stage build

[docs](https://docs.docker.com/develop/develop-images/multistage-build/)

Многоэтапные сборки используются для создания более компактных и защищенных (за счет удаления лишних зависимостей) образов.

Например сборка и компиляция выделяется в отдельный этап. Всё, что связано с этим в итоговый образ не включается, а только результат этапа.

### 8.6 Не используйте ненужные зависимости

Уменьшение сложности, размера и т. п.

### 8.7 Декомпозируйте контейнеры/приложения

Стремиться к: одно приложение - один контейнер. 

Например приложение из веб-сервера, БД, in-memory кеша, тогда свой контейнер на каждую часть.

Преимущества:

* возможность масштабирования
* переиспользование
* удобный анализ логов
* переносимость и предсказуемость

### 8.8 Минимизируйте количество слоев

Только команды `RUN`, `COPY`, `ADD` создают новые слои. Остальные создают временные слои, не увеличивающие размер образа.

Для уменьшения количества слоев можно использовать multi-stage build.

Файлы удаляйте в том же слое, где использовали (в той же команде `RUN`)



### 8.9 Сортируйте агрументы по алфавиту

Удобно для VSC и сопровождения

    RUN apt-get update && apt-get install -y \
      bzr \
      cvs \
      git \
      mercurial \
      subversion \
      && rm -rf /var/lib/apt/lists/*



### 8.10 Следите за порядком команд (кеширование)

При сборке слои сохраняются в кеше для ускорения повторных сборок.

Если слой меняется (например файл в нем изменился), он выбрасывается из кеша, и также выбрасываются последующие слои (по порядку команд в Dockerfile).

Отсюда рекомендации:

* слои делать меньше (например несколько команд `COPY` вместо одной)
* часто изменяемые слои располагать к концу Dockerfile

Например сналача копирование зависимостей, затем копирование исходников, не наоборот.


### 8.11 Используйте непривилегированных пользователей

#### 8.11.1 Основы

[п.5 habr](https://habr.com/ru/company/wunderfund/blog/586778/)

[habr](https://habr.com/ru/post/448480/)

По умолчанию процессы в контейнере - под root-правами. Желательно ограничивать:

    RUN addgroup --system app && adduser --system --group app
    # переключиться на нового пользователя
    USER app
  
Даже при копировании файлов - указывать владельца явно, ведь по умолчанию - root:

    COPY --chown=node:node . /usr/src/app

Подробнее про опасности root - [6](https://snyk.io/blog/10-best-practices-to-containerize-nodejs-web-applications-with-docker/)

#### 8.11.2 Как создавать пользователей

Просмотр пользователей и групп:

    cat /etc/passwd
    cat /etc/group

В дистрибутиве alpine:

    # alpine:
    RUN addgroup -g 2000 node \                             # -g GID имя
        && adduser -u 2000 -G node -s /bin/sh -D node   
    # -u UID -G группа -D без пароля

В Debian дистрибутивах:

    RUN groupadd --gid 2000 node \
        && useradd --uid 2000 --gid node --shell /bin/bash --create-home node

Далее переключаемся на пользователя

    USER node

Или по UID

    USER 2000

??? Что если смонтировали том и передали в контейнер с нерутовым пользователем: 

* пользователь в контейнере не сможет создавать там файлы (как и нерутовый пользователь хоста и не в группе docker)
* том в контейнере получает владельца и группу `root` даже, если в контейнере была директория с другими владельцами

Вариант решения UID пользователя в контейнере должен совпадать с UID пользователя хоста, у которого есть права на директорию тома [отсюда](https://habr.com/ru/post/448480/)

### 8.12 Версионирование образов

Не используйте тег `latest` для базовых образов: нет контроля над версиями ПО. Базовый образ должен иметь явную версию.

Например так с указанием тега и хеша (см. [6]):
    
    FROM node:lts-alpine@sha256:b2da...b27390a


Для собственных внутренних образов определите стратегию для тегов (имен). Например: 

    docker build -t web-prod-a072c4e5d94b5a769225f621f08af3d4bf820a07-0.1.4 

Здесь:

* Имя проекта: web
* Имя окружения: prod
* Хеш Git-коммита: a072c4e5d94b5a769225f621f08af3d4bf820a07
* Семантическая версия: 0.1.4

[stackover про версионирование](https://stackoverflow.com/questions/56212495/properly-versioning-docker-images/56213290#56213290)

### 8.13 Не храните секреты в образах

Правильные варианты:

* передача в переменные окружения во время выполнения `docker run .. --env "password=123"`
    - но видны например через `docker inspect`
    - можно через тома, защифровав через хранилище (Vault) 
* через аргументы при сборке контейнера `ARG`
    - видны через `docker history` если есть доступ к образу
    - если это разовый ключ (SSH для скачивания) - многоэтапная сборка, не сохраняет промежуточные этапы
* через инструменты в средах оркестрации (Docker Secrets, Kubernetes Secrets)

[build secrets](https://pythonspeed.com/articles/docker-build-secrets/)

### 8.14 Используйте статический анализ Dockerfile и сканеры уязвимости

[hadolint](https://hadolint.github.io/hadolint/)

[варианты сканеров](https://habr.com/ru/company/wunderfund/blog/586778/)

### 8.15 Правильно выбирайте команду для запуска основного процесса внутри контейнера

Сам Docker, системы оркестрации управляют контейнерами через отправку сигналов внутрь контейнера. Обычно это `SIGTERM` или `SIGKILL`. И они отправляются процессу с PID=1.

Важно чтобы эти сигналы доходили до нужного процесса. 

Первая проблема: запуск через что-то промежуточное. Например запуск Nodejs как `CMD "npm" "start"` - `npm` не будет передавать сигналы.

Вторая проблема: запуск в shell-форме - сигналы также не будут доходить до процесса. Оболочка (PID=1) получает сигнал `SIGTERM`, завершается, но дочерним процессам сигналы не посылает. Docker вынужден грубо их завершать через `SIGKILL`.

Если через оболочку нужно запустить (скрипт например), можно использовать команду `exec` (подменяет оболочку на исполняемую команду):

    exec /app/bin/your-app

Третья проблема: запуск в exec-форме запускает процесс с PID=1. А для ядра это особый процесс (должен решать задачи по завершению дочерних процессов). Исполняемая команда приложения скорее всего не будет этим заниматься. Возможны зомби процессы ([habr 2015](https://habr.com/ru/company/hexlet/blog/248519/)). 

Подробно в [github dumb-init](https://github.com/Yelp/dumb-init)

[еще про PID=1 и dumb-init](https://engineeringblog.yelp.com/2016/01/dumb-init-an-init-for-docker.html)

Решение - использование специальной прослойки `dumb-init`:

    RUN apk add dumb-init
    CMD "dumb-init" "java" "-jar" "java-application.jar"

Возможно уже решается стандартными средствами (docker-compose init?)

Почему контейнер долго останавливается? возможно процесс с PID=1 не принимает SIGTERM. Docker после таймаута посылает SIGKILL

[Почему приложение в контейнере не принимает сигналы](https://hynek.me/articles/docker-signals/)


### 8.16 Уменьшайте размер образов (сводные рекомнедации)
 
[devops helsinki p.3](https://devopswithdocker.com/part3/)

* уменьшение числа слоев
    - объединение команд в `RUN`
    - контроль через `docker image history`
* удаление лишних данных
    - удаление кеша пакетного менеджера `rm -rf /var/lib/apt/lists/*`
    - удаление лишних зависимостей после использования, например `apt-get purge -y --auto-remove curl`
* базовый образ - alpine
    - установка без кеша `apk add --no-cache ...`
    - удаление зависимостей `apk del curl`
* multi-stage build: 
    - компиляция на отдельном этапе
    - в итоговый образ не включать средства компиляции
    - только исполняемые файлы

## 9. Best practices: команды

### 9.1 FROM

Использовать в качестве базового образа официальные образы. Можно начать с `alpine` - небольшой Linux дистрибутив.

### 9.2 LABEL

[подробнее](https://docs.docker.com/config/labels-custom-metadata/)

Лучше отдельная команда на каждую метку, но можно несколько в одной команде. Разница - только визуально.

### 9.3 RUN

#### 9.3.1 Общее

Разделять сложные команды на строки через `/`, сортировать аргументы команд по алфавиту.

Объединение команд через `;` или `&&`. (???) Предпочтительнее `&&`, т. к. ошибка в любой части остановит билд.

#### 9.3.2 apt-get

Всегда использовать `apt-get update` и `apt-get install` в одной команде `RUN`:

    RUN apt-get update && apt-get install -y \
         package-bar

Если разделить, результат `RUN apt-get update` будет закеширован, и изменение в `RUN apt-get install...` не будет использовать последнее состояние репозиториев.

Версии пакета не указываются (тогда последние) или указываются для воспроизводимости.

Рекомендуется вызывать в конце `rm -rf /var/lib/apt/lists/*` для очистки кеша и уменьшения размера. Официальные образы Debian и Ubuntu автоматически вызывают `apt-get clean`, для них необязательно.

Пример:

    RUN apt-get update && apt-get install -y \
        aufs-tools \
        curl \
        ruby1.9.1 \
        ruby1.9.1-dev \
        s3cmd=1.1.* \
     && rm -rf /var/lib/apt/lists/*


#### 9.3.3 Использование конвейеров (pipe)

Пример:

    RUN wget -O - https://some.site | wc -l > /number

Вопрос, что если промежуточная команда падает с ошибкой?

Т. к. выполняется через `/bin/sh -c`, результат всего конвейера - это результат последней команды (в примере `wc` вернет успешный результат, даже если `wget` с ошибкой будет). 

Если установить `set -o pipefail` (не для всех оболочек), ошибка на промежуточном этапе будет передана в конец и не даст создать слой.

    RUN set -o pipefail && wget -O - https://some.site | wc -l > /number

Запуск с конкретной оболочкой:

    RUN ["/bin/bash", "-c", "set -o pipefail && wget -O - https://some.site 
                | wc -l > /number"]


### 9.4 CMD

Предпочтительно использовать в execform.

Лучше использовать `CMD`, чем `ENTRYPOINT` + `CMD ["param1", "param2"]`

### 9.5 ENV

[ENV vs ARG](https://vsupalov.com/docker-arg-env-variable-guide/)

Обычно используется для установки `PATH`:

    ENV PATH=/usr/local/nginx/bin:$PATH
    # теперь просто можно
    CMD ["nginx"]

Для установки переменных для сервисов (например `PGDATA`).

Для переменных версий и использования этих переменных:

    ENV PG_MAJOR=9.3
    ENV PG_VERSION=9.3.4
    RUN curl -SL https://example.com/postgres-$PG_VERSION.tar.xz | tar ...
    ENV PATH=/usr/local/postgres-$PG_MAJOR/bin:$PATH

`ENV` прописывает переменную в слое. Последующая команда `RUN unset` не удалит переменную окружения из контейнера. Если переменная нужна на время билда - `RUN export ...` и используем ее в той же команде `RUN`. 

### 9.6 COPY или ADD

Приоритет - `COPY` как более прозрачная и понятная команда.

`ADD` - если нужно разархивировать tar файл в образ.

Несколько файлов добавлять лучше отдельными командами, а не одной (весь кеш не будет сбрасываться при изменении одного файла (?? количество слоев)).

Явно указывайте, что копируется: `COPY ./123.txt .` вместо `COPY . .`

### 9.7 ENRTYPOINT

Задает основную команду образа + `CMD` задает параметры по умолчанию.

Позволяет запускать через контейнер команду с параметрами, например:

    ENTRYPOINT ["s3cmd"]
    CMD ["--help"]
    # можно docker run s3cmd ls s3://mybucket

Можно вспомогательный скрипт, например образ Postgres использует

    COPY ./docker-entrypoint.sh /
    ENTRYPOINT ["/docker-entrypoint.sh"]
    CMD ["postgres"]

### 9.8 USER

Если сервис может запускаться без привилегий, следует создавать отдельных пользователей, например:

    RUN groupadd -r postgres && useradd --no-log-init -r -g postgres postgres

Здесь `--no-log-init` - для обхода бага в Go.

Избегать использования `sudo` - сложности с передачей сигналов. Если нужно запустить с рутовыми правами под непривилегированным пользователем - смотреть в сторону [gosu](https://github.com/tianon/gosu)(замена для `sudo`).

Для сокращения слоев - меньше переключаться между пользователями через команду `USER`.


### 9.9 WORKDIR

Для ясности всегда использовать абсолютные пути.

Не использовать `cd`, например `RUN cd … && do-something`




