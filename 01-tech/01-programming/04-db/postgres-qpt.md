# Оптимизация запросов

[source](https://postgrespro.ru/education/courses/QPT)

## Содержание

<!-- MarkdownTOC autolink="true" uri_encoding="false" levels="2,3" -->

- [0. Разное](#0-Разное)
    - [0.1 Просмотр этапов выполнения запроса в логах](#01-Просмотр-этапов-выполнения-запроса-в-логах)
    - [0.2 Подготовка запросов и просмотр подготовленных запросов](#02-Подготовка-запросов-и-просмотр-подготовленных-запросов)
    - [0.3 Отображение времени выполнения команд psql \(в т. ч. запросов\)](#03-Отображение-времени-выполнения-команд-psql-в-т-ч-запросов)
- [1. Выполнение запросов](#1-Выполнение-запросов)
    - [1.1 Подходы к оптимизации](#11-Подходы-к-оптимизации)
    - [1.2 Этапы выполнения запроса](#12-Этапы-выполнения-запроса)
    - [1.3 Расширенные запросы](#13-Расширенные-запросы)
    - [1.4 Этап планирования](#14-Этап-планирования)
- [2. Последовательное сканирование](#2-Последовательное-сканирование)
    - [2.1 Последовательное сканирование \(Seq Scan\)](#21-Последовательное-сканирование-seq-scan)
    - [2.2 Распараллеливание запросов](#22-Распараллеливание-запросов)
    - [2.3 Параллельное последовательное сканирование \(Parallel Sec Scan\)](#23-Параллельное-последовательное-сканирование-parallel-sec-scan)
    - [2.4 Настройка параллельных запросов](#24-Настройка-параллельных-запросов)
    - [2.5 Примеры анализа](#25-Примеры-анализа)

<!-- /MarkdownTOC -->

## 0. Разное

### 0.1 Просмотр этапов выполнения запроса в логах

Устанавливаем параметры

    ALTER SYSTEM SET log_parser_stats = on;
    ALTER SYSTEM SET log_planner_stats = on;
    ALTER SYSTEM SET log_executor_stats = on;
    SELECT pg_reload_conf();

Теперь можно выполнять анализ и смотреть логи

    EXPLAIN (ANALYZE, COSTS OFF, TIMING OFF) SELECT * FROM ticket_flights;

    tail -n 50 /var/log/postgresql/postgresql-10-main.log | egrep 'LOG: |elapsed'

### 0.2 Подготовка запросов и просмотр подготовленных запросов

Создаем:

    PREPARE model(varchar) AS SELECT model FROM aircrafts WHERE aircraft_code = $1;

Все подготовленные хранятся в **pg_prepared_statements** до конца сеанса:

    SELECT * FROM pg_prepared_statements \gx

### 0.3 Отображение времени выполнения команд psql (в т. ч. запросов)

    \timing on
    
## 1. Выполнение запросов

### 1.1 Подходы к оптимизации

* Мониторинг нагрузки и подстраивание системы под нее (конфигурационные параметры, настройка ОС и т. п.)
    - глобально влияет на всю систему
* Уменьшение нагрузки
    - основная нагрузка создается запросами
    - можно оптимизировать отдельные запросы, что положительно скажется на всей системе
    

### 1.2 Этапы выполнения запроса

* **Разбор** (parse)
    - синтаксический: проверяется корректность запроса
    - семантический: какие объекты БД требуются, если ли на них права (анализируется например `pg_tables`)
    - результат разбора - дерево
    - можно посмотреть в логах, если включить `debug_print_parse`, но особо не нужно
* **Переписывание** (rewrite)
    - например добавляются тексты запросов вместо представлений
* **Планирование** 
    - планировщик (оптимизатор) перебирает возможные способы выполнения запроса
    - дает оценку выполнения на основе статистики
    - выбирает наиболее оптимальный план
* **Выполнение**
    - по выбранному плану 
    - обход дерева, начиная с нижних узлов
    - каждый узел передает данные верхнему узлу
    - разные типы узлов: выбирают данные из тадлиц, соединяют данные от других узлов, сортируют и т. п.
    
### 1.3 Расширенные запросы

**Подготовленные запросы** и **курсоры**

Подготовленный (параметризованный) запрос:

* клиент передает запрос с параметрами
* сервер выполняет разбор и переписывание и сохраняет результат (дерево) в локальной памяти процесса
* клиент вызывает запрос по имени с значениями параметров
* сервер планирует и выполняет запрос
* экономия на разборе запроса, если несколько раз выполняется в течении сеанса

Если параметров нет, сервер сразу планирует подготовленный запрос и хранит его в памяти.

С параметрами перепланирует запрос ограниченное число раз (5). Если общий план не хуже частных, перестает использовать перепланирование.

Курсоры:

* запрос выполняется по частям
* курсоры хранятся в локальной памяти процесса

### 1.4 Этап планирования

#### 1.4.1 Критерии стоимости плана

Оптимизатор перебирает планы, оценивает их стоимость, выбирает с наименьшей стоимостью.

Для оценки стоимости:

* **селективность** - доля строк, отбираемых условиями
* **кардинальность** - обшее число строк

Нужна статистика. Основные ошибки - если неверно оценена кардинальность (неадекватная статистика)

#### 1.4.2 Оценка кардинальности

Кардинальность как рекурсивный процесс: оцениваем кардинальность дочерних узлов, затем зная тип узла - его кардинальность.

Например сначала оценивается кардинальность узлов доступа к данным (на основе размера таблиц и селективности). Если можем оценить селективность простых условий, селективность сложных (AND, OR) - выводится из простых по формулам:

    sel(a AND b) = sel(a) * sel(b)
    sel(a OR b) = 1 - (1 - sel(a)) * (1 - sel(b))

Затем оценивается кардинальность соединений (см. далее как)

Если возникают ошибки оценки в нижних узлах - нарастают и могут приводить к выбору неверного плана


#### 1.4.3 Оценка стоимости

Также рекурсивный процесс: стоимость дерева = стоимость узла + стоимость поддерева.

Стоимость узла - мат. модель на основе числа обрабатываемых строк. Для каждого типа узла - своя модель.

    Стоимость = стоимость подготовки + стоимость выборки

Некоторые узлы не имеют подготовки. У некоторых всегда она будет (например узел сортировки сначала выбирает данные, затем сортирует)

Стоимость - просто оценка. Выражена в условных единицах. Может не коррелировать с временем выполнения.


#### 1.4.4 Выбор плана

Оптимизатор пытается перебрать все планы (порядок соединений, способы соединений, методы доступа)

Если слишком много вариантов - переключается на генетический алгоритм.

Что такое лучший план:

* для обычных и подготовленных запросов - минимальная общая стоимость (минимальное время получение всего результата)
* для курсоров - минимизируется время получения первых результатов
    - есть параметр `cursor_tuple_fraction` - доля строк для быстрого получения. По умолчанию - 0.1


## 2. Последовательное сканирование

### 2.1 Последовательное сканирование (Seq Scan)

Доступ к данным через последовательное сканирование страниц файла. На странице читаются строки и проверяется их видимость.

При чтении - буферное кольцо, процессы могут присоединятся к чтению.

Эффективно, если нужно читать большую часть таблицы (селективность низкая).

### 2.2 Распараллеливание запросов

Ведущий процесс, выполняющий запрос, порождает несколько рабочих процессов, передавая им часть плана (параллельный план). Рабочие процессы передают результат своей работы в узел `Gather` ведущего процесса.

Если у ведущего процесса есть время, он может также выполнять параллельную часть плана.

### 2.3 Параллельное последовательное сканирование (Parallel Sec Scan)

Страницы таблицы читаются последовательно, но страницы распределяются между несколькими рабочими процессами. Рабочие процессы синхронизированны, что чтение шло в правильном порядке. 

Дает выигрыш, если происходит не только чтение, а еще и обработка страниц (например подсчет агрегация)

### 2.4 Настройка параллельных запросов

Общее число рабочих процессов (не только запросы, но и например репликация) ограничено `max_worker_processes` - 8 по умолчанию.

Из этих процессов, количество процессов, занимающихся параллельными планами, ограничено `max_parallel_workers` - 8 по умолчанию.

Ограничено количество одновременных рабочих процессов на один ведущий - `max_parallel_workers_per_gather` - 2 по умолчанию.

Нет смысла увеличивать, если нет свободных ядер в системе.

Выбор количества параллельных рабочих процессов:

* если размер таблицы меньше `min_parallel_table_scan_size` (8 МБ), планировщик не будет распараллеливать
* будет увеличивать количество процессов на каждое утроение размера таблицы (8МБ - 1 процесс, 24МБ - 2, 72МБ - 3 и т. д.)
* если для таблицы задан параметр `parallel_workers`, будет его использовать

Но во всех случаях **не превышает max_parallel_workers_per_gather** и **не выходит за общий пул max_worker_processes**

Не распараллеливаются совсем:

* запросы меняющие или блокирующие данные (INSERT, DELETE, SELECT FOR UPDATE и т. п.)
* курсоры
* функции с пометкой `PARALLEL UNSAFE`
* запросы в функциях из уже распараллеленного процесса
* запросы на уровне SERIALIZABLE

### 2.5 Примеры анализа

#### 2.5.1 Последовательное сканирование

    EXPLAIN SELECT * FROM flights;
                           QUERY PLAN                           
    ----------------------------------------------------------------
     Seq Scan on flights  (cost=0.00..4564.67 rows=214867 width=63)

Здесь `cost` - стоимость плана (первое число - стоимость подготовительного этапа, второе - общая стоимость), `rows` - оценка возвращаемого количества строк, `width` - оценка размера одной записи в байтах (не очень интересно)

Мат. модель для последовательного сканирования состоит из двух частей.

Первая - чтение страниц из памяти (стоимость чтения страницы в у.е. на количество страниц в таблице):

    SELECT relpages, current_setting('seq_page_cost'),  
        relpages * current_setting('seq_page_cost')::real AS total 
    FROM pg_class WHERE relname='flights';

        relpages | current_setting | total 
       ----------+-----------------+-------
            2416 | 1               |  2416


Вторая - обработка строк (количество строк умножается на стоимость обработки одной строки):

    SELECT reltuples, current_setting('cpu_tuple_cost'),
        reltuples * current_setting('cpu_tuple_cost')::real AS total
    FROM pg_class WHERE relname='flights';

     reltuples | current_setting |  total  
    -----------+-----------------+---------
        214867 | 0.01            | 2148.67

#### 2.5.2 Последовательное сканирование с агрегированием

    EXPLAIN SELECT count(*) FROM seats;
                          QUERY PLAN                           
    ---------------------------------------------------------------
     Aggregate  (cost=24.74..24.75 rows=1 width=8)
       ->  Seq Scan on seats  (cost=0.00..21.39 rows=1339 width=0)

Здесь у узла Aggregate есть подготовка.

Разница между стоимостью Aggregate и Sec Scan - собственно расчет количества в узле Aggregate:

    SELECT reltuples, current_setting('cpu_operator_cost'),
        reltuples * current_setting('cpu_operator_cost')::real AS total
    FROM pg_class WHERE relname='seats';

        reltuples | current_setting | total  
       -----------+-----------------+--------
            1339 | 0.0025          | 3.3475

#### 2.5.3 Параллельное последовательное сканирование

    EXPLAIN SELECT count(*) FROM bookings;
                        QUERY PLAN                              
    -------------------------------------------------------------------------
     Finalize Aggregate  (cost=25442.58..25442.59 rows=1 width=8)
     ->  Gather  (cost=25442.36..25442.57 rows=2 width=8)
       Workers Planned: 2
        ->  Partial Aggregate  (cost=24442.36..24442.37 rows=1 width=8)
         ->  Parallel Seq Scan on bookings  (cost=0.00..22243.29 rows=879629 width=0)

Эффективное количество рабочих процессов - 2.4 (2 параллельных + ведущий процесс часть работы возьмет). Отсюда количество обработанных строк:

    SELECT round(reltuples / 2.4) FROM pg_class WHERE relname = 'bookings';
      => 879629 

Оценка обработки этих строк (страницы все равно читаем полностью, но обработка делится между процессами):

    SELECT round( relpages * current_setting('seq_page_cost')::real +
        reltuples * current_setting('cpu_tuple_cost')::real / 2.4
    ) FROM pg_class WHERE relname = 'bookings';
        => 22243

Стоимость узла **Partial Aggregate** (подсчет количества):

    SELECT round(reltuples / 2.4 * current_setting('cpu_operator_cost')::real)
        FROM pg_class WHERE relname='bookings';
        => 2199

Стоимость **Gather** - это стоимость запуска рабочих процессов и получение от них данных:

    SELECT current_setting('parallel_setup_cost') parallel_setup_cost,
        current_setting('parallel_tuple_cost') parallel_tuple_cost;
         parallel_setup_cost | parallel_tuple_cost 
        ---------------------+---------------------
         1000                | 0.1
