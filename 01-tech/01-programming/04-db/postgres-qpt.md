# Оптимизация запросов

[source](https://postgrespro.ru/education/courses/QPT)

## Содержание

<!-- MarkdownTOC autolink="true" uri_encoding="false" levels="2,3" -->

- [0. Разное](#0-Разное)
    - [0.1 Просмотр этапов выполнения запроса в логах](#01-Просмотр-этапов-выполнения-запроса-в-логах)
    - [0.2 Подготовка запросов и просмотр подготовленных запросов](#02-Подготовка-запросов-и-просмотр-подготовленных-запросов)
    - [0.3 Отображение времени выполнения команд psql \(в т. ч. запросов\)](#03-Отображение-времени-выполнения-команд-psql-в-т-ч-запросов)
- [1. Выполнение запросов](#1-Выполнение-запросов)
    - [1.1 Подходы к оптимизации](#11-Подходы-к-оптимизации)
    - [1.2 Этапы выполнения запроса](#12-Этапы-выполнения-запроса)
    - [1.3 Расширенные запросы](#13-Расширенные-запросы)
    - [1.4 Этап планирования](#14-Этап-планирования)
- [2. Последовательное сканирование](#2-Последовательное-сканирование)
    - [2.1 Последовательное сканирование \(Seq Scan\)](#21-Последовательное-сканирование-seq-scan)
    - [2.2 Распараллеливание запросов](#22-Распараллеливание-запросов)
    - [2.3 Параллельное последовательное сканирование \(Parallel Sec Scan\)](#23-Параллельное-последовательное-сканирование-parallel-sec-scan)
    - [2.4 Настройка параллельных запросов](#24-Настройка-параллельных-запросов)

<!-- /MarkdownTOC -->

## 0. Разное

### 0.1 Просмотр этапов выполнения запроса в логах

Устанавливаем параметры

    ALTER SYSTEM SET log_parser_stats = on;
    ALTER SYSTEM SET log_planner_stats = on;
    ALTER SYSTEM SET log_executor_stats = on;
    SELECT pg_reload_conf();

Теперь можно выполнять анализ и смотреть логи

    EXPLAIN (ANALYZE, COSTS OFF, TIMING OFF) SELECT * FROM ticket_flights;

    tail -n 50 /var/log/postgresql/postgresql-10-main.log | egrep 'LOG: |elapsed'

### 0.2 Подготовка запросов и просмотр подготовленных запросов

Создаем:

    PREPARE model(varchar) AS SELECT model FROM aircrafts WHERE aircraft_code = $1;

Все подготовленные хранятся в **pg_prepared_statements** до конца сеанса:

    SELECT * FROM pg_prepared_statements \gx

### 0.3 Отображение времени выполнения команд psql (в т. ч. запросов)

    \timing on
    
## 1. Выполнение запросов

### 1.1 Подходы к оптимизации

* Мониторинг нагрузки и подстраивание системы под нее (конфигурационные параметры, настройка ОС и т. п.)
    - глобально влияет на всю систему
* Уменьшение нагрузки
    - основная нагрузка создается запросами
    - можно оптимизировать отдельные запросы, что положительно скажется на всей системе
    

### 1.2 Этапы выполнения запроса

* **Разбор** (parse)
    - синтаксический: проверяется корректность запроса
    - семантический: какие объекты БД требуются, если ли на них права (анализируется например `pg_tables`)
    - результат разбора - дерево
    - можно посмотреть в логах, если включить `debug_print_parse`, но особо не нужно
* **Переписывание** (rewrite)
    - например добавляются тексты запросов вместо представлений
* **Планирование** 
    - планировщик (оптимизатор) перебирает возможные способы выполнения запроса
    - дает оценку выполнения на основе статистики
    - выбирает наиболее оптимальный план
* **Выполнение**
    - по выбранному плану 
    - обход дерева, начиная с нижних узлов
    - каждый узел передает данные верхнему узлу
    - разные типы узлов: выбирают данные из тадлиц, соединяют данные от других узлов, сортируют и т. п.
    
### 1.3 Расширенные запросы

**Подготовленные запросы** и **курсоры**

Подготовленный (параметризованный) запрос:

* клиент передает запрос с параметрами
* сервер выполняет разбор и переписывание и сохраняет результат (дерево) в локальной памяти процесса
* клиент вызывает запрос по имени с значениями параметров
* сервер планирует и выполняет запрос
* экономия на разборе запроса, если несколько раз выполняется в течении сеанса

Если параметров нет, сервер сразу планирует подготовленный запрос и хранит его в памяти.

С параметрами перепланирует запрос ограниченное число раз (5). Если общий план не хуже частных, перестает использовать перепланирование.

Курсоры:

* запрос выполняется по частям
* курсоры хранятся в локальной памяти процесса

### 1.4 Этап планирования

#### 1.4.1 Критерии стоимости плана

Оптимизатор перебирает планы, оценивает их стоимость, выбирает с наименьшей стоимостью.

Для оценки стоимости:

* **селективность** - доля строк, отбираемых условиями
* **кардинальность** - обшее число строк

Нужна статистика. Основные ошибки - если неверно оценена кардинальность (неадекватная статистика)

#### 1.4.2 Оценка кардинальности

Кардинальность как рекурсивный процесс: оцениваем кардинальность дочерних узлов, затем зная тип узла - его кардинальность.

Например сначала оценивается кардинальность узлов доступа к данным (на основе размера таблиц и селективности). Если можем оценить селективность простых условий, селективность сложных (AND, OR) - выводится из простых по формулам:

    sel(a AND b) = sel(a) * sel(b)
    sel(a OR b) = 1 - (1 - sel(a)) * (1 - sel(b))

Затем оценивается кардинальность соединений (см. далее как)

Если возникают ошибки оценки в нижних узлах - нарастают и могут приводить к выбору неверного плана


#### 1.4.3 Оценка стоимости

Также рекурсивный процесс: стоимость дерева = стоимость узла + стоимость поддерева.

Стоимость узла - мат. модель на основе числа обрабатываемых строк. Для каждого типа узла - своя модель.

    Стоимость = стоимость подготовки + стоимость выборки

Некоторые узлы не имеют подготовки. У некоторых всегда она будет (например узел сортировки сначала выбирает данные, затем сортирует)

Стоимость - просто оценка. Выражена в условных единицах. Может не коррелировать с временем выполнения.


#### 1.4.4 Выбор плана

Оптимизатор пытается перебрать все планы (порядок соединений, способы соединений, методы доступа)

Если слишком много вариантов - переключается на генетический алгоритм.

Что такое лучший план:

* для обычных и подготовленных запросов - минимальная общая стоимость (минимальное время получение всего результата)
* для курсоров - минимизируется время получения первых результатов
    - есть параметр `cursor_tuple_fraction` - доля строк для быстрого получения. По умолчанию - 0.1


## 2. Последовательное сканирование

### 2.1 Последовательное сканирование (Seq Scan)

Доступ к данным через последовательное сканирование страниц файла. На странице читаются строки и проверяется их видимость.

При чтении - буферное кольцо, процессы могут присоединятся к чтению.

Эффективно, если нужно читать большую часть таблицы (селективность низкая).

### 2.2 Распараллеливание запросов

Ведущий процесс, выполняющий запрос, порождает несколько рабочих процессов, передавая им часть плана (параллельный план). Рабочие процессы передают результат своей работы в узел `Gather` ведущего процесса.

Если у ведущего процесса есть время, он может также выполнять параллельную часть плана.

### 2.3 Параллельное последовательное сканирование (Parallel Sec Scan)

Страницы таблицы читаются последовательно, но страницы распределяются между несколькими рабочими процессами. Рабочие процессы синхронизированны, что чтение шло в правильном порядке. 

Дает выигрыш, если происходит не только чтение, а еще и обработка страниц (например подсчет агрегация)

### 2.4 Настройка параллельных запросов

Общее число рабочих процессов (не только запросы, но и например репликация) ограничено `max_worker_processes` - 8 по умолчанию.

Из этих процессов, количество процессов, занимающихся параллельными планами, ограничено `max_parallel_workers` - 8 по умолчанию.

Ограничено количество одновременных рабочих процессов на один ведущий - `max_parallel_workers_per_gather` - 2 по умолчанию.

Нет смысла увеличивать, если нет свободных ядер в системе.

Выбор количества параллельных рабочих процессов:

* если размер таблицы меньше `min_parallel_table_scan_size` (8 МБ), планировщик не будет распараллеливать
* будет увеличивать количество процессов на каждое утроение размера таблицы (8МБ - 1 процесс, 24МБ - 2, 72МБ - 3 и т. д.)
* если для таблицы задан параметр `parallel_workers`, будет его использовать

Но во всех случаях **не превышает max_parallel_workers_per_gather** и **не выходит за общий пул max_worker_processes**

Не распараллеливаются совсем:

* запросы меняющие или блокирующие данные (INSERT, DELETE, SELECT FOR UPDATE и т. п.)
* курсоры
* функции с пометкой `PARALLEL UNSAFE`
* запросы в функциях из уже распараллеленного процесса
* запросы на уровне SERIALIZABLE