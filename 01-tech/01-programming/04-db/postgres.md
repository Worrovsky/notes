
## Содержание

<!-- MarkdownTOC autolink="true" uri_encoding="false" levels="2,3" -->

- [1. Установка и настройка](#1-Установка-и-настройка)
    - [1.1 Установка сервера](#11-Установка-сервера)
    - [1.2 Настройка переменных окружения](#12-Настройка-переменных-окружения)
    - [1.3 Начало работы](#13-Начало-работы)
    - [1.3.4 Команда pg_ctlcluster](#134-Команда-pg_ctlcluster)
    - [1.3.5 Где мои логи, чувак?](#135-Где-мои-логи-чувак)
- [2. Утилита psql](#2-Утилита-psql)
    - [2.1 Подключение к серверу](#21-Подключение-к-серверу)
    - [2.2 Основные команды](#22-Основные-команды)
    - [2.3 Выполнение скриптов при запуске](#23-Выполнение-скриптов-при-запуске)
    - [2.4 Форматирование вывода](#24-Форматирование-вывода)
    - [2.5 Разное](#25-Разное)
    - [2.6 Переменные psql и переменные окружения](#26-Переменные-psql-и-переменные-окружения)
- [3. Конфигурация](#3-Конфигурация)
    - [3.2 Файл postgresql.conf](#32-Файл-postgresqlconf)
    - [3.3 Файл postgresql.auto.conf](#33-Файл-postgresqlautoconf)
    - [3.4 Представление pg_file_settings](#34-Представление-pg_file_settings)
    - [3.5 Представление pg_settings](#35-Представление-pg_settings)
    - [3.6 Пользовательские параметры](#36-Пользовательские-параметры)
- [4. Архитектура](#4-Архитектура)
    - [4.1 Многоверсионность](#41-Многоверсионность)
    - [4.2 Уровни изоляции](#42-Уровни-изоляции)
    - [4.3 Буферный кеш и журналирование](#43-Буферный-кеш-и-журналирование)
- [5. Организация данных](#5-Организация-данных)
    - [5.1 Базы данных и схемы](#51-Базы-данных-и-схемы)
    - [5.2 Системный каталог](#52-Системный-каталог)
    - [5.3 Табличные пространства](#53-Табличные-пространства)
    - [5.4 Низкий уровень \(структура файлов\)](#54-Низкий-уровень-структура-файлов)

<!-- /MarkdownTOC -->


## 1. Установка и настройка

### 1.1 Установка сервера

[Инструкция с оф. сайта](https://www.postgresql.org/download/linux/ubuntu/)

    # Настраиваем репозиторий для apt-get
    sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
    
    # получаеи ключ для репозитория
    wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
    
    # собственно установка
    # здесь явно версия 10 указано, можно без указания, тогда актуальную 
    sudo apt-get update
    sudo apt-get -y install postgresql-10

Процесс установки:

* устанавливает в `/usr/lib/postgresql/` и утилиты в `/usr/bin/`
* создает пользователя `postgres` и группу `postgres`
* создает конфигурационные файлы в `/etc/postgresql/` и в `/etc/postgresql-common/` (напр. в `postgresql.conf` задана директория для БД)
* создает кластер БД в директории БД `var/lib/postgresql/10/main`, владелец - группа `postgres` через комманду `initdb`
* логи выводятся в `/var/log/postgresql/postgresql-10-main.log`
* также запускает сервер

### 1.2 Настройка переменных окружения

Все переменные не обязательны, просто для удобства

Добавить в `PATH` каталог с установленным PostgreSQL

**Вариант 1** (для конкретного пользователя):

    # зависит от оболочки, для bash
    # в файл ~/bashrc
    export PATH=$PATH:/usr/lib/postgresql/10/bin

**Вариант 2**

Через каталог `/etc/profile.d`: добавить туда скрипт с раcширением `.sh`

Это будет работать для всех пользователей, но только если они явно логинятся в систему (через `sudo su postgres` не буден работать) (см. login shell / non-login shell по ссылке ниже)

    sudo nano /etc/profile.d
        => PATH=$PATH:/usr/lib/postgresql/10/bin
    # сохранить

**Вариант 3**

Еще вариант - редактирование `/etc/environment`

[Подробно про переменные](https://stackoverflow.com/questions/14637979/how-to-permanently-set-path-on-linux-unix)

Можно создать переменную PGDATA (путь к директории БД (напр. `var/lib/postgresql/10/main`) )


### 1.3 Начало работы

#### 1.3.1 Пользователи ОС для сервера Postgres

Лучше использовать созданного в процессе установки пользователя `postgres` с одноименной группой. У него уже настроены необходимые разрешения.

Можно создать еще пользователя (зачем?): 

* `sudo adduser new_user`
* включить его в группу 134 ssl-cert (так у стандартного)
* дать новому пользователю права на `/var/run/postgresql` (через включение его в группу `postgres` ??)

#### 1.3.2 **Создание кластера БД**

Кластер - группа баз данных, управляемых одним экземпляром сервера Postgres

Для создания кластера необходимо:

* создать директорию для кластера БД, назначить владельцем пользователя `postgres`
    - `mkdir /var/lib/postgresql/10/testcluster`
    - `sudo chown postgres /var/lib/postgresql/10/testcluster`
    - `ls -l` покажет владельцев
* инициализировать кластер БД (от имени пользователя)
    - `sudo su postgres`
    - `initdb -k -D  /var/lib/postgresql/10/testcluster`
    - здесь `-k` включает подсчет контрольной суммы страниц (для обнаружения повреждений БД (влияет на производительность))
* вывод результата инициализации должен показать команду для запуска сервера

#### 1.3.3 Запуск / остановка

Если была стандартная установка сервер уже запущен.

Способы запуска:

* **pg_ctl** - низкоуровневая
    - `pg_ctl -D <каталог кластера> start`
* **pg_ctlcluster** - обертка над **pg ctl**, запускает по имени кластера
    - `pg_ctlcluster <версия кластера> <имя> start`

Кластера создаются по разному. При установке например, настройки хранятся в `/etc/postgresql/10/main` (в т. ч. конфигурационный файл). При создании кластера через `initdb -k -D ...` все настройки хранятся в том же каталоге, что и данные. 

Если конфигурационный файл расположен внутри кластера, можно запустить через `pg_ctl -D ... start`.

Если конфигурационный файл отдельно расположен, нужно указывать путь к нему `pg_ctl -D /var/lib/postgresql/10/main -o "-c config_file=/etc/postgresql/10/main/postgresql.conf" start`. Здесь через `-o` параметры передаются в команду `postgres` 

### 1.3.4 Команда pg_ctlcluster

* обертка для **pg_ctl**
* запускает по имени кластера
* внутри проверяет версию кластера и т. п. и запускает подходящую команду `pg_ctl`
* логи по умолчанию пишутся в `/var/logs/postgresql-<версия>-<имя кластера>`
* команды: start, stop, reload, status
* можно передавать параметры в вызываемую **pg_ctl**
* настройки может сохранять в `/etc/postgresql/<версия>/<имя>` или в директории кластера, в т. ч. **postgresql.conf** 

### 1.3.5 Где мои логи, чувак?

Смотрим переменную `log_destination` (метод логгирования):

    SHOW log_destination;

Там несколько вариантов может быть:

* `stderr` - по умолчанию
* `csvlog` - в формате csv
* `syslog` - пересылка логов сервисом, много настроек куда и как.
* `eventlog` - только для Win

Если `stderr`, также скорее всего куда-то перенаправляются.

Например при запуске через `pg_ctl -D ... start` вывод идет в терминал. Можно указать файл при запуске `pg_ctl -D ... -l mylog`. 

Стоит проверить переменную `logging_collector`

    SHOW logging_collector;

Если включен, значит см. переменные `log_directory` (если относительный - в каталоге кластера), `log_filename`.

Если выключен, системное расположение используется:

    # определить PID процесса
    # так например текущего psql
    select pg_backend_pid();
        => 31314
    # можно через top корневого postgres
    # затем проверить симлинк
    \! ls -l /proc/31314/fd/2
        => /var/log/postgresql/...
    # или из обычного терминала
    ls -l ....


**TODO**:

Просмотр процессов в терминале (м. б. top ?)

Запуск по умолчанию: systemd??? отключить, управление????

## 2. Утилита psql

### 2.1 Подключение к серверу

 Это терминальный клиент для работы с сервером PostgreSQL.

    psql -d <имя БД в кластере> -U <роль> -h <узел> -p <порт> 
    # после этого переход в режим ввода

Можно пробовать подключаться без указания параметров, тогда имя БД и роль будут браться по имени текущего пользователя (поэтому от имени пользователя `postgres` надо):

    sudo su postgres 
    psql

### 2.2 Основные команды

Команды начинаются с `\`.

Основные команды:

* `\c` - подключение к новой БД
* `\conninfo` - информация о текущем подключении 
* `\?` - справка по командам psql
* `\h` - список команд SQL
* `\h <имя комманды>` - синтаксис конкретной команды
* `\q` - выход

### 2.3 Выполнение скриптов при запуске

Можно настроить скрипты, выполняемые при запуске `psql`. Для этого общесистемный файл `psqlrc` или пользовательский `~/.psqlrc`. 

Общесистемный файл расположен в каталоге с настройками. Посмотреть расположение этого каталога `pg_config --sysconfdir`

Например так из оболочки под пользователем `postgres`

    # отображение времени выполнения запроса
    echo "\timing on" >> ~/.psqlrc
  
    # просмотрщик для результатов запросов
    echo "\setenv PAGER 'less -X'" >> ~/.psqlrc
    # можно флаг N еще добавить для вывода строк или в процессе работы переключать через `-N`. См. `man less`

### 2.4 Форматирование вывода

Полный список атрибутов можно посмотреть:

    \pset

Есть краткие команды:

* `\a` - переключение режима с выравнивания и без
* `\t` - переключение режима с выводом заголовков, итоговой строки и без
* `\x` - переключение режима вывода колонок в строки / в колонки

### 2.5 Разное

Выполнение команд оболочки: через `\!`

    \! pwd
    \! uptime

Запись в файл:

    # переключили в режим вывода в файл
    \o some_file 
    # здесь любые команды, результат выводится в файл
    ....
    # переключаем обратно
    \o 
    # можно посмотреть файл
    \! cat some_file

Запуск команд из файла:

    \i some-file
    # или из оболочки
    psql <some-file
    psql -f some-file

### 2.6 Переменные psql и переменные окружения

Аналог переменных окружения.

Устанавливаются через `\set` / `\unset`. Просмотр через `\echo`, полный список через `\set`

В переменную можно записать результат запроса:

    # внимание на отсутствие ;
    select now() as cur_time \gset
    \echo cur_time

В переменные можно записать текст запроса и выполнять его через переменную:

    \set cur_time 'select now();'
    # запуск
    :cur_time
    # просмотр переменной
    \echo :cur_time

Приглашения ввода:

    \set PROMPT1 '%n@%/%R%# '
    \set PROMPT2 '%n@%/%R%# '

Можно записать это в файлы `psqlrc`, тогда будет доступ всегда при запуске.

Работа с системными переменными из psql:
    
    # установка
    \setenv PAGER 'less -XSN'
    # просмотр
    \! echo $PAGER



## 3. Конфигурация

Разные параметры конфигурации можно устанавливать:

* для всего сеанса сервера
* для отдельной БД 
* для пользователя
* во время работы клиентского сеанса

### 3.2 Файл postgresql.conf

Главный источник параметров - файл `postgresql.conf`. Может находится или в каталоге с данными, или отдельно (напр. `/etc/postgresql`)

Посмотреть расположение (в pqsl):
    
    # команда SQL
    SHOW config_file;
    # показать все параметры
    SHOW ALL;

При изменении в файле, нужно чтобы сервер перечитал этот файл. Есть разные способы:
    
    # 1. через утилиты pg_ctl / pg_ctlcluster
    $ pg_ctl reload
    # 2. послать сигнал главному процессу сервера postmaster
    $ kill -HUP
    # 3. через psql
    => SELECT pg_reload_conf();

Для некоторых параметров может требоваться перезагрузка

### 3.3 Файл postgresql.auto.conf

Предназначен для редактирования конфигурационных параметров посредством команд SQL. Доступ к файлу не нужен:

    # установка значения (добавляет строку в файл)
    ALTER SYSTEM SET <параметр> TO <значение>;
    # удаление параметр (строку файла)
    ALTER SYSTEM RESET <параметр>;
    # удаление всех параметров из файла
    ALTER SYSTEM RESET ALL;

Файл считывается после `postgresql.conf`, т. е. настройки `postgresql.auto.conf` имеют приоритет

Всегда расположен в каталоге кластера БД.

Напрямую редактировать не стоит.

Чтобы изменения вступили в силу, также нужно чтобы сервер перечитал конфигурацию

### 3.4 Представление pg_file_settings

Одно из системных представлений.

    SELECT * FROM pg_file_settings;

Показывает сводное содержимое файлов конфигурации. Показывает, что есть в файлах, а не то, что сервер использует в данный момент. Для просмотра состояния сервера см. **pg_settiings**.

Колонки:

* `sourcefile` - файл-источник параметра (напр. `postgresql.conf`)
* `sourceline` - строка в файле
* `applied` - true/false может ли это изменение быть применено успешно
* `error` - описание ошибки

Если конфигурационный файл содержит синтаксические ошибки, представление будет содержать одну или нескольно строк с описанием ошибки.

### 3.5 Представление pg_settings

Показывает действующие значения конфигурационных параметров

    SELECT * FROM pg_settings;

Колонки:

* `name`, `setting`, `unit` - имя параметра, значение и единица измерения
* `boot_val` - значение по умолчанию
* `reset_val` - если во время сеанса будет вызвана команда `ALTER SYSTEM RESET`
* `source` - источник значения параметра
* `pending_restart` - значение изменено (например через конфигурационный файл) и требуется перезагрузка сервера
* минимальное и максимальное значение параметра

Колонка **context** описавает как можно изменить значение параметра:

* **internal** - это внутренний параметр, изменить непосредственно нельзя (пересобрать сервер может быть)
* **postmaster** - для изменения требуется перезапуск сервера
* **sighub** - можно без перезапуска, перечитав конфигурацию (reload)
* **superuser** - можно изменять в файле конфигурации или в сеансе ( команда SQL `SET`), но только суперпользователю. Параметры установленные через `SET` имеют больший приоритет, чем в файле конфигурации
* **user** - аналогично, но любой пользователь




### 3.6 Пользовательские параметры

Можно создавать свои параметры теми же способами, что и предопределенные:

* редактирование файла `postgresql.conf`
* через SQL команду `ALTER SYSTEM SET`
* установка на время сеанса через команду `SET`
* установка в запросе через функцию `set_config()`

Главное правило: имя должно содержать `.`, чтобы не путать с системными параметрами.

    SELECT CASE WHEN current_setting('myapp.currency_code', true) IS NULL THEN
                set_config('myapp.currency_code', 'RUB', false)
            ELSE
                current_setting('myapp.currency_code')
            END;




## 4. Архитектура

### 4.1 Многоверсионность

#### 4.1.1 Суть многоверсионности

Введена для решения проблем при многопоточном доступе. Если несколько процессов одновременно хотят записать данные в одну строку, вынуждены ставить блокировку и процессы будут ждать. Если есть читающий и пишущий процесс тоже нужна блокировка, чтобы не нарушить консистентность, но это будет влиять на производительность.

Поэтому Postgres каждую строку таблицы БД хранит в нескольких версиях. Строка имеет отметку о начале действия и конце действия. В качестве меток выступают номера транзакций (они выдаются по нарастающей, поэтому могут играть роль отметок времени).

Так например INSERT создает строку с началом действия. UPDATE устанавливает конец действия и создает новую строку. DELETE устанавливает конец действия.

Чтение выполняется через **снимок данных**. Определяются еще активные транзакции и выбираются действующие версии строк. 

Для хранения информации о транзакциях используется специальный файл в каталоге данных (**pg_xact**). Также есть буфер в памяти. Два бита на каждую транзакцию: зафиксирована и отменена. При этом сами данные не меняются, поэтому работает быстро.

Итого: блокировки на строки для чтений не устанавливаются никогда (ни для чтение-чтение, ни для чтение-запись). Блокировки устанавливаются только на запись-запись. Блокировки могут устанавливаться на таблицы: запрет удаления пока идет чтение, запрет чтения при перестроении таблицы.

Можно это увидеть через запросы:

    SELECT *, xmin, xmax FROM t;

Также можно посмотреть текущую транзакцию:

    BEGIN;
    SELECT txid_current();


#### 4.1.2 Очистка

Получается, что в таблице хранится несколько версий строки. Это ведет к разрастанию таблиц со временем, хотя среди этих версий будут версии больше не нужные.

Периодически запускается процесс очистки (vacuum). 

Два варианта:

* **частичная очистка** - помечает ненужные версии, фактически они остаются в файле, но на их место можно записывать новые строки. Этот процесс работает параллельно с основным процессом сервера. Но размер БД не уменьшается.
* **полная очистка** - перестраивает файл БД, удаляя ненужные строки и уменьшая размер. Но при этом блокирует таблицу.

Есть процесс `autovacuum launcher`:

* отслеживает работу с таблица и решает когда нужна очистка
* запускает дочерние процессы по очистке




### 4.2 Уровни изоляции

**Read uncommitted** - разрешает чтение незафиксированных транзакций. PostgreSQL не поддерживает.

**Read committed** - снимок строится на момент начала оператора. Поэтому одинаковые запросы внутри транзакции могут давать разные результаты. Это режим по умолчанию.

**Repeatable read** - снимок строится на момент первого оператора транзакции.

**Serializable** - полная изоляция. Как будто транзакции выполняются последовательно.



### 4.3 Буферный кеш и журналирование

#### 4.3.1 Буферный кеш

Буферный кеш: для согласования скорости работы оперативной памяти и дисков. Кеш состоит из массива буферов, содержащих страницы данных. Размер страницы задается при сборке PostgreSQL (8 кб обычно).

Любой запрос данных - сначала обращение к буферному кешу. Если нет в кеше, тогда обращение к ОС для чтения с диска (ОС свои кеши имеет).

На буферный кеш также устанавливаются блокировки при совместном доступе.

Если кеш заполнен, страницы нужно **вытеснять** из буфера и тогда можно заменять новыми. Если страница изменялась (**грязный буфер**), её нужно записать на диск. В первую очередь вытесняются страницы, которые дольше других не использовались.

#### 4.3.2 Журнал предварительной записи

Буферный кеш улучшает производительность, но возникает проблема потери кеша при сбоях. Для решения - журналирование: записи об операциях, позволяющие выполнить операции повторно при необходимости.

Записи об операциях создаются сразу на диск до выполнения самой операции - поэтому **журнал предварительной записи** (WAL). Располагается в `PGDATA/pg_wal`

Под журналирование попадают таблицы, индексы, состояние транзакций (xact), не попадают - временные и нежурналируемые таблицы (при сбоях данные в таких таблицах не восстанавливаются).

Обычно запись в журнал быстрее выполняется чем запись страниц в файл данных: запись в журнал это последовательная запись, а не произвольная. Справляются обычные HDD.

Два режима журналирования:

* **Синхронный**: запись в журнал выполняется сразу явно на диск (не в буфер ОС). При этом транзакция будет ждать окончания записи, это не быстрая операция.
* **Асинхронный**: на диск записи журнала переносятся отдельным фоновым заданием `walwriter`. Производительность повышается, но есть риск потерять записи журнала, хотя согласованность данных все равно обеспечивается.

Настраивается свойством `synchronous_commit`

Журнал можно применять и для других целей. Зависит от уровня ведения:

* **Minimal** - гарантия восстановления после сбоя
* **Replica** - значение по умолчанию, резервное копирование и репликация
* **Logical** - логическая репликация

Просмотр текущего объема журнала (вернет указатель на текущую запись в байтах, можно вычесть два указателя, чтобы получить изменение размера):

    SELECT pg_current_wal_lsn() AS pos1 \gset
    ...
    SELECT pg_current_wal_lsn() AS pos2 \gset
    SELECT :'pos2'::pg_lsn - :'pos1'::pg_lsn;

Посмотреть содержимое каталога PGDATA/pg_wal (это файлы по 16 МБ):

     SELECT * FROM pg_ls_waldir() ORDER BY name;

#### 4.3.3 Контрольные точки

Если произошел сбой, сервер после запуска начинает восстановление. Читаются и последовательно выполняются записи журнала, которые не попали на диск. 

Чтобы не просматривать весь журнал, формируются **контрольные точки**: в процессе работы сбрасываются все грязные буферы. Т. е. гарантируется, что до контрольной точки все изменения есть на диске.

Процесс создания контрольной точки может занимать длительное время: 50% - 90% времени между контрольными точками. Это нормально: не сильно влияет на производительность.

#### 4.3.4 Процессы, обслуживающие буферный кеш и журнал

**walwriter** - выполняет асинхронную запись журнала на диск. При синхронной записи это делает процесс, обслуживающий транзакцию

**checkpointer** - создает контрольные точки, сбрасывая грязные буферы на диск

**bgwriter** - фоновый процесс, также сбрасывает грязные буферы, которые с большой вероятностью будут вытеснены вскоре. Освобождает основные процессы от этой работы.

**обслуживающие процессы**, вытесняющие оставшиеся грязные буферы

Посмотреть дочерние процессы главного процесса:

    ps -o pid,command --ppid `head -n 1 $PGDATA/postmaster.pid`




## 5. Организация данных

### 5.1 Базы данных и схемы

#### 5.1.1 Шаблонные базы данных

##### 5.1.1.1 Зачем нужны

При инициализации кластера (команда `initdb`) создаются три одинаковые базы данных.

* **postgres** - используется при подключении по умолчанию пользователем postgres. Особо не нужна, но удалять не рекомендуется (наличии подразумевается некоторыми утилитами)
* **template1** - шаблон для создания любой новой базы. В эту базу можно добавлять объекты и расширения, они будут попадать в любую новую базу
*  **template0** - никогда не должна меняться. Используется для восстановления из архива утилитой pg_dump. Также при создании новой БД с кодировкой отличной от кодировки кластера.

Так например полный синтаксис создания БД (по факту копирование происходит):

    CREATE DATABASE <name> TEMPLATE <template_name>;

По умолчанию в качестве шаблона - **tempalte1**

Можно создать собственный шаблон (см. [здесь](https://postgrespro.ru/docs/postgresql/10/manage-ag-templatedbs.html))

##### 5.1.1.2 Разные команды 

    # просмотр списка баз:
    psql -l

    # подключение к БД:
    \с имя_бд

    # просмотр баз данных изнутри БД через представление pg_database
    # имя, шаблон или нет, разрешено подключение, лимит подключений
    SELECT datname, datistemplate, datallowconn, datconnlimit FROM pg_database;

    # создание БД (поключен к другой)
    CREATE DATABASE db; # можно выбрать шаблон явно

    # удаление (подключен должен быть к другой)
    DROP DATABASE db;

    # переименование (подключен к другой)
    ALTER DATABASE db RENAME TO db1;

    # просмотр размера БД
    SELECT pg_database_size('appdb');
    SELECT pg_size_pretty(pg_database_size('appdb'));

#### 5.1.2 Схемы

##### 5.1.2.1 Для чего нужны

Схемы - это пространство имен для объектов БД. Используется для разделения объектов на логические группы, избежания конфликтов имен. Каждый объект внутри БД принадлежит какой-то схеме. Если явно не указано - есть схема по умолчанию с именем `public`. Ничем особенным не отличается: просто есть по умолчанию и включается по умолчанию в путь поиска.

[подробнее](https://postgrespro.ru/docs/postgresql/10/ddl-schemas.html)

В общем такая иерархия: кластер содержит базы данных, базы данных содержат схемы, внутри схем расположены объекты. Клиент подключается одновременно только к одной БД, но внутри может работать с объектами любых схем.

К объектам можно обращаться по полному квалифицированному имени `схема.имя_объекта`. Такое имя однозначно идентифицирует объект. 

##### 5.1.2.2 Путь поиска

Если имя схемы не указано объект будет определятся с использованием **пути поиска (search_path)**. Это обычный конфигурационный параметр. Содержит перечень схем, по которым выполняется поиск по порядку. В пути могут находиться несуществующие схемы или те, на которые у пользователя нет прав. Такие исключаются из просмотра.

Значение по умолчанию: `$user, public`. `$user` - схема с именем текущего пользователя, пока ее явно не создали, отсутствует.

Неявно включаются:

* схема `pg_temp_nnn` - схема временных таблиц на время сеанса или транзакции
* `pg_catalog` - служебные объекты

Если эти схемы явно не указаны, тогда будут на первом месте, если явно указали - тогда там, где заявлены.

##### 5.1.2.3 Команды, функции работы со схемами

    CREATE SCHEMA имя_схемы;

    DROP SCHEMA имя_схемы;

    # удаление не пустой схемы:
    DROP SCHEMA имя_схемы CASCADE;

Любые операции над таблицами можно с указанием схемы:

    CREATE TABLE myschema.mytable (...);

Изменение схемы: 

    ALTER TABLE t SET SCHEMA new_schema;

Просмотр списка схем:

    \dn # от data namespace

Просмотр пути поиска:

    SHOW search_path;

Просмотр "эффективного" пути поиска:

    SELECT current_schemas(true);

Таблицы и их схемы:

    \dt # 

Установка пути поиска:

    # на время сеанса
    SET search_path = ...;
    # можно через файлы psqlrc, но это будет действовать для всего кластера
    
    # лучше устанавливать для БД
    ALTER DATABASE имя SET search_path = ..; 



### 5.2 Системный каталог

**Системный каталог** - набор таблиц/представлений с описанием объектов БД и кластера.

Расположен в схеме `pg_catalog`. Альтернативный вариант - `information_schema`.

В каждой БД создается свой набор системных таблиц. Часть этих таблиц будет общими для всех баз кластера. Например `pg_database`.

Правила наименования: 
    
    pg_<имя таблицы>.<префикс из 3-х символов><имя колонки>

Например: pg_database.datname

Содержимое хранится в нижнем регистре.

Таблицы системного каталога в качестве первичного ключа используют особый тип **OID**. Это целочисленный тип с автоинкрементом. Поэтому легко можно переименовывать сущности БД, т. к. имя - просто атрибут.

Для некоторых таблиц есть специальные представления/функции для преобразования OID в текстовое представление (имя сущности) и обратно. Это **Reg-типы**.

В общем случае к данным системного каталога можно обращаться через SQL команды или команды psql (обычно с `d` начинаются, с суффиксом `S` - системные)

    # все системные объекты
    \dS
    # базы данных
    SELECT * FROM pg_database;
    # схемы
    SELECT * FROM pg_namespace;
    # здесь например колонка nspowner - OID пользователя


Важная таблица **pg_class**: содержит описание разных объектов (таблиц, представлений, индексов и др.), описываемых термином *отношения* (*relations*). Колонка `relkind` уточняет этот тип.

Для отдельных типов есть более удобные представления:

    SELECT * FROM pg_tables;
    SELECT * FROM pg_views;

Есть аналогичные команды:

    \dt
    \dv
    # модификатор + дает больше информации
    \dt+
    # для конкретного объекта по имени
    \d mytable

Для изучения структуры системного каталога можно включить вывод запросов, выполняющихся при использовании команд:

    \set ECHO_HIDDEN on
    \dt

Пример преобразования OID:

    SELECT a.attname, a.atttypid FROM pg_attribute a
        WHERE a.attrelid = 'employees'::regclass AND a.attnum > 0;




### 5.3 Табличные пространства

#### 5.3.1 Основы

**Табличные пространства** определяют физическое расположение данных в файловой системе. Например одно ТП на медленных дисках для редко используемых данных, другое - на быстрых.

При инициализации кластера создаются 2 ТП:

* **pg_default** - пространство по умолчанию, где создаются объекты, если не указано явно
* **pg_global** - для хранения объектов системного каталога, общих для кластера

В одном ТП может быть несколько баз данных. Одна БД может хранить данные в нескольких ТП.

По сути ТП это указатель на каталог файловой системы: 

* `pg_global` - `$PGDATA/global/`
* `pg_default` - `$PGDATA/base/`

При создании своего ТП, указываем каталог явно. Допонительно PostgreSQL создает симлинки в `$PGDATA/pg_tblspc/`

Внутри `$PGDATA/base/` еще деление по БД. Если создается пользовательское ТП, внутри автоматически создаются директории под версию сервера (для переносимости)

Внутри каталогов хранятся объекты: каждый объект в своем файле.

#### 5.3.2 Команды для работы с ТП

Просмотр:
    
    # покажет размер и расположение (для стандартных - пустое)
    \db+

    SELECT * FROM pg_tablespace;

    # где таблицы находятся
    SELECT tablename, tablespace FROM pg_tables;

Работа с ТП:

    # создаем новое
    # нужен пустой каталог, владелец - пользователь postgres
    CREATE TABLESPACE new_ts LOCATION '/home/postgres/new_ts_dir';

    # создаем базу в новом ТП
    # тогда все таблицы этой БД по умолчанию будут в этом ТП
    CREATE DATABASE db TABLESPACE new_ts;

    # но можно явно задавать
    CREATE TABLE t() TABLESPACE pg_default;

Можно перемещать между ТП, при этом копирование файлов происходит и объект блокируется на время перемещения.

    ALTER TABLE t1 SET TABLESPACE pg_default;
    # или все объекты
    ALTER TABLE ALL IN TABLESPACE pg_default SET TABLESPACE ts;

    # можно для всей БД (находясь в другой)
    ALTER DATABASE db SET TABLESPACE pg_default;

Просмотр размера:

    SELECT pg_size_pretty( pg_tablespace_size('ts') );

Удалять можно только пустые ТП. Как с БД использовать `CASCADE` нельзя, т. к. несколько баз может использовать, а подключены только к одной
    
    DROP TABLESPACE ts;


### 5.4 Низкий уровень (структура файлов)

#### 5.4.1 Слои, сегменты

Каждому объекту БД (таблица, индекс и т. п.) соответствует несколько **слоев** (**forks**). Каждому слою соответствует файл. Если файл вырастает больше 1 ГБ, создается следующий файл слоя. Такие файлы - **сегменты**.

Имена файлов состоят из OID объекта, префикса слоя и номера сегмента. Например `13131_fsm.1` - сегмент 1 слоя fsm объекта с OID = 13131.

Таким образом одной таблице будет соответствовать минимум 3 файла, индексу - 2. Все они будут расположены в одном каталоге (если в одном пространстве). Т. к. файловые системы могут не очень работать с большим количеством файлов в одном каталоге, есть возможность оптимизации (разноска по пространствам ??).

Файлы делятся на страницы / блоки размером что и страницы буферного кеша (8 КБ  обычно). Собственно эти страницы файлов и попадают в буферный кеш.

Виды слоев:

* **основной** - собственно данные
    - например версии строк таблицы, строки индексов
    - существует у всех объктов
    - имена без префикса
* **слой инициализации** - есть у нежурналируемых объектов, например временных таблиц
    - используется для замены основного слоя при сбое
    - префикс `_init`
* **free space map (карта свободного пространства)**
    - показывает свободные строки, возникающие после очистки
    - для ускорения процесса вставки новых строк
    - появится только после очистки `VACUUM`
    - префикс `_fsm`
* **visibility map (карта видимости)**
    - отмечает страницы, в которых только актуальные версии строк
    - для оптимизации очистки и поиска
    - есть только для таблиц
    - префикс `_vm`

#### 5.4.2 Хранение длинных строк и таблицы TOAST

Любая версия строки (файл, собственно строка, большое число) должна помещаться на страницу файла.

Для длинных строк применяются разные стратегии: попытается сжать и/или вынесет в отдельную **TOAST-таблицу**. Такие таблицы расположены в пространстве `pg_toast` или `pg_toast_temp_N` для временных. По умолчанию не видны, но можно посмотреть:

    SELECT chunk_id, chunk_seq, length(chunk_data) FROM pg_toast.pg_toast_16428`);

Для таблиц TOAST также правило строка на файл, поэтому может разбивать на части. Версионность для таких таблиц своя, поэтому несколько версий строки основного файла могут ссылаться на одну строку таблицы TOAST.

#### Команды для работы с файлами, слоями, TOAST

Базовый каталог объекта можно получить по его имени:
    
    SELECT pg_relation_filepath('my_table');
        => base/16499/16502

Или получить OID объекта:
    
    SELECT OID FROM pg_database WHERE datname = 'my_table';

Также можно использовать утилиту `oid2name` (входит в стандартную установку)

Размеры объектов:

    # по слоям:
    SELECT pg_relation_size('t','main') main, pg_relation_size('t','fsm') fsm;
    
    # таблица без индексов
    SELECT pg_table_size('t');
    
    # индекс таблицы
    SELECT pg_indexes_size('t');
    
    # размер всей таблицы
    SELECT pg_total_relation_size('t');

Работа с TOAST:

    # есть ли у таблицы соответствующая TOAST-таблица:
    # смотрим колокну в таблице pg_class
    SELECT reltoastrelid FROM pg_class WHERE relname='t'
    # можно дополнительно реквизиты самой таблицы TOAST
    SELECT * FROM pg_class WHERE oid = ..;

Стратегии работы с длинными строками можно посмотреть через `\d+ <имя таблицы>`, колонка `Storage`:

* **plain** - тип фиксированной длины, TOAST не используется
* **main** - приоритет сжатия
* **extended** - попытается сжать, если результата не увидит - отдельное хранение 
* **external** - сразу отдельное хранение

Можно поменять стратегию (начнет действовать для новых данных):

    ALTER TABLE t ALTER COLUMN n SET STORAGE extended;



## 6. Администрирование

### 6.1 Мониторинг

#### 6.1.1 Стандартные средства ОС

Стандартные стредства ОС:

* процессы:
    - `ps aux |grep ^postgres`
* ресурсы: iostat, vmstat, sar, top
* дисковое пространство: df, du, quota

#### 6.1.2 Внутренняя статистика

Внутренняя статистика PostgreSQL:

* собственно статистика, собираемая сервером и хранящаяся внутри
    - текущая активность процессов
    - разнообразная статистика, собираемая через **stats collector**
* логи

Просмотр текущей активности всех процессов: представление **pg_stat_activity** (autovacuum, client backend, walwriter и т. п.) и другие. Настройка: параметр `track_activities`, включена по умолчанию, отключать не следует. 

Аналогичная команда ОС:
    
    ps -o pid,command --ppid `head -n 1 $PGDATA/postmaster.pid`

Сбор статистики может выполняться фоновым процессом **stats collector**. Каждый обслуживающий процесс сервера собирает статистику о своей работе и передает её коллектору. Коллектор периодически (обычно раз в 0.5 сек) сбрасывает статистику во временные файлы в `$PGDATA/pg_stat_tmp` (можно в память перенести для повышения производительности). По запросу последняя версия статистики читается из этого каталога. При остановке сервера сбрасывается в каталог `$PGDATA/pg_stat`. Счетчики статистики обнуляются по команде или при восстановлении после сбоя.

Можно подключать расширения (входящие в поставку и внешние), позволяющие собирать дополнительную информацию: pg_stat_statements (по запросам), pg_stat_plans (по планам запросов) и др.

#### 6.1.3 Логи

Основной параметр - `log_destination`: список приемников сообщений (stderr, syslog, csvlog)

Дополнительно можно включить процесс - коллектор сообщений (параметр `logging_collector`). Этот коллектор будет записывать логи в файлы, определяемые параметрами `log_directory` и `log_filename`. Можно ротацию настраивать. Особенность коллектора - гарантирует запись сообщения (в отличие от syslog), поэтому при нагрузке процессы могут ждать ответа от коллектора -> снижение производительности.

По умолчанию минимально настроен вывод логов. Можно включать (разные варианты: для БД, для кластера, на время сеанса):

* `log_min_messages` - уровень логгирования
* `log_min_duration_statement` - команды, выполнявшиеся больше заданного времени
* `log_duration` - время выполнения команд
* `log_statement` - сами команды
* и др.

Анализ логов: 

* средства ОС: grep, awk, cat, tail и т. п.
* внешние утилиты, например **pgBadger** (требует настройки логов)

#### 6.1.4 Примеры работы статистики

Имитация работы: утилита `pgbench`:

    # создаем тестовую базу
    CREATE DATABASE testdb;
    # инициализируем утилиту (создает таблицы)
    \q
    pgbench -i testdb

    # сброс статистики
    SELECT pg_stat_reset(); # это сброс на уровне базы данных
    SELECT pg_stat_reset_shared('bgwriter'); # это на уровне кластера

    # запуск теста
    pgbench -T 10 testdb 
    # в выводе tps - число транзакций в секунду

**Статистика обращения к таблицам (`pg_stat_all_tables`)**
    
    SELECT * FROM pg_stat_all_tables WHERE schemaname = 'public' \gx
        relid               | 16398
        schemaname          | public
        relid               | 16398
        schemaname          | public
        relname             | pgbench_history
        seq_scan            | 0
        seq_tup_read        | 0
        idx_scan            | 
        idx_tup_fetch       | 
        n_tup_ins           | 7697
        n_tup_upd           | 0
        n_tup_del           | 0
        n_tup_hot_upd       | 0
        n_live_tup          | 7697
        n_dead_tup          | 0
        n_mod_since_analyze | 0
        last_vacuum         | 2021-08-19 10:47:04.814125+03
        last_autovacuum     | 
        last_analyze        | 2021-08-19 10:47:04.814536+03
        last_autoanalyze    | 2021-08-19 10:55:51.677843+03
        vacuum_count        | 1
        autovacuum_count    | 0
        analyze_count       | 1
        autoanalyze_count   | 2
   
Покажет: 

* количество вставок, удалений, апдейтов
* количество последовательный чтений таблицы (без использования индекса) `seq_scan`
* количество чтений с использованием индекса `idx_scan`
* количество операций очистки и время последних

**Статистика в терминах страниц буферного кеша (`pg_statio_all_tables `)**

    SELECT * FROM pg_statio_all_tables WHERE schemaname = 'public' \gx
        relid           | 16404
        schemaname      | public
        relname         | pgbench_accounts
        heap_blks_read  | 1671
        heap_blks_hit   | 38086
        idx_blks_read   | 276
        idx_blks_hit    | 34293
        toast_blks_read | 
        toast_blks_hit  | 
        tidx_blks_read  | 
        tidx_blks_hit   | 

Показывает сколько страниц пришлось считать с диска (`..._read`),  а сколько оказалось в кеше (`..._hit`)  

Аналогичная статистика есть конкретно по индексам `pg_stat_all_indexes` и `pg_statio_all_indexes`

**Сводная статистика по БД**

    SELECT * FROM pg_stat_database WHERE datname='testdb' \gx
        datid          | 16397
        datname        | testdb
        numbackends    | 1
        xact_commit    | 7890
        xact_rollback  | 1
        blks_read      | 2334
        blks_hit       | 121880
        tup_returned   | 364146
        tup_fetched    | 19929
        tup_inserted   | 107808
        tup_updated    | 23117
        tup_deleted    | 0
        conflicts      | 0
        temp_files     | 0
        temp_bytes     | 0
        deadlocks      | 0
        blk_read_time  | 0
        blk_write_time | 0
        stats_reset    | 2021-08-19 10:45:36.957315+03

Здесь есть данные по транзакциям и блокировкам.

**Статистика по процессам фоновой записи и контрольных точек**

    # SELECT * FROM pg_stat_bgwriter \gx
        checkpoints_timed     | 179
        checkpoints_req       | 4
        checkpoint_write_time | 307801
        checkpoint_sync_time  | 11
        buffers_checkpoint    | 3814
        buffers_clean         | 0
        maxwritten_clean      | 0
        buffers_backend       | 1753
        buffers_backend_fsync | 0
        buffers_alloc         | 3519
        stats_reset           | 2021-08-17 09:39:49.806519+03

`buffers_clean` - количество страниц, записанных фоновой записью;
`buffers_checkpoint` - количество страниц, записанных контрольной точкой;
`buffers_backend` - количество страниц, записанных серверными процессами.

**Текущие активности и блокировки**

Например есть активная транзакция, другой процесс те же данные пытается изменить и попадает на блокировку.

    SELECT pid, query, state, wait_event, wait_event_type
        , pg_blocking_pids(pid) 
    FROM pg_stat_activity WHERE backend_type = 'client backend' \gx
        pid              | 30562
        query            | UPDATE t SET n = n + 1;
        state            | idle in transaction
        wait_event       | ClientRead
        wait_event_type  | Client
        pg_blocking_pids | {}
        -----------------------------------
        pid              | 30614
        query            | UPDATE t SET n = n + 2;
        state            | active
        wait_event       | transactionid
        wait_event_type  | Lock
        pg_blocking_pids | {30562}

Здесь выбираем все клиентские запросы, смотрим из состояние. Функция `pg_blocking_pids` показывает процессы, которые заблокировали указанный.

Завершить клиентский процесс можно функциями `pg_cancel_backend(pid)`  и `pg_terminate_backend(pid)`. Завершать через `kill -9` не стоит, т. к. эти процессы порождает главный серверный процесс и он следит за их состоянием. Внешнее завершение может посчитать нарушением работоспособности.














### 6.2 Сопровождение

#### 6.2.1 Процедуры очистки (vacuum, autovacuum, полная очистка)

Варианты запуска **vacuum**:

* `VACUUM <имя таблицы>` - очистка таблицы
* `VACUUM` - очистка всей БД
* `$ vacuumdb` - консольная утилита

Работает параллельно с другими транзакциями. Не минимизирует место, занимаемое объектами, не уменьшает размер файлов, просто помечает строки как свободные.

Частый запуск может сказаться на производительности системы, редкий ведет к росту файлов.

Ещё есть фоновый процесс **autovacuum launcher**. Мониторит активность работы с таблицами и при необходимости запускает дочерние процессы **autovacuum worker**, которые выполняют очистку.

Третий вариант - **полная очистка**:

* `VACUUM FULL <имя таблицы>`
* `VACUUM FULL` - вся БД
* `$ vacuumdb --full`
* `TRUNCATE` - похожим образом работает

Блокирует таблицу и индексы полностью, освобождая место. SQL команда `TRUNCATE` подобным образом работает, в отличие от `DELETE`, которая только помечает объекты.

#### 6.2.2 Обновление статистики

Обычно обновлением статистики занимается процесс **autovacuum**. При необходимости можно явно запустить:

* `ANALYZE <таблица>`
* `$ vacuumdb --analyze-only`
* `VACUUM ANALYZE <таблица>` - очистка + обновление статистики
* `$ vacuumdb --analyze` 

При обновлении статистики читается случайная выборка данных определенного размера. Размер можно настраивать

#### 6.2.3 Заморозка номеров транзакций

Счетчик транзакций, используемый в версиях строк, 32-битный. Возможно переполнение. 

Для освобождения номеров процесс автоочисти помечает очень старые транзакции как замороженные и их номера могут присваиваться новым транзакциям. Т. е. пространство номером закольцовано и периодически из него освобождаются номера для повторного использования. 

Сервер может остановить свою работу, если обнаружит сбои в работе механизма заморозки. Придется стартовать заново и выполнять очистку.

#### 6.2.4 Мониторинг индексов

Индексы - сложные структуры, могут сильно расти в размерах.

Выявление проблем:

* `pg_stat_all_ indexes.idx_scan` - не используемые
* `pg_relation_size()` - разрастание
* расширение `pgstattuple`

Перестроение индексов:

* `REINDEX <индекс/таблица/схема/..>` - перестраивает индекс, блокирует таблицу
* `VACUUM FULL` - вместе с очисткой выполняет перестроение

Можно попытаться создать индекс в неблокирующем режиме:

    # создаем индекс параллельно с работой, может из-за блокировок неудачно
    CREATE INDEX <имя> ON .. CONCURRENTLY;
    # удаляем старый 
    DROP INDEX <имя> CONCURRENTLY;






#### 6.2.5 Оценка разрастания таблиц и индексов

Через расширение **pgstattuple**

     CREATE EXTENSION pgstattuple;

    # создаем таблицу
    CREATE TABLE t(id serial, s text);
    # разные манипуляции ...

    SELECT * FROM pgstattuple('t') \gx
        table_len          | 4423680
        tuple_count        | 100000
        tuple_len          | 3388895
        tuple_percent      | 76.61
        dead_tuple_count   | 0
        dead_tuple_len     | 0
        dead_tuple_percent | 0
        free_space         | 16552
        free_percent       | 0.37 

Вот пример после вставки одной строки в пустую таблицу:

    table_len          | 8192       # это размер по умолчанию (1 страница 8 КБ)
    tuple_count        | 1
    tuple_len          | 28
    tuple_percent      | 0.34       # процент, занятый данными
    dead_tuple_count   | 0
    dead_tuple_len     | 0
    dead_tuple_percent | 0
    free_space         | 8128
    free_percent       | 99.22

Вот после удаления строки:

    table_len          | 8192
    tuple_count        | 0
    tuple_len          | 0
    tuple_percent      | 0
    dead_tuple_count   | 1           # освободится после очистки
    dead_tuple_len     | 28
    dead_tuple_percent | 0.34
    free_space         | 8128
    free_percent       | 99.22






## 7. Управление доступом

### 7.1 Роли и их атрибуты 

#### 7.1.1 Роли

Роль это пользователь СУБД. Но в тоже время может быть групповой ролью (включать в себя другие роли). 

Не связана с пользователями ОС.

Привязаны к кластеру. Одна роль может быть владельцем объектов в разных базах. При создании кластера создается одна роль-суперпользователь. Есть псевдороль **public**, в которую неявно включаются все другие роли.

#### 7.1.2 Атрибуты ролей

Атрибуты роли определяют полномочия:

* **LOGIN** - имеет право подключения к БД, т. е. пользователь
* **SUPERUSER** - нет проверок на права доступа, право входа в систему проверяется все равно
* **CREATEDB** - право создания баз данных
* **CREATEROLE** - право создания ролей 

Обычно есть противоположные атрибуты: `NOLOGIN` и т. п.

Управление аттрибутами:

    CREATE ROLE имя [аттрибуты];
    ALTER ROLE имя ...

Для обычной работы можно создать пользователя с `CREATEDB` и `CREATEROLE`, чтобы избежать использования роли суперпользователя.

#### 7.1.3 Групповые роли

Для упрощения управления правами: права действуют на всех участников группы.

    CREATE ROLE group_role;
    # включаем в эту группу роли:
    GRANT group_role TO роль1, ...;
    # исключаем
    REVOKE group_role FROM роль1;

При включении можно дать право управления групповой ролью (право включать/исключать другие роли):
    
    GRANT группа TO роль2 WITH ADMIN OPTION;
    # отзыв этого права:
    REVOKE ADMIN OPTION FOR группа FROM роль2;

Членом группы может быть другая группа. Между групповой и негрупповой ролью принципиальных различий нет.

Право включать и исключать роли в/из групповой роли имеют:

* сама групповая роль
* роль с атрибутом `SUPERUSER`
* роль с атрибутом `CREATEROLE` (кроме включения в суперпользовательскую группу)

Как роль может использовать права групповой роли:

* явно переключившись на групповую роль `SET ROLE`, членом которой является роль (при этом при создании объектов владельцем будет групповая)
* если у роли установлен атрибут **INHERIT** (по умолчанию), она автоматически наследует права групповых (в т. ч. по иерархии наследования)


#### 7.1.4 Примеры работы с ролями

**Создание**:

    # создаем роль с возможностью логина и создания других ролей
    CREATE ROLE alice LOGIN CREATEROLE;

    # заходим под новым пользователем
    \c - alice

    # может создавать другие роли
    CREATE ROLE bob;

**Просмотр списка ролей**:

    \du
    # или
    SELECT * FROM pg_user;

**Установка настроек для пользователя**:

Срабатывают при начале сеанса

    # логгируем все действия пользователя
    ALTER ROLE alice SET log_min_duration_statement=0;

    # или только для конкретной БД
    ALTER ROLE alice IN DATABASE postgres SET log_min_duration_statement=0;

**Переключение между ролями**:
    
    # переключение на суперпользователя  
    \c - postgres
    
    # включение в группу
    GRANT postgres TO alice;
    
    # переключение на пользователя
    \с - alice
    # переключение на роль
    SET ROLE postgres;
    # сброс
    RESET ROLE;

    # просмотр текущей роли: кто начал сессию и под какой ролью сейчас
    SELECT session_user, current_user;
        session_user | current_user 
        --------------+--------------
        alice        | postgres

**Удаление ролей**:
    
Удалить можно, если нет объектов во владении

    DROP ROLE alice;

Можно передать другой роли все объекты (но могут быть в другой БД)
    
    REASSIGN OWNED BY alice TO bob;



### 7.2 Привилегии

#### 7.2.1 Механизм привилегий

Определяют права доступа ролей к объектам. Различаются для разных объектов.

Привелегии для таблиц:

* `SELECT`, `INSERT`, `UPDATE` - право на чтение, вставку, изменение (можно для столбцов отдельных)
* `DELETE` - удаление строк
* `TRUNCATE` - очистка таблицы
* `TRIGGER` - создание триггеров

Для табличных пространств:

* `CREATE` - право на создание в этом ТП

Для БД:

* `CREATE` - право создавать объекты
* `CONNECT` - право подключения

Роли с точки зрения привилегий:

* Суперпользователи - полный доступ, никакие проверки не выполняются
* Владельцы объектов - выполняется проверка привилегий
    - изначально получают полный набор привилегий
    - плюс права на выдачу/отмену привилегий (в т. ч. у себя)
* Остальные - доступ только по выданным привилегиям

#### 7.2.2 Управление привилегиями


