<!-- MarkdownTOC autolink="true" uri_encoding="false" levels="2,3" -->

- [1. Установка и настройка](#1-Установка-и-настройка)
    - [1.1 Установка сервера](#11-Установка-сервера)
    - [1.2 Настройка переменных окружения](#12-Настройка-переменных-окружения)
    - [1.3 Начало работы](#13-Начало-работы)
    - [1.3.4 Команда pg_ctlcluster](#134-Команда-pg_ctlcluster)
    - [1.3.5 Где мои логи, чувак?](#135-Где-мои-логи-чувак)
- [2. Утилита psql](#2-Утилита-psql)
    - [2.1 Подключение к серверу](#21-Подключение-к-серверу)
    - [2.2 Основные команды](#22-Основные-команды)
    - [2.3 Выполнение скриптов при запуске](#23-Выполнение-скриптов-при-запуске)
    - [2.4 Форматирование вывода](#24-Форматирование-вывода)
    - [2.5 Разное](#25-Разное)
    - [2.6 Переменные psql и переменные окружения](#26-Переменные-psql-и-переменные-окружения)
- [3. Конфигурация](#3-Конфигурация)
    - [3.2 Файл postgresql.conf](#32-Файл-postgresqlconf)
    - [3.3 Файл postgresql.auto.conf](#33-Файл-postgresqlautoconf)
    - [3.4 Представление pg_file_settings](#34-Представление-pg_file_settings)
    - [3.5 Представление pg_settings](#35-Представление-pg_settings)
    - [3.6 Пользовательские параметры](#36-Пользовательские-параметры)
- [4. Архитектура](#4-Архитектура)
    - [4.1 Многоверсионность](#41-Многоверсионность)
    - [4.2 Уровни изоляции](#42-Уровни-изоляции)
    - [4.3 Буферный кеш и журналирование](#43-Буферный-кеш-и-журналирование)
- [5. Организация данных](#5-Организация-данных)
    - [5.1 Базы данных и схемы](#51-Базы-данных-и-схемы)
    - [5.2 Системный каталог](#52-Системный-каталог)
    - [5.3 Табличные пространства](#53-Табличные-пространства)
    - [5.4 Низкий уровень \(структура файлов\)](#54-Низкий-уровень-структура-файлов)

<!-- /MarkdownTOC -->


## 1. Установка и настройка

### 1.1 Установка сервера

[Инструкция с оф. сайта](https://www.postgresql.org/download/linux/ubuntu/)

    # Настраиваем репозиторий для apt-get
    sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
    
    # получаеи ключ для репозитория
    wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
    
    # собственно установка
    # здесь явно версия 10 указано, можно без указания, тогда актуальную 
    sudo apt-get update
    sudo apt-get -y install postgresql-10

Процесс установки:

* устанавливает в `/usr/lib/postgresql/` и утилиты в `/usr/bin/`
* создает пользователя `postgres` и группу `postgres`
* создает конфигурационные файлы в `/etc/postgresql/` и в `/etc/postgresql-common/` (напр. в `postgresql.conf` задана директория для БД)
* создает кластер БД в директории БД `var/lib/postgresql/10/main`, владелец - группа `postgres` через комманду `initdb`
* логи выводятся в `/var/log/postgresql/postgresql-10-main.log`
* также запускает сервер

### 1.2 Настройка переменных окружения

Все переменные не обязательны, просто для удобства

Добавить в `PATH` каталог с установленным PostgreSQL

**Вариант 1** (для конкретного пользователя):

    # зависит от оболочки, для bash
    # в файл ~/bashrc
    export PATH=$PATH:/usr/lib/postgresql/10/bin

**Вариант 2**

Через каталог `/etc/profile.d`: добавить туда скрипт с раcширением `.sh`

Это будет работать для всех пользователей, но только если они явно логинятся в систему (через `sudo su postgres` не буден работать) (см. login shell / non-login shell по ссылке ниже)

    sudo nano /etc/profile.d
        => PATH=$PATH:/usr/lib/postgresql/10/bin
    # сохранить

**Вариант 3**

Еще вариант - редактирование `/etc/environment`

[Подробно про переменные](https://stackoverflow.com/questions/14637979/how-to-permanently-set-path-on-linux-unix)

Можно создать переменную PGDATA (путь к директории БД (напр. `var/lib/postgresql/10/main`) )


### 1.3 Начало работы

#### 1.3.1 Пользователи ОС для сервера Postgres

Лучше использовать созданного в процессе установки пользователя `postgres` с одноименной группой. У него уже настроены необходимые разрешения.

Можно создать еще пользователя (зачем?): 

* `sudo adduser new_user`
* включить его в группу 134 ssl-cert (так у стандартного)
* дать новому пользователю права на `/var/run/postgresql` (через включение его в группу `postgres` ??)

#### 1.3.2 **Создание кластера БД**

Кластер - группа баз данных, управляемых одним экземпляром сервера Postgres

Для создания кластера необходимо:

* создать директорию для кластера БД, назначить владельцем пользователя `postgres`
    - `mkdir /var/lib/postgresql/10/testcluster`
    - `sudo chown postgres /var/lib/postgresql/10/testcluster`
    - `ls -l` покажет владельцев
* инициализировать кластер БД (от имени пользователя)
    - `sudo su postgres`
    - `initdb -k -D  /var/lib/postgresql/10/testcluster`
    - здесь `-k` включает подсчет контрольной суммы страниц (для обнаружения повреждений БД (влияет на производительность))
* вывод результата инициализации должен показать команду для запуска сервера

#### 1.3.3 Запуск / остановка

Если была стандартная установка сервер уже запущен.

Способы запуска:

* **pg_ctl** - низкоуровневая
    - `pg_ctl -D <каталог кластера> start`
* **pg_ctlcluster** - обертка над **pg ctl**, запускает по имени кластера
    - `pg_ctlcluster <версия кластера> <имя> start`

Кластера создаются по разному. При установке например, настройки хранятся в `/etc/postgresql/10/main` (в т. ч. конфигурационный файл). При создании кластера через `initdb -k -D ...` все настройки хранятся в том же каталоге, что и данные. 

Если конфигурационный файл расположен внутри кластера, можно запустить через `pg_ctl -D ... start`.

Если конфигурационный файл отдельно расположен, нужно указывать путь к нему `pg_ctl -D /var/lib/postgresql/10/main -o "-c config_file=/etc/postgresql/10/main/postgresql.conf" start`. Здесь через `-o` параметры передаются в команду `postgres` 

### 1.3.4 Команда pg_ctlcluster

* обертка для **pg_ctl**
* запускает по имени кластера
* внутри проверяет версию кластера и т. п. и запускает подходящую команду `pg_ctl`
* логи по умолчанию пишутся в `/var/logs/postgresql-<версия>-<имя кластера>`
* команды: start, stop, reload, status
* можно передавать параметры в вызываемую **pg_ctl**
* настройки может сохранять в `/etc/postgresql/<версия>/<имя>` или в директории кластера, в т. ч. **postgresql.conf** 

### 1.3.5 Где мои логи, чувак?

Смотрим переменную `log_destination` (метод логгирования):

    SHOW log_destination;

Там несколько вариантов может быть:

* `stderr` - по умолчанию
* `csvlog` - в формате csv
* `syslog` - пересылка логов сервисом, много настроек куда и как.
* `eventlog` - только для Win

Если `stderr`, также скорее всего куда-то перенаправляются.

Например при запуске через `pg_ctl -D ... start` вывод идет в терминал. Можно указать файл при запуске `pg_ctl -D ... -l mylog`. 

Стоит проверить переменную `logging_collector`

    SHOW logging_collector;

Если включен, значит см. переменные `log_directory` (если относительный - в каталоге кластера), `log_filename`.

Если выключен, системное расположение используется:

    # определить PID процесса
    # так например текущего psql
    select pg_backend_pid();
        => 31314
    # можно через top корневого postgres
    # затем проверить симлинк
    \! ls -l /proc/31314/fd/2
        => /var/log/postgresql/...
    # или из обычного терминала
    ls -l ....


**TODO**:

Просмотр процессов в терминале (м. б. top ?)

Запуск по умолчанию: systemd??? отключить, управление????

## 2. Утилита psql

### 2.1 Подключение к серверу

 Это терминальный клиент для работы с сервером PostgreSQL.

    psql -d <имя БД в кластере> -U <роль> -h <узел> -p <порт> 
    # после этого переход в режим ввода

Можно пробовать подключаться без указания параметров, тогда имя БД и роль будут браться по имени текущего пользователя (поэтому от имени пользователя `postgres` надо):

    sudo su postgres 
    psql

### 2.2 Основные команды

Команды начинаются с `\`.

Основные команды:

* `\c` - подключение к новой БД
* `\conninfo` - информация о текущем подключении 
* `\?` - справка по командам psql
* `\h` - список команд SQL
* `\h <имя комманды>` - синтаксис конкретной команды
* `\q` - выход

### 2.3 Выполнение скриптов при запуске

Можно настроить скрипты, выполняемые при запуске `psql`. Для этого общесистемный файл `psqlrc` или пользовательский `~/.psqlrc`. 

Общесистемный файл расположен в каталоге с настройками. Посмотреть расположение этого каталога `pg_config --sysconfdir`

Например так из оболочки под пользователем `postgres`

    # отображение времени выполнения запроса
    echo "\timing on" >> ~/.psqlrc
  
    # просмотрщик для результатов запросов
    echo "\setenv PAGER 'less -X'" >> ~/.psqlrc
    # можно флаг N еще добавить для вывода строк или в процессе работы переключать через `-N`. См. `man less`

### 2.4 Форматирование вывода

Полный список атрибутов можно посмотреть:

    \pset

Есть краткие команды:

* `\a` - переключение режима с выравнивания и без
* `\t` - переключение режима с выводом заголовков, итоговой строки и без
* `\x` - переключение режима вывода колонок в строки / в колонки

### 2.5 Разное

Выполнение команд оболочки: через `\!`

    \! pwd
    \! uptime

Запись в файл:

    # переключили в режим вывода в файл
    \o some_file 
    # здесь любые команды, результат выводится в файл
    ....
    # переключаем обратно
    \o 
    # можно посмотреть файл
    \! cat some_file

Запуск команд из файла:

    \i some-file
    # или из оболочки
    psql <some-file
    psql -f some-file

### 2.6 Переменные psql и переменные окружения

Аналог переменных окружения.

Устанавливаются через `\set` / `\unset`. Просмотр через `\echo`, полный список через `\set`

В переменную можно записать результат запроса:

    # внимание на отсутствие ;
    select now() as cur_time \gset
    \echo cur_time

В переменные можно записать текст запроса и выполнять его через переменную:

    \set cur_time 'select now();'
    # запуск
    :cur_time
    # просмотр переменной
    \echo :cur_time

Приглашения ввода:

    \set PROMPT1 '%n@%/%R%# '
    \set PROMPT2 '%n@%/%R%# '

Можно записать это в файлы `psqlrc`, тогда будет доступ всегда при запуске.

Работа с системными переменными из psql:
    
    # установка
    \setenv PAGER 'less -XSN'
    # просмотр
    \! echo $PAGER



## 3. Конфигурация

Разные параметры конфигурации можно устанавливать:

* для всего сеанса сервера
* для отдельной БД 
* для пользователя
* во время работы клиентского сеанса

### 3.2 Файл postgresql.conf

Главный источник параметров - файл `postgresql.conf`. Может находится или в каталоге с данными, или отдельно (напр. `/etc/postgresql`)

Посмотреть расположение (в pqsl):
    
    # команда SQL
    SHOW config_file;
    # показать все параметры
    SHOW ALL;

При изменении в файле, нужно чтобы сервер перечитал этот файл. Есть разные способы:
    
    # 1. через утилиты pg_ctl / pg_ctlcluster
    $ pg_ctl reload
    # 2. послать сигнал главному процессу сервера postmaster
    $ kill -HUP
    # 3. через psql
    => SELECT pg_reload_conf();

Для некоторых параметров может требоваться перезагрузка

### 3.3 Файл postgresql.auto.conf

Предназначен для редактирования конфигурационных параметров посредством команд SQL. Доступ к файлу не нужен:

    # установка значения (добавляет строку в файл)
    ALTER SYSTEM SET <параметр> TO <значение>;
    # удаление параметр (строку файла)
    ALTER SYSTEM RESET <параметр>;
    # удаление всех параметров из файла
    ALTER SYSTEM RESET ALL;

Файл считывается после `postgresql.conf`, т. е. настройки `postgresql.auto.conf` имеют приоритет

Всегда расположен в каталоге кластера БД.

Напрямую редактировать не стоит.

Чтобы изменения вступили в силу, также нужно чтобы сервер перечитал конфигурацию

### 3.4 Представление pg_file_settings

Одно из системных представлений.

    SELECT * FROM pg_file_settings;

Показывает сводное содержимое файлов конфигурации. Показывает, что есть в файлах, а не то, что сервер использует в данный момент. Для просмотра состояния сервера см. **pg_settiings**.

Колонки:

* `sourcefile` - файл-источник параметра (напр. `postgresql.conf`)
* `sourceline` - строка в файле
* `applied` - true/false может ли это изменение быть применено успешно
* `error` - описание ошибки

Если конфигурационный файл содержит синтаксические ошибки, представление будет содержать одну или нескольно строк с описанием ошибки.

### 3.5 Представление pg_settings

Показывает действующие значения конфигурационных параметров

    SELECT * FROM pg_settings;

Колонки:

* `name`, `setting`, `unit` - имя параметра, значение и единица измерения
* `boot_val` - значение по умолчанию
* `reset_val` - если во время сеанса будет вызвана команда `ALTER SYSTEM RESET`
* `source` - источник значения параметра
* `pending_restart` - значение изменено (например через конфигурационный файл) и требуется перезагрузка сервера
* минимальное и максимальное значение параметра

Колонка **context** описавает как можно изменить значение параметра:

* **internal** - это внутренний параметр, изменить непосредственно нельзя (пересобрать сервер может быть)
* **postmaster** - для изменения требуется перезапуск сервера
* **sighub** - можно без перезапуска, перечитав конфигурацию (reload)
* **superuser** - можно изменять в файле конфигурации или в сеансе ( команда SQL `SET`), но только суперпользователю. Параметры установленные через `SET` имеют больший приоритет, чем в файле конфигурации
* **user** - аналогично, но любой пользователь




### 3.6 Пользовательские параметры

Можно создавать свои параметры теми же способами, что и предопределенные:

* редактирование файла `postgresql.conf`
* через SQL команду `ALTER SYSTEM SET`
* установка на время сеанса через команду `SET`
* установка в запросе через функцию `set_config()`

Главное правило: имя должно содержать `.`, чтобы не путать с системными параметрами.

    SELECT CASE WHEN current_setting('myapp.currency_code', true) IS NULL THEN
                set_config('myapp.currency_code', 'RUB', false)
            ELSE
                current_setting('myapp.currency_code')
            END;




## 4. Архитектура

### 4.1 Многоверсионность

#### 4.1.1 Суть многоверсионности

Введена для решения проблем при многопоточном доступе. Если несколько процессов одновременно хотят записать данные в одну строку, вынуждены ставить блокировку и процессы будут ждать. Если есть читающий и пишущий процесс тоже нужна блокировка, чтобы не нарушить консистентность, но это будет влиять на производительность.

Поэтому Postgres каждую строку таблицы БД хранит в нескольких версиях. Строка имеет отметку о начале действия и конце действия. В качестве меток выступают номера транзакций (они выдаются по нарастающей, поэтому могут играть роль отметок времени).

Так например INSERT создает строку с началом действия. UPDATE устанавливает конец действия и создает новую строку. DELETE устанавливает конец действия.

Чтение выполняется через **снимок данных**. Определяются еще активные транзакции и выбираются действующие версии строк. 

Для хранения информации о транзакциях используется специальный файл в каталоге данных (**pg_xact**). Также есть буфер в памяти. Два бита на каждую транзакцию: зафиксирована и отменена. При этом сами данные не меняются, поэтому работает быстро.

Итого: блокировки на строки для чтений не устанавливаются никогда (ни для чтение-чтение, ни для чтение-запись). Блокировки устанавливаются только на запись-запись. Блокировки могут устанавливаться на таблицы: запрет удаления пока идет чтение, запрет чтения при перестроении таблицы.

Можно это увидеть через запросы:

    SELECT *, xmin, xmax FROM t;

Также можно посмотреть текущую транзакцию:

    BEGIN;
    SELECT txid_current();


#### 4.1.2 Очистка

Получается, что в таблице хранится несколько версий строки. Это ведет к разрастанию таблиц со временем, хотя среди этих версий будут версии больше не нужные.

Периодически запускается процесс очистки (vacuum). 

Два варианта:

* **частичная очистка** - помечает ненужные версии, фактически они остаются в файле, но на их место можно записывать новые строки. Этот процесс работает параллельно с основным процессом сервера. Но размер БД не уменьшается.
* **полная очистка** - перестраивает файл БД, удаляя ненужные строки и уменьшая размер. Но при этом блокирует таблицу.

Есть процесс `autovacuum launcher`:

* отслеживает работу с таблица и решает когда нужна очистка
* запускает дочерние процессы по очистке




### 4.2 Уровни изоляции

**Read uncommitted** - разрешает чтение незафиксированных транзакций. PostgreSQL не поддерживает.

**Read committed** - снимок строится на момент начала оператора. Поэтому одинаковые запросы внутри транзакции могут давать разные результаты. Это режим по умолчанию.

**Repeatable read** - снимок строится на момент первого оператора транзакции.

**Serializable** - полная изоляция. Как будто транзакции выполняются последовательно.



### 4.3 Буферный кеш и журналирование

#### 4.3.1 Буферный кеш

Буферный кеш: для согласования скорости работы оперативной памяти и дисков. Кеш состоит из массива буферов, содержащих страницы данных. Размер страницы задается при сборке PostgreSQL (8 кб обычно).

Любой запрос данных - сначала обращение к буферному кешу. Если нет в кеше, тогда обращение к ОС для чтения с диска (ОС свои кеши имеет).

На буферный кеш также устанавливаются блокировки при совместном доступе.

Если кеш заполнен, страницы нужно **вытеснять** из буфера и тогда можно заменять новыми. Если страница изменялась (**грязный буфер**), её нужно записать на диск. В первую очередь вытесняются страницы, которые дольше других не использовались.

#### 4.3.2 Журнал предварительной записи

Буферный кеш улучшает производительность, но возникает проблема потери кеша при сбоях. Для решения - журналирование: записи об операциях, позволяющие выполнить операции повторно при необходимости.

Записи об операциях создаются сразу на диск до выполнения самой операции - поэтому **журнал предварительной записи** (WAL). Располагается в `PGDATA/pg_wal`

Под журналирование попадают таблицы, индексы, состояние транзакций (xact), не попадают - временные и нежурналируемые таблицы (при сбоях данные в таких таблицах не восстанавливаются).

Обычно запись в журнал быстрее выполняется чем запись страниц в файл данных: запись в журнал это последовательная запись, а не произвольная. Справляются обычные HDD.

Два режима журналирования:

* **Синхронный**: запись в журнал выполняется сразу явно на диск (не в буфер ОС). При этом транзакция будет ждать окончания записи, это не быстрая операция.
* **Асинхронный**: на диск записи журнала переносятся отдельным фоновым заданием `walwriter`. Производительность повышается, но есть риск потерять записи журнала, хотя согласованность данных все равно обеспечивается.

Настраивается свойством `synchronous_commit`

Журнал можно применять и для других целей. Зависит от уровня ведения:

* **Minimal** - гарантия восстановления после сбоя
* **Replica** - значение по умолчанию, резервное копирование и репликация
* **Logical** - логическая репликация

Просмотр текущего объема журнала (вернет указатель на текущую запись в байтах, можно вычесть два указателя, чтобы получить изменение размера):

    SELECT pg_current_wal_lsn() AS pos1 \gset
    ...
    SELECT pg_current_wal_lsn() AS pos2 \gset
    SELECT :'pos2'::pg_lsn - :'pos1'::pg_lsn;

Посмотреть содержимое каталога PGDATA/pg_wal (это файлы по 16 МБ):

     SELECT * FROM pg_ls_waldir() ORDER BY name;

#### 4.3.3 Контрольные точки

Если произошел сбой, сервер после запуска начинает восстановление. Читаются и последовательно выполняются записи журнала, которые не попали на диск. 

Чтобы не просматривать весь журнал, формируются **контрольные точки**: в процессе работы сбрасываются все грязные буферы. Т. е. гарантируется, что до контрольной точки все изменения есть на диске.

Процесс создания контрольной точки может занимать длительное время: 50% - 90% времени между контрольными точками. Это нормально: не сильно влияет на производительность.

#### 4.3.4 Процессы, обслуживающие буферный кеш и журнал

**walwriter** - выполняет асинхронную запись журнала на диск. При синхронной записи это делает процесс, обслуживающий транзакцию

**checkpointer** - создает контрольные точки, сбрасывая грязные буферы на диск

**bgwriter** - фоновый процесс, также сбрасывает грязные буферы, которые с большой вероятностью будут вытеснены вскоре. Освобождает основные процессы от этой работы.

**обслуживающие процессы**, вытесняющие оставшиеся грязные буферы

Посмотреть дочерние процессы главного процесса:

    ps -o pid,command --ppid `head -n 1 $PGDATA/postmaster.pid`




## 5. Организация данных

### 5.1 Базы данных и схемы

#### 5.1.1 Шаблонные базы данных

##### 5.1.1.1 Зачем нужны

При инициализации кластера (команда `initdb`) создаются три одинаковые базы данных.

* **postgres** - используется при подключении по умолчанию пользователем postgres. Особо не нужна, но удалять не рекомендуется (наличии подразумевается некоторыми утилитами)
* **template1** - шаблон для создания любой новой базы. В эту базу можно добавлять объекты и расширения, они будут попадать в любую новую базу
*  **template0** - никогда не должна меняться. Используется для восстановления из архива утилитой pg_dump. Также при создании новой БД с кодировкой отличной от кодировки кластера.

Так например полный синтаксис создания БД (по факту копирование происходит):

    CREATE DATABASE <name> TEMPLATE <template_name>;

По умолчанию в качестве шаблона - **tempalte1**

Можно создать собственный шаблон (см. [здесь](https://postgrespro.ru/docs/postgresql/10/manage-ag-templatedbs.html))

##### 5.1.1.2 Разные команды 

    # просмотр списка баз:
    psql -l

    # подключение к БД:
    \с имя_бд

    # просмотр баз данных изнутри БД через представление pg_database
    # имя, шаблон или нет, разрешено подключение, лимит подключений
    SELECT datname, datistemplate, datallowconn, datconnlimit FROM pg_database;

    # создание БД (поключен к другой)
    CREATE DATABASE db; # можно выбрать шаблон явно

    # удаление (подключен должен быть к другой)
    DROP DATABASE db;

    # переименование (подключен к другой)
    ALTER DATABASE db RENAME TO db1;

    # просмотр размера БД
    SELECT pg_database_size('appdb');
    SELECT pg_size_pretty(pg_database_size('appdb'));

#### 5.1.2 Схемы

##### 5.1.2.1 Для чего нужны

Схемы - это пространство имен для объектов БД. Используется для разделения объектов на логические группы, избежания конфликтов имен. Каждый объект внутри БД принадлежит какой-то схеме. Если явно не указано - есть схема по умолчанию с именем `public`. Ничем особенным не отличается: просто есть по умолчанию и включается по умолчанию в путь поиска.

[подробнее](https://postgrespro.ru/docs/postgresql/10/ddl-schemas.html)

В общем такая иерархия: кластер содержит базы данных, базы данных содержат схемы, внутри схем расположены объекты. Клиент подключается одновременно только к одной БД, но внутри может работать с объектами любых схем.

К объектам можно обращаться по полному квалифицированному имени `схема.имя_объекта`. Такое имя однозначно идентифицирует объект. 

##### 5.1.2.2 Путь поиска

Если имя схемы не указано объект будет определятся с использованием **пути поиска (search_path)**. Это обычный конфигурационный параметр. Содержит перечень схем, по которым выполняется поиск по порядку. В пути могут находиться несуществующие схемы или те, на которые у пользователя нет прав. Такие исключаются из просмотра.

Значение по умолчанию: `$user, public`. `$user` - схема с именем текущего пользователя, пока ее явно не создали, отсутствует.

Неявно включаются:

* схема `pg_temp_nnn` - схема временных таблиц на время сеанса или транзакции
* `pg_catalog` - служебные объекты

Если эти схемы явно не указаны, тогда будут на первом месте, если явно указали - тогда там, где заявлены.

##### 5.1.2.3 Команды, функции работы со схемами

    CREATE SCHEMA имя_схемы;

    DROP SCHEMA имя_схемы;

    # удаление не пустой схемы:
    DROP SCHEMA имя_схемы CASCADE;

Любые операции над таблицами можно с указанием схемы:

    CREATE TABLE myschema.mytable (...);

Изменение схемы: 

    ALTER TABLE t SET SCHEMA new_schema;

Просмотр списка схем:

    \dn # от data namespace

Просмотр пути поиска:

    SHOW search_path;

Просмотр "эффективного" пути поиска:

    SELECT current_schemas(true);

Таблицы и их схемы:

    \dt # 

Установка пути поиска:

    # на время сеанса
    SET search_path = ...;
    # можно через файлы psqlrc, но это будет действовать для всего кластера
    
    # лучше устанавливать для БД
    ALTER DATABASE имя SET search_path = ..; 



### 5.2 Системный каталог

**Системный каталог** - набор таблиц/представлений с описанием объектов БД и кластера.

Расположен в схеме `pg_catalog`. Альтернативный вариант - `information_schema`.

В каждой БД создается свой набор системных таблиц. Часть этих таблиц будет общими для всех баз кластера. Например `pg_database`.

Правила наименования: 
    
    pg_<имя таблицы>.<префикс из 3-х символов><имя колонки>

Например: pg_database.datname

Содержимое хранится в нижнем регистре.

Таблицы системного каталога в качестве первичного ключа используют особый тип **OID**. Это целочисленный тип с автоинкрементом. Поэтому легко можно переименовывать сущности БД, т. к. имя - просто атрибут.

Для некоторых таблиц есть специальные представления/функции для преобразования OID в текстовое представление (имя сущности) и обратно. Это **Reg-типы**.

В общем случае к данным системного каталога можно обращаться через SQL команды или команды psql (обычно с `d` начинаются, с суффиксом `S` - системные)

    # все системные объекты
    \dS
    # базы данных
    SELECT * FROM pg_database;
    # схемы
    SELECT * FROM pg_namespace;
    # здесь например колонка nspowner - OID пользователя


Важная таблица **pg_class**: содержит описание разных объектов (таблиц, представлений, индексов и др.), описываемых термином *отношения* (*relations*). Колонка `relkind` уточняет этот тип.

Для отдельных типов есть более удобные представления:

    SELECT * FROM pg_tables;
    SELECT * FROM pg_views;

Есть аналогичные команды:

    \dt
    \dv
    # модификатор + дает больше информации
    \dt+
    # для конкретного объекта по имени
    \d mytable

Для изучения структуры системного каталога можно включить вывод запросов, выполняющихся при использовании команд:

    \set ECHO_HIDDEN on
    \dt

Пример преобразования OID:

    SELECT a.attname, a.atttypid FROM pg_attribute a
        WHERE a.attrelid = 'employees'::regclass AND a.attnum > 0;




### 5.3 Табличные пространства

#### 5.3.1 Основы

**Табличные пространства** определяют физическое расположение данных в файловой системе. Например одно ТП на медленных дисках для редко используемых данных, другое - на быстрых.

При инициализации кластера создаются 2 ТП:

* **pg_default** - пространство по умолчанию, где создаются объекты, если не указано явно
* **pg_global** - для хранения объектов системного каталога, общих для кластера

В одном ТП может быть несколько баз данных. Одна БД может хранить данные в нескольких ТП.

По сути ТП это указатель на каталог файловой системы: 

* `pg_global` - `$PGDATA/global/`
* `pg_default` - `$PGDATA/base/`

При создании своего ТП, указываем каталог явно. Допонительно PostgreSQL создает симлинки в `$PGDATA/pg_tblspc/`

Внутри `$PGDATA/base/` еще деление по БД. Если создается пользовательское ТП, внутри автоматически создаются директории под версию сервера (для переносимости)

Внутри каталогов хранятся объекты: каждый объект в своем файле.

#### 5.3.2 Команды для работы с ТП

Просмотр:
    
    # покажет размер и расположение (для стандартных - пустое)
    \db+

    SELECT * FROM pg_tablespace;

    # где таблицы находятся
    SELECT tablename, tablespace FROM pg_tables;

Работа с ТП:

    # создаем новое
    # нужен пустой каталог, владелец - пользователь postgres
    CREATE TABLESPACE new_ts LOCATION '/home/postgres/new_ts_dir';

    # создаем базу в новом ТП
    # тогда все таблицы этой БД по умолчанию будут в этом ТП
    CREATE DATABASE db TABLESPACE new_ts;

    # но можно явно задавать
    CREATE TABLE t() TABLESPACE pg_default;

Можно перемещать между ТП, при этом копирование файлов происходит и объект блокируется на время перемещения.

    ALTER TABLE t1 SET TABLESPACE pg_default;
    # или все объекты
    ALTER TABLE ALL IN TABLESPACE pg_default SET TABLESPACE ts;

    # можно для всей БД (находясь в другой)
    ALTER DATABASE db SET TABLESPACE pg_default;

Просмотр размера:

    SELECT pg_size_pretty( pg_tablespace_size('ts') );

Удалять можно только пустые ТП. Как с БД использовать `CASCADE` нельзя, т. к. несколько баз может использовать, а подключены только к одной
    
    DROP TABLESPACE ts;


### 5.4 Низкий уровень (структура файлов)

#### 5.4.1 Слои, сегменты

Каждому объекту БД (таблица, индекс и т. п.) соответствует несколько **слоев** (**forks**). Каждому слою соответствует файл. Если файл вырастает больше 1 ГБ, создается следующий файл слоя. Такие файлы - **сегменты**.

Имена файлов состоят из OID объекта, префикса слоя и номера сегмента. Например `13131_fsm.1` - сегмент 1 слоя fsm объекта с OID = 13131.

Таким образом одной таблице будет соответствовать минимум 3 файла, индексу - 2. Все они будут расположены в одном каталоге (если в одном пространстве). Т. к. файловые системы могут не очень работать с большим количеством файлов в одном каталоге, есть возможность оптимизации (разноска по пространствам ??).

Файлы делятся на страницы / блоки размером что и страницы буферного кеша (8 КБ  обычно). Собственно эти страницы файлов и попадают в буферный кеш.

Виды слоев:

* **основной** - собственно данные
    - например версии строк таблицы, строки индексов
    - существует у всех объктов
    - имена без префикса
* **слой инициализации** - есть у нежурналируемых объектов, например временных таблиц
    - используется для замены основного слоя при сбое
    - префикс `_init`
* **free space map (карта свободного пространства)**
    - показывает свободные строки, возникающие после очистки
    - для ускорения процесса вставки новых строк
    - появится только после очистки `VACUUM`
    - префикс `_fsm`
* **visibility map (карта видимости)**
    - отмечает страницы, в которых только актуальные версии строк
    - для оптимизации очистки и поиска
    - есть только для таблиц
    - префикс `_vm`

#### 5.4.2 Хранение длинных строк и TOAST

Любая версия строки (файл, собственно строка, большое число) должна помещаться на страницу файла.

Для длинных строк применяются разные стратегии: попытается сжать или вынесет в отдельную TOAST-таблицу. Такие таблицы расположены в пространстве `pg_toast` (по умолчанию не видны, но можно посмотреть)

