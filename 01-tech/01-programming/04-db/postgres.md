
## Содержание

<!-- MarkdownTOC autolink="true" uri_encoding="false" levels="2,3" -->

- [1. Установка и настройка](#1-Установка-и-настройка)
    - [1.1 Установка сервера](#11-Установка-сервера)
    - [1.2 Настройка переменных окружения](#12-Настройка-переменных-окружения)
    - [1.3 Начало работы](#13-Начало-работы)
    - [1.3.4 Команда pg_ctlcluster](#134-Команда-pg_ctlcluster)
    - [1.3.5 Где мои логи, чувак?](#135-Где-мои-логи-чувак)
- [2. Утилита psql](#2-Утилита-psql)
    - [2.1 Подключение к серверу](#21-Подключение-к-серверу)
    - [2.2 Основные команды](#22-Основные-команды)
    - [2.3 Выполнение скриптов при запуске](#23-Выполнение-скриптов-при-запуске)
    - [2.4 Форматирование вывода](#24-Форматирование-вывода)
    - [2.5 Разное](#25-Разное)
    - [2.6 Переменные psql и переменные окружения](#26-Переменные-psql-и-переменные-окружения)
- [3. Конфигурация](#3-Конфигурация)
    - [3.2 Файл postgresql.conf](#32-Файл-postgresqlconf)
    - [3.3 Файл postgresql.auto.conf](#33-Файл-postgresqlautoconf)
    - [3.4 Представление pg_file_settings](#34-Представление-pg_file_settings)
    - [3.5 Представление pg_settings](#35-Представление-pg_settings)
    - [3.6 Пользовательские параметры](#36-Пользовательские-параметры)
- [4. Архитектура](#4-Архитектура)
    - [4.1 Многоверсионность](#41-Многоверсионность)
    - [4.2 Уровни изоляции](#42-Уровни-изоляции)
    - [4.3 Буферный кеш и журналирование](#43-Буферный-кеш-и-журналирование)
- [5. Организация данных](#5-Организация-данных)
    - [5.1 Базы данных и схемы](#51-Базы-данных-и-схемы)
    - [5.2 Системный каталог](#52-Системный-каталог)
    - [5.3 Табличные пространства](#53-Табличные-пространства)
    - [5.4 Низкий уровень \(структура файлов\)](#54-Низкий-уровень-структура-файлов)

<!-- /MarkdownTOC -->


## 1. Установка и настройка

### 1.1 Установка сервера

[Инструкция с оф. сайта](https://www.postgresql.org/download/linux/ubuntu/)

    # Настраиваем репозиторий для apt-get
    sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
    
    # получаеи ключ для репозитория
    wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
    
    # собственно установка
    # здесь явно версия 10 указано, можно без указания, тогда актуальную 
    sudo apt-get update
    sudo apt-get -y install postgresql-10

Процесс установки:

* устанавливает в `/usr/lib/postgresql/` и утилиты в `/usr/bin/`
* создает пользователя `postgres` и группу `postgres`
* создает конфигурационные файлы в `/etc/postgresql/` и в `/etc/postgresql-common/` (напр. в `postgresql.conf` задана директория для БД)
* создает кластер БД в директории БД `var/lib/postgresql/10/main`, владелец - группа `postgres` через комманду `initdb`
* логи выводятся в `/var/log/postgresql/postgresql-10-main.log`
* также запускает сервер

### 1.2 Настройка переменных окружения

Все переменные не обязательны, просто для удобства

Добавить в `PATH` каталог с установленным PostgreSQL

**Вариант 1** (для конкретного пользователя):

    # зависит от оболочки, для bash
    # в файл ~/bashrc
    export PATH=$PATH:/usr/lib/postgresql/10/bin

**Вариант 2**

Через каталог `/etc/profile.d`: добавить туда скрипт с раcширением `.sh`

Это будет работать для всех пользователей, но только если они явно логинятся в систему (через `sudo su postgres` не буден работать) (см. login shell / non-login shell по ссылке ниже)

    sudo nano /etc/profile.d
        => PATH=$PATH:/usr/lib/postgresql/10/bin
    # сохранить

**Вариант 3**

Еще вариант - редактирование `/etc/environment`

[Подробно про переменные](https://stackoverflow.com/questions/14637979/how-to-permanently-set-path-on-linux-unix)

Можно создать переменную PGDATA (путь к директории БД (напр. `var/lib/postgresql/10/main`) )


### 1.3 Начало работы

#### 1.3.1 Пользователи ОС для сервера Postgres

Лучше использовать созданного в процессе установки пользователя `postgres` с одноименной группой. У него уже настроены необходимые разрешения.

Можно создать еще пользователя (зачем?): 

* `sudo adduser new_user`
* включить его в группу 134 ssl-cert (так у стандартного)
* дать новому пользователю права на `/var/run/postgresql` (через включение его в группу `postgres` ??)

#### 1.3.2 **Создание кластера БД**

Кластер - группа баз данных, управляемых одним экземпляром сервера Postgres

Для создания кластера необходимо:

* создать директорию для кластера БД, назначить владельцем пользователя `postgres`
    - `mkdir /var/lib/postgresql/10/testcluster`
    - `sudo chown postgres /var/lib/postgresql/10/testcluster`
    - `ls -l` покажет владельцев
* инициализировать кластер БД (от имени пользователя)
    - `sudo su postgres`
    - `initdb -k -D  /var/lib/postgresql/10/testcluster`
    - здесь `-k` включает подсчет контрольной суммы страниц (для обнаружения повреждений БД (влияет на производительность))
* вывод результата инициализации должен показать команду для запуска сервера

#### 1.3.3 Запуск / остановка

Если была стандартная установка сервер уже запущен.

Способы запуска:

* **pg_ctl** - низкоуровневая
    - `pg_ctl -D <каталог кластера> start`
* **pg_ctlcluster** - обертка над **pg ctl**, запускает по имени кластера
    - `pg_ctlcluster <версия кластера> <имя> start`

Кластера создаются по разному. При установке например, настройки хранятся в `/etc/postgresql/10/main` (в т. ч. конфигурационный файл). При создании кластера через `initdb -k -D ...` все настройки хранятся в том же каталоге, что и данные. 

Если конфигурационный файл расположен внутри кластера, можно запустить через `pg_ctl -D ... start`.

Если конфигурационный файл отдельно расположен, нужно указывать путь к нему `pg_ctl -D /var/lib/postgresql/10/main -o "-c config_file=/etc/postgresql/10/main/postgresql.conf" start`. Здесь через `-o` параметры передаются в команду `postgres` 

### 1.3.4 Команда pg_ctlcluster

* обертка для **pg_ctl**
* запускает по имени кластера
* внутри проверяет версию кластера и т. п. и запускает подходящую команду `pg_ctl`
* логи по умолчанию пишутся в `/var/logs/postgresql-<версия>-<имя кластера>`
* команды: start, stop, reload, status
* можно передавать параметры в вызываемую **pg_ctl**
* настройки может сохранять в `/etc/postgresql/<версия>/<имя>` или в директории кластера, в т. ч. **postgresql.conf** 

### 1.3.5 Где мои логи, чувак?

Смотрим переменную `log_destination` (метод логгирования):

    SHOW log_destination;

Там несколько вариантов может быть:

* `stderr` - по умолчанию
* `csvlog` - в формате csv
* `syslog` - пересылка логов сервисом, много настроек куда и как.
* `eventlog` - только для Win

Если `stderr`, также скорее всего куда-то перенаправляются.

Например при запуске через `pg_ctl -D ... start` вывод идет в терминал. Можно указать файл при запуске `pg_ctl -D ... -l mylog`. 

Стоит проверить переменную `logging_collector`

    SHOW logging_collector;

Если включен, значит см. переменные `log_directory` (если относительный - в каталоге кластера), `log_filename`.

Если выключен, системное расположение используется:

    # определить PID процесса
    # так например текущего psql
    select pg_backend_pid();
        => 31314
    # можно через top корневого postgres
    # затем проверить симлинк
    \! ls -l /proc/31314/fd/2
        => /var/log/postgresql/...
    # или из обычного терминала
    ls -l ....


**TODO**:

Просмотр процессов в терминале (м. б. top ?)

Запуск по умолчанию: systemd??? отключить, управление????

## 2. Утилита psql

### 2.1 Подключение к серверу

 Это терминальный клиент для работы с сервером PostgreSQL.

    psql -d <имя БД в кластере> -U <роль> -h <узел> -p <порт> 
    # после этого переход в режим ввода

Можно пробовать подключаться без указания параметров, тогда имя БД и роль будут браться по имени текущего пользователя (поэтому от имени пользователя `postgres` надо):

    sudo su postgres 
    psql

### 2.2 Основные команды

Команды начинаются с `\`.

Основные команды:

* `\c` - подключение к новой БД
* `\conninfo` - информация о текущем подключении 
* `\?` - справка по командам psql
* `\h` - список команд SQL
* `\h <имя комманды>` - синтаксис конкретной команды
* `\q` - выход

### 2.3 Выполнение скриптов при запуске

Можно настроить скрипты, выполняемые при запуске `psql`. Для этого общесистемный файл `psqlrc` или пользовательский `~/.psqlrc`. 

Общесистемный файл расположен в каталоге с настройками. Посмотреть расположение этого каталога `pg_config --sysconfdir`

Например так из оболочки под пользователем `postgres`

    # отображение времени выполнения запроса
    echo "\timing on" >> ~/.psqlrc
  
    # просмотрщик для результатов запросов
    echo "\setenv PAGER 'less -X'" >> ~/.psqlrc
    # можно флаг N еще добавить для вывода строк или в процессе работы переключать через `-N`. См. `man less`

### 2.4 Форматирование вывода

Полный список атрибутов можно посмотреть:

    \pset

Есть краткие команды:

* `\a` - переключение режима с выравнивания и без
* `\t` - переключение режима с выводом заголовков, итоговой строки и без
* `\x` - переключение режима вывода колонок в строки / в колонки

### 2.5 Разное

Выполнение команд оболочки: через `\!`

    \! pwd
    \! uptime

Запись в файл:

    # переключили в режим вывода в файл
    \o some_file 
    # здесь любые команды, результат выводится в файл
    ....
    # переключаем обратно
    \o 
    # можно посмотреть файл
    \! cat some_file

Запуск команд из файла:

    \i some-file
    # или из оболочки
    psql <some-file
    psql -f some-file

### 2.6 Переменные psql и переменные окружения

Аналог переменных окружения.

Устанавливаются через `\set` / `\unset`. Просмотр через `\echo`, полный список через `\set`

В переменную можно записать результат запроса:

    # внимание на отсутствие ;
    select now() as cur_time \gset
    \echo cur_time

В переменные можно записать текст запроса и выполнять его через переменную:

    \set cur_time 'select now();'
    # запуск
    :cur_time
    # просмотр переменной
    \echo :cur_time

Приглашения ввода:

    \set PROMPT1 '%n@%/%R%# '
    \set PROMPT2 '%n@%/%R%# '

Можно записать это в файлы `psqlrc`, тогда будет доступ всегда при запуске.

Работа с системными переменными из psql:
    
    # установка
    \setenv PAGER 'less -XSN'
    # просмотр
    \! echo $PAGER



## 3. Конфигурация

Разные параметры конфигурации можно устанавливать:

* для всего сеанса сервера
* для отдельной БД 
* для пользователя
* во время работы клиентского сеанса

### 3.2 Файл postgresql.conf

Главный источник параметров - файл `postgresql.conf`. Может находится или в каталоге с данными, или отдельно (напр. `/etc/postgresql`)

Посмотреть расположение (в pqsl):
    
    # команда SQL
    SHOW config_file;
    # показать все параметры
    SHOW ALL;

При изменении в файле, нужно чтобы сервер перечитал этот файл. Есть разные способы:
    
    # 1. через утилиты pg_ctl / pg_ctlcluster
    $ pg_ctl reload
    # 2. послать сигнал главному процессу сервера postmaster
    $ kill -HUP
    # 3. через psql
    => SELECT pg_reload_conf();

Для некоторых параметров может требоваться перезагрузка

### 3.3 Файл postgresql.auto.conf

Предназначен для редактирования конфигурационных параметров посредством команд SQL. Доступ к файлу не нужен:

    # установка значения (добавляет строку в файл)
    ALTER SYSTEM SET <параметр> TO <значение>;
    # удаление параметр (строку файла)
    ALTER SYSTEM RESET <параметр>;
    # удаление всех параметров из файла
    ALTER SYSTEM RESET ALL;

Файл считывается после `postgresql.conf`, т. е. настройки `postgresql.auto.conf` имеют приоритет

Всегда расположен в каталоге кластера БД.

Напрямую редактировать не стоит.

Чтобы изменения вступили в силу, также нужно чтобы сервер перечитал конфигурацию

### 3.4 Представление pg_file_settings

Одно из системных представлений.

    SELECT * FROM pg_file_settings;

Показывает сводное содержимое файлов конфигурации. Показывает, что есть в файлах, а не то, что сервер использует в данный момент. Для просмотра состояния сервера см. **pg_settiings**.

Колонки:

* `sourcefile` - файл-источник параметра (напр. `postgresql.conf`)
* `sourceline` - строка в файле
* `applied` - true/false может ли это изменение быть применено успешно
* `error` - описание ошибки

Если конфигурационный файл содержит синтаксические ошибки, представление будет содержать одну или нескольно строк с описанием ошибки.

### 3.5 Представление pg_settings

Показывает действующие значения конфигурационных параметров

    SELECT * FROM pg_settings;

Колонки:

* `name`, `setting`, `unit` - имя параметра, значение и единица измерения
* `boot_val` - значение по умолчанию
* `reset_val` - если во время сеанса будет вызвана команда `ALTER SYSTEM RESET`
* `source` - источник значения параметра
* `pending_restart` - значение изменено (например через конфигурационный файл) и требуется перезагрузка сервера
* минимальное и максимальное значение параметра

Колонка **context** описавает как можно изменить значение параметра:

* **internal** - это внутренний параметр, изменить непосредственно нельзя (пересобрать сервер может быть)
* **postmaster** - для изменения требуется перезапуск сервера
* **sighub** - можно без перезапуска, перечитав конфигурацию (reload)
* **superuser** - можно изменять в файле конфигурации или в сеансе ( команда SQL `SET`), но только суперпользователю. Параметры установленные через `SET` имеют больший приоритет, чем в файле конфигурации
* **user** - аналогично, но любой пользователь




### 3.6 Пользовательские параметры

Можно создавать свои параметры теми же способами, что и предопределенные:

* редактирование файла `postgresql.conf`
* через SQL команду `ALTER SYSTEM SET`
* установка на время сеанса через команду `SET`
* установка в запросе через функцию `set_config()`

Главное правило: имя должно содержать `.`, чтобы не путать с системными параметрами.

    SELECT CASE WHEN current_setting('myapp.currency_code', true) IS NULL THEN
                set_config('myapp.currency_code', 'RUB', false)
            ELSE
                current_setting('myapp.currency_code')
            END;




## 4. Архитектура

### 4.1 Многоверсионность

#### 4.1.1 Суть многоверсионности

Введена для решения проблем при многопоточном доступе. Если несколько процессов одновременно хотят записать данные в одну строку, вынуждены ставить блокировку и процессы будут ждать. Если есть читающий и пишущий процесс тоже нужна блокировка, чтобы не нарушить консистентность, но это будет влиять на производительность.

Поэтому Postgres каждую строку таблицы БД хранит в нескольких версиях. Строка имеет отметку о начале действия и конце действия. В качестве меток выступают номера транзакций (они выдаются по нарастающей, поэтому могут играть роль отметок времени).

Так например INSERT создает строку с началом действия. UPDATE устанавливает конец действия и создает новую строку. DELETE устанавливает конец действия.

Чтение выполняется через **снимок данных**. Определяются еще активные транзакции и выбираются действующие версии строк. 

Для хранения информации о транзакциях используется специальный файл в каталоге данных (**pg_xact**). Также есть буфер в памяти. Два бита на каждую транзакцию: зафиксирована и отменена. При этом сами данные не меняются, поэтому работает быстро.

Итого: блокировки на строки для чтений не устанавливаются никогда (ни для чтение-чтение, ни для чтение-запись). Блокировки устанавливаются только на запись-запись. Блокировки могут устанавливаться на таблицы: запрет удаления пока идет чтение, запрет чтения при перестроении таблицы.

Можно это увидеть через запросы:

    SELECT *, xmin, xmax FROM t;

Также можно посмотреть текущую транзакцию:

    BEGIN;
    SELECT txid_current();


#### 4.1.2 Очистка

Получается, что в таблице хранится несколько версий строки. Это ведет к разрастанию таблиц со временем, хотя среди этих версий будут версии больше не нужные.

Периодически запускается процесс очистки (vacuum). 

Два варианта:

* **частичная очистка** - помечает ненужные версии, фактически они остаются в файле, но на их место можно записывать новые строки. Этот процесс работает параллельно с основным процессом сервера. Но размер БД не уменьшается.
* **полная очистка** - перестраивает файл БД, удаляя ненужные строки и уменьшая размер. Но при этом блокирует таблицу.

Есть процесс `autovacuum launcher`:

* отслеживает работу с таблица и решает когда нужна очистка
* запускает дочерние процессы по очистке




### 4.2 Уровни изоляции

**Read uncommitted** - разрешает чтение незафиксированных транзакций. PostgreSQL не поддерживает.

**Read committed** - снимок строится на момент начала оператора. Поэтому одинаковые запросы внутри транзакции могут давать разные результаты. Это режим по умолчанию.

**Repeatable read** - снимок строится на момент первого оператора транзакции.

**Serializable** - полная изоляция. Как будто транзакции выполняются последовательно.



### 4.3 Буферный кеш и журналирование

#### 4.3.1 Буферный кеш

Буферный кеш: для согласования скорости работы оперативной памяти и дисков. Кеш состоит из массива буферов, содержащих страницы данных. Размер страницы задается при сборке PostgreSQL (8 кб обычно).

Любой запрос данных - сначала обращение к буферному кешу. Если нет в кеше, тогда обращение к ОС для чтения с диска (ОС свои кеши имеет).

На буферный кеш также устанавливаются блокировки при совместном доступе.

Если кеш заполнен, страницы нужно **вытеснять** из буфера и тогда можно заменять новыми. Если страница изменялась (**грязный буфер**), её нужно записать на диск. В первую очередь вытесняются страницы, которые дольше других не использовались.

#### 4.3.2 Журнал предварительной записи

Буферный кеш улучшает производительность, но возникает проблема потери кеша при сбоях. Для решения - журналирование: записи об операциях, позволяющие выполнить операции повторно при необходимости.

Записи об операциях создаются сразу на диск до выполнения самой операции - поэтому **журнал предварительной записи** (WAL). Располагается в `PGDATA/pg_wal`

Под журналирование попадают таблицы, индексы, состояние транзакций (xact), не попадают - временные и нежурналируемые таблицы (при сбоях данные в таких таблицах не восстанавливаются).

Обычно запись в журнал быстрее выполняется чем запись страниц в файл данных: запись в журнал это последовательная запись, а не произвольная. Справляются обычные HDD.

Два режима журналирования:

* **Синхронный**: запись в журнал выполняется сразу явно на диск (не в буфер ОС). При этом транзакция будет ждать окончания записи, это не быстрая операция.
* **Асинхронный**: на диск записи журнала переносятся отдельным фоновым заданием `walwriter`. Производительность повышается, но есть риск потерять записи журнала, хотя согласованность данных все равно обеспечивается.

Настраивается свойством `synchronous_commit`

Журнал можно применять и для других целей. Зависит от уровня ведения:

* **Minimal** - гарантия восстановления после сбоя
* **Replica** - значение по умолчанию, резервное копирование и репликация
* **Logical** - логическая репликация

Просмотр текущего объема журнала (вернет указатель на текущую запись в байтах, можно вычесть два указателя, чтобы получить изменение размера):

    SELECT pg_current_wal_lsn() AS pos1 \gset
    ...
    SELECT pg_current_wal_lsn() AS pos2 \gset
    SELECT :'pos2'::pg_lsn - :'pos1'::pg_lsn;

Посмотреть содержимое каталога PGDATA/pg_wal (это файлы по 16 МБ):

     SELECT * FROM pg_ls_waldir() ORDER BY name;

#### 4.3.3 Контрольные точки

Если произошел сбой, сервер после запуска начинает восстановление. Читаются и последовательно выполняются записи журнала, которые не попали на диск. 

Чтобы не просматривать весь журнал, формируются **контрольные точки**: в процессе работы сбрасываются все грязные буферы. Т. е. гарантируется, что до контрольной точки все изменения есть на диске.

Процесс создания контрольной точки может занимать длительное время: 50% - 90% времени между контрольными точками. Это нормально: не сильно влияет на производительность.

#### 4.3.4 Процессы, обслуживающие буферный кеш и журнал

**walwriter** - выполняет асинхронную запись журнала на диск. При синхронной записи это делает процесс, обслуживающий транзакцию

**checkpointer** - создает контрольные точки, сбрасывая грязные буферы на диск

**bgwriter** - фоновый процесс, также сбрасывает грязные буферы, которые с большой вероятностью будут вытеснены вскоре. Освобождает основные процессы от этой работы.

**обслуживающие процессы**, вытесняющие оставшиеся грязные буферы

Посмотреть дочерние процессы главного процесса:

    ps -o pid,command --ppid `head -n 1 $PGDATA/postmaster.pid`




## 5. Организация данных

### 5.1 Базы данных и схемы

#### 5.1.1 Шаблонные базы данных

##### 5.1.1.1 Зачем нужны

При инициализации кластера (команда `initdb`) создаются три одинаковые базы данных.

* **postgres** - используется при подключении по умолчанию пользователем postgres. Особо не нужна, но удалять не рекомендуется (наличии подразумевается некоторыми утилитами)
* **template1** - шаблон для создания любой новой базы. В эту базу можно добавлять объекты и расширения, они будут попадать в любую новую базу
*  **template0** - никогда не должна меняться. Используется для восстановления из архива утилитой pg_dump. Также при создании новой БД с кодировкой отличной от кодировки кластера.

Так например полный синтаксис создания БД (по факту копирование происходит):

    CREATE DATABASE <name> TEMPLATE <template_name>;

По умолчанию в качестве шаблона - **tempalte1**

Можно создать собственный шаблон (см. [здесь](https://postgrespro.ru/docs/postgresql/10/manage-ag-templatedbs.html))

##### 5.1.1.2 Разные команды 

    # просмотр списка баз:
    psql -l

    # подключение к БД:
    \с имя_бд

    # просмотр баз данных изнутри БД через представление pg_database
    # имя, шаблон или нет, разрешено подключение, лимит подключений
    SELECT datname, datistemplate, datallowconn, datconnlimit FROM pg_database;

    # создание БД (поключен к другой)
    CREATE DATABASE db; # можно выбрать шаблон явно

    # удаление (подключен должен быть к другой)
    DROP DATABASE db;

    # переименование (подключен к другой)
    ALTER DATABASE db RENAME TO db1;

    # просмотр размера БД
    SELECT pg_database_size('appdb');
    SELECT pg_size_pretty(pg_database_size('appdb'));

#### 5.1.2 Схемы

##### 5.1.2.1 Для чего нужны

Схемы - это пространство имен для объектов БД. Используется для разделения объектов на логические группы, избежания конфликтов имен. Каждый объект внутри БД принадлежит какой-то схеме. Если явно не указано - есть схема по умолчанию с именем `public`. Ничем особенным не отличается: просто есть по умолчанию и включается по умолчанию в путь поиска.

[подробнее](https://postgrespro.ru/docs/postgresql/10/ddl-schemas.html)

В общем такая иерархия: кластер содержит базы данных, базы данных содержат схемы, внутри схем расположены объекты. Клиент подключается одновременно только к одной БД, но внутри может работать с объектами любых схем.

К объектам можно обращаться по полному квалифицированному имени `схема.имя_объекта`. Такое имя однозначно идентифицирует объект. 

##### 5.1.2.2 Путь поиска

Если имя схемы не указано объект будет определятся с использованием **пути поиска (search_path)**. Это обычный конфигурационный параметр. Содержит перечень схем, по которым выполняется поиск по порядку. В пути могут находиться несуществующие схемы или те, на которые у пользователя нет прав. Такие исключаются из просмотра.

Значение по умолчанию: `$user, public`. `$user` - схема с именем текущего пользователя, пока ее явно не создали, отсутствует.

Неявно включаются:

* схема `pg_temp_nnn` - схема временных таблиц на время сеанса или транзакции
* `pg_catalog` - служебные объекты

Если эти схемы явно не указаны, тогда будут на первом месте, если явно указали - тогда там, где заявлены.

##### 5.1.2.3 Команды, функции работы со схемами

    CREATE SCHEMA имя_схемы;

    DROP SCHEMA имя_схемы;

    # удаление не пустой схемы:
    DROP SCHEMA имя_схемы CASCADE;

Любые операции над таблицами можно с указанием схемы:

    CREATE TABLE myschema.mytable (...);

Изменение схемы: 

    ALTER TABLE t SET SCHEMA new_schema;

Просмотр списка схем:

    \dn # от data namespace

Просмотр пути поиска:

    SHOW search_path;

Просмотр "эффективного" пути поиска:

    SELECT current_schemas(true);

Таблицы и их схемы:

    \dt # 

Установка пути поиска:

    # на время сеанса
    SET search_path = ...;
    # можно через файлы psqlrc, но это будет действовать для всего кластера
    
    # лучше устанавливать для БД
    ALTER DATABASE имя SET search_path = ..; 



### 5.2 Системный каталог

**Системный каталог** - набор таблиц/представлений с описанием объектов БД и кластера.

Расположен в схеме `pg_catalog`. Альтернативный вариант - `information_schema`.

В каждой БД создается свой набор системных таблиц. Часть этих таблиц будет общими для всех баз кластера. Например `pg_database`.

Правила наименования: 
    
    pg_<имя таблицы>.<префикс из 3-х символов><имя колонки>

Например: pg_database.datname

Содержимое хранится в нижнем регистре.

Таблицы системного каталога в качестве первичного ключа используют особый тип **OID**. Это целочисленный тип с автоинкрементом. Поэтому легко можно переименовывать сущности БД, т. к. имя - просто атрибут.

Для некоторых таблиц есть специальные представления/функции для преобразования OID в текстовое представление (имя сущности) и обратно. Это **Reg-типы**.

В общем случае к данным системного каталога можно обращаться через SQL команды или команды psql (обычно с `d` начинаются, с суффиксом `S` - системные)

    # все системные объекты
    \dS
    # базы данных
    SELECT * FROM pg_database;
    # схемы
    SELECT * FROM pg_namespace;
    # здесь например колонка nspowner - OID пользователя


Важная таблица **pg_class**: содержит описание разных объектов (таблиц, представлений, индексов и др.), описываемых термином *отношения* (*relations*). Колонка `relkind` уточняет этот тип.

Для отдельных типов есть более удобные представления:

    SELECT * FROM pg_tables;
    SELECT * FROM pg_views;

Есть аналогичные команды:

    \dt
    \dv
    # модификатор + дает больше информации
    \dt+
    # для конкретного объекта по имени
    \d mytable

Для изучения структуры системного каталога можно включить вывод запросов, выполняющихся при использовании команд:

    \set ECHO_HIDDEN on
    \dt

Пример преобразования OID:

    SELECT a.attname, a.atttypid FROM pg_attribute a
        WHERE a.attrelid = 'employees'::regclass AND a.attnum > 0;




### 5.3 Табличные пространства

#### 5.3.1 Основы

**Табличные пространства** определяют физическое расположение данных в файловой системе. Например одно ТП на медленных дисках для редко используемых данных, другое - на быстрых.

При инициализации кластера создаются 2 ТП:

* **pg_default** - пространство по умолчанию, где создаются объекты, если не указано явно
* **pg_global** - для хранения объектов системного каталога, общих для кластера

В одном ТП может быть несколько баз данных. Одна БД может хранить данные в нескольких ТП.

По сути ТП это указатель на каталог файловой системы: 

* `pg_global` - `$PGDATA/global/`
* `pg_default` - `$PGDATA/base/`

При создании своего ТП, указываем каталог явно. Допонительно PostgreSQL создает симлинки в `$PGDATA/pg_tblspc/`

Внутри `$PGDATA/base/` еще деление по БД. Если создается пользовательское ТП, внутри автоматически создаются директории под версию сервера (для переносимости)

Внутри каталогов хранятся объекты: каждый объект в своем файле.

#### 5.3.2 Команды для работы с ТП

Просмотр:
    
    # покажет размер и расположение (для стандартных - пустое)
    \db+

    SELECT * FROM pg_tablespace;

    # где таблицы находятся
    SELECT tablename, tablespace FROM pg_tables;

Работа с ТП:

    # создаем новое
    # нужен пустой каталог, владелец - пользователь postgres
    CREATE TABLESPACE new_ts LOCATION '/home/postgres/new_ts_dir';

    # создаем базу в новом ТП
    # тогда все таблицы этой БД по умолчанию будут в этом ТП
    CREATE DATABASE db TABLESPACE new_ts;

    # но можно явно задавать
    CREATE TABLE t() TABLESPACE pg_default;

Можно перемещать между ТП, при этом копирование файлов происходит и объект блокируется на время перемещения.

    ALTER TABLE t1 SET TABLESPACE pg_default;
    # или все объекты
    ALTER TABLE ALL IN TABLESPACE pg_default SET TABLESPACE ts;

    # можно для всей БД (находясь в другой)
    ALTER DATABASE db SET TABLESPACE pg_default;

Просмотр размера:

    SELECT pg_size_pretty( pg_tablespace_size('ts') );

Удалять можно только пустые ТП. Как с БД использовать `CASCADE` нельзя, т. к. несколько баз может использовать, а подключены только к одной
    
    DROP TABLESPACE ts;


### 5.4 Низкий уровень (структура файлов)

#### 5.4.1 Слои, сегменты

Каждому объекту БД (таблица, индекс и т. п.) соответствует несколько **слоев** (**forks**). Каждому слою соответствует файл. Если файл вырастает больше 1 ГБ, создается следующий файл слоя. Такие файлы - **сегменты**.

Имена файлов состоят из OID объекта, префикса слоя и номера сегмента. Например `13131_fsm.1` - сегмент 1 слоя fsm объекта с OID = 13131.

Таким образом одной таблице будет соответствовать минимум 3 файла, индексу - 2. Все они будут расположены в одном каталоге (если в одном пространстве). Т. к. файловые системы могут не очень работать с большим количеством файлов в одном каталоге, есть возможность оптимизации (разноска по пространствам ??).

Файлы делятся на страницы / блоки размером что и страницы буферного кеша (8 КБ  обычно). Собственно эти страницы файлов и попадают в буферный кеш.

Виды слоев:

* **основной** - собственно данные
    - например версии строк таблицы, строки индексов
    - существует у всех объктов
    - имена без префикса
* **слой инициализации** - есть у нежурналируемых объектов, например временных таблиц
    - используется для замены основного слоя при сбое
    - префикс `_init`
* **free space map (карта свободного пространства)**
    - показывает свободные строки, возникающие после очистки
    - для ускорения процесса вставки новых строк
    - появится только после очистки `VACUUM`
    - префикс `_fsm`
* **visibility map (карта видимости)**
    - отмечает страницы, в которых только актуальные версии строк
    - для оптимизации очистки и поиска
    - есть только для таблиц
    - префикс `_vm`

#### 5.4.2 Хранение длинных строк и таблицы TOAST

Любая версия строки (файл, собственно строка, большое число) должна помещаться на страницу файла.

Для длинных строк применяются разные стратегии: попытается сжать и/или вынесет в отдельную **TOAST-таблицу**. Такие таблицы расположены в пространстве `pg_toast` или `pg_toast_temp_N` для временных. По умолчанию не видны, но можно посмотреть:

    SELECT chunk_id, chunk_seq, length(chunk_data) FROM pg_toast.pg_toast_16428`);

Для таблиц TOAST также правило строка на файл, поэтому может разбивать на части. Версионность для таких таблиц своя, поэтому несколько версий строки основного файла могут ссылаться на одну строку таблицы TOAST.

#### Команды для работы с файлами, слоями, TOAST

Базовый каталог объекта можно получить по его имени:
    
    SELECT pg_relation_filepath('my_table');
        => base/16499/16502

Или получить OID объекта:
    
    SELECT OID FROM pg_database WHERE datname = 'my_table';

Также можно использовать утилиту `oid2name` (входит в стандартную установку)

Размеры объектов:

    # по слоям:
    SELECT pg_relation_size('t','main') main, pg_relation_size('t','fsm') fsm;
    
    # таблица без индексов
    SELECT pg_table_size('t');
    
    # индекс таблицы
    SELECT pg_indexes_size('t');
    
    # размер всей таблицы
    SELECT pg_total_relation_size('t');

Работа с TOAST:

    # есть ли у таблицы соответствующая TOAST-таблица:
    # смотрим колокну в таблице pg_class
    SELECT reltoastrelid FROM pg_class WHERE relname='t'
    # можно дополнительно реквизиты самой таблицы TOAST
    SELECT * FROM pg_class WHERE oid = ..;

Стратегии работы с длинными строками можно посмотреть через `\d+ <имя таблицы>`, колонка `Storage`:

* **plain** - тип фиксированной длины, TOAST не используется
* **main** - приоритет сжатия
* **extended** - попытается сжать, если результата не увидит - отдельное хранение 
* **external** - сразу отдельное хранение

Можно поменять стратегию (начнет действовать для новых данных):

    ALTER TABLE t ALTER COLUMN n SET STORAGE extended;
