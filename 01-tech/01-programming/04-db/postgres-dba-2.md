## Содержание

<!-- MarkdownTOC autolink="true" uri_encoding="false" levels="2,3" -->

- [1. Многоверсионность](#1-Многоверсионность)
    - [1.1 Транзакции](#11-Транзакции)
    - [1.2 Страницы и версии строк](#12-Страницы-и-версии-строк)
    - [1.3 Снимки данных и горизонт событий](#13-Снимки-данных-и-горизонт-событий)

<!-- /MarkdownTOC -->

## 1. Многоверсионность

### 1.1 Транзакции

#### 1.1.1 Свойства транзакций

Транзакция - совокупность операций, которые переводят базу из одного корректного состояния в другое (**согласованность**), при условии, что транзакция выполнена полностью (**атомарность**) и без помех со стороны других транзакций (**изолированность**). (+ **долговечность**)

Согласованность состояния определяется ограничениями на уровне БД или семантикой приложения.

#### 1.1.2 Аномалии

Ослабление **изолированности** ведет к аномалиям:

* **грязное чтение** - транзакция Т2 читает данные незафиксированной транзакции Т1, при откате транзакции Т1 получается, что Т2 видела данные, которых не существовало.
* **неповторяющееся чтение (non-repeatable read)** - Т1 читает строку. Т2 изменяет или удаляет эту строку и фиксируется. Т1 снова читает строку и видит изменения
* **фантомное чтение** - Т1 читает набор строк по условию. Т2 добавляет строку, соответствующее условию и фиксируется. Т1 читает еще раз и видит новые строки.
* есть другие.

#### 1.1.3 Уровни изолированности

Стандарт SQL определяет уровни изолированности по аномалиям:

* **Read Uncommitted** - возможно грязное чтение и все другие аномалии
* **Read Committed** - грязное чтение невозможно, остальные возможны
* **Repeatable Read** - неповторяющееся чтение, грязное чтение невозможны, остальные возможны
* **Serializable** - никакие аномалии невозможны, как если бы последовательно транзакции выполнялись

Дополнительно: ни на каком уровне **не допускается потеря сделанных изменений в других транзакциях** (**lost updates**). Пример потерянного обновления: Т1 читает строку по условию, Т1 изменяет ее, Т2 читает ту же строку. Т2 изменяет. Т1 фиксируется. Т2 фиксируется. Изменения Т1 потеряны. БД не должны такого допускать.

Особенности PostgreSQL - более строгие ограничения:

* грязное чтение невозможно (многоверсионность), поэтому **Read Uncommitted** и **Read Committed** эквиваленты.
* **Repeatable Read** не допускает также фантомного чтения
* уровень по умолчанию - самый низший **Read Committed**

Итого:

* уровень **Read Committed**:
    - SELECT видит снимок БД на момент выполнения каждого оператора внутри транзакции
    - никогда не увидит незафиксированных изменений или изменений, внесенных паралелльными транзакциями в процессе выполнения запроса (НЕ транзакции)
    - два последовательных SELECT могут видеть разные данные, если были зафиксированные транзакции
    - если две транзакции выполняют изменение / удаление одной строки, вторая транзакция будет ожидать результата первой и работать с обновленной версией строки
    - есть варианты выполнения команды INSERT: ON CONFLICT DO UPDATE и ON CONFLICT DO NOTHING
* уровень **Repeatable Read**:
    - снимок БД фиксируется на момент первого оператора в транзакции (не BEGIN)
    - если две транзакции выполняют изменение / удаление одной строки, вторая транзакция будет ожидать результата первой, и в случае фиксации первой - выдаст ошибку.
* уровень **Serializable**:
    - точно также получаем ошибку при параллельной записи
    - чтобы работал, все транзакции должны быть на уровне Serializable

#### 1.1.4 Команды для работы с транзакциями

Выполнение в транзакции:

    BEGIN;
    ....
    ROLLBACK;
    COMMIT;

Установка уровня изолированности:

    BEGIN;
    # первая комманда после начала транзакции
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
    # или сразу
    BEGIN ISOLATION LEVEL READ UNCOMMITTED;

Просмотр уровня транзакции:

    SHOW transaction_isolation;
    # по умолчанию:
    SHOW default_transaction_isolation; 

#### 1.1.5 Примеры работы

Блокировки параллельных транзакций при записи: 

    # уровень Read Committed
    T1: BEGIN;
    T1: UPDATE t SET n = 4;
    T2: BEGIN;
    T2: UPDATE t SET n = n + 10;
    # т. к. нельзя допустить lost updates, T2 блокируется и ждет результата T1
    # аналогично для DELETE
    # при этом если удаление по условию выполняется и в результате другой транзакции это условие перестает выполнятся, удаления не произойдет
    # если 
    T1: COMMIT;
    T2: COMMIT; # здесь еще раз выполняется обновление строки
    SELECT * FROM t;
        n = 14;

Ошибка параллельных транзакций при записи:

    # уровень Repeatable Read;
    T1: BEGIN ISOLATION LEVEL REPEATABLE READ;
    T1: UPDATE t SET n = 4;
    T2: BEGIN ISOLATION LEVEL REPEATABLE READ;
    T2: UPDATE t SET n = 10;
    # Т2 ждет результата Т1
    Т1: COMMIT;
    # T2 тут же выдает ошибку: из-за запрета lost updates T2 должна перечитать данные, но уровень изоляции не позволяет этого сделать    



### 1.2 Страницы и версии строк

#### 1.2.1 Структура данных

##### 1.2.1.1 Структура страницы

Размер страницы по умолчанию 8 КБ. 

Таблицы, индексы и другие объекты используют одинаковую структуру страниц, чтобы пользоваться общим буферным кешем.

Структура страницы:

* вначале - блок указателей (24 байта) - общие сведения, размер других областей
* указатели - каждый указатель 4 байта, указывает на позицию версии строки (**tuple**) на странице
* собственно версии строк расположены в конце страницы

Косвенная адресация позволяет например перемещать строки, не ломая индексы

Страницы попадают в буферный кеш прямо с диска, без преобразований. Поэтому нет совместимости между разными платформами (разрядность, порядок байт).

При хранении данных используется выравнивание по границам машинных слов (32-битные - 4 байта, 64-х - 8 байт). Поэтому правильное расположение колонок может дать некоторую экономию.    

##### 1.2.1.2 Указатели

Содержат:

* ссылку на версию строки
* длину этой версии
* несколько бит, определяющих статус версии
    - примеры статусов: `normal`, `dead` (версия строки удалена, но указатель используется чем-то извне), `unused` (указатель и версия удалены)
    - изменяют статусы например `VACUUM`, внутристраничная очистка

##### 1.2.1.3 Версии строк

Состоят из заголовка и данных.

Заголовок:

* **xmin**, **xmax** - определяют видимость версий в терминах номеров транзакций
* **ctid** - ссылка на следующую версию строки, у актуальной версии - на себя же. Формат: (номер страницы, номер указателя в массиве)
* ряд битов **infomask**

Структура индексных страниц сильно зависит от типа индекса. Но обычно также содержит указатели на версии строк **ctid**. Не содержит никаких данных о версиях строк (нет полей xmax, xmin).




#### 1.2.2 Выполнение операций

**Вставляется строка в транзакции**

* Начинается транзакция, добавляется строка:
    - создается указатель с номером 1 на версию строки
    - в версии строки **xmin** содержит номер транзакции (100 например)
    - **xmax** пустой и бит **xmax_aborted** установлен в истину, т. е. другие транзакции будут игнорировать **xmax**
    - в журнале XACT для 100 транзакции биты не установлены (транзакция еще активна)
    - **ctin** ссылается на эту же строку
* Транзакция фиксируется
    - в журнале XACT у транзакции № 100 устанавливается бит **committed**
    - больше ничего не меняется, транзакция завершена

**Другая транзакция пытается прочитать строку**:

*  Видит версию строки с номером транзакции 100. Нужно понять в каком состоянии эта транзакция
    -  проверяет статус транзакции: активна или завершилась. Для этого есть структура в памяти ProcArray
    -  если завершилась - проверяет фиксацией или отменой по битам журнала XACT
    -  чтобы повторно не выполнять это, устанавливает информационные биты в версии строки **xmin committed** или **xmin aborted**. Последующие транзакции будут анализировать только эти биты

Почему только следующая транзакция устанавливает эти биты, а не исходная? Нужно запоминать какие строки, на каких страницах, страницы могут быть уже не в кеше.

Следствие: операции чтения могут вызывать записи на диск (когда обновляются биты во время первого чтения после записи).

**Удаление строки**

* в **хmax** записывается номер текущей транзакции (выступает также как признак блокировки, если транзакция активна)
* бит **xmax_aborted** сбрасывается
* транзакция завершается, больше ничего не происходит
* последующее чтение:
    - проверит статус транзакции в XACT
    - установит бит **xmax committed** или **xmax aborted**

**Обновление строки**

* удаляется предыдущая версия строки
    - все то же, что при удалении обычном
* записывается новая
    - аналогично обычной вставке
    - обновляется **ctid**


#### 1.2.3 Точки сохранения и вложенные транзакции

**Точка сохранения** - возможность откатить часть транзакции.

    BEGIN;
    INSERT ...
    SAVEPOINT sp;
    DELETE ...
    ROLLBACK TO sp;
    ....
    COMMIT;


Реализованы через вложенные транзакции. От начала до точки сохранения одна, от точки до конца - другая. При возврате к точке просто меняется статус в XACT.

Вложенные транзакции имеют номер больший чем основная. Могут иметь свой статус. Но при откате основной, откатываются и они.

Информация о вложенности хранится в `$PGDATA/subtrans/`

### 1.3 Снимки данных и горизонт событий

#### 1.3.1 Снимки данных

**Снимки данных** нужны для транзакций и определяют какие версии строк видны, а какие нет.

Для уровня **Read Committed** снимок создается в начале каждого оператора транзакции и активен, пока этот оператор выполняется.

Для уровней **Repeatable Read** и **Serializable** создается один раз в начале первого оператора и активен до конца транзакции.

Видна версия строки в снимке или нет: на основе **xmin** и **xmax**. Эти номера не пересекаются, поэтому в одном снимке - максимум одна версия строки.

Транзакции видные в снимке, если это та же самая транзакция или транзакция зафиксирована до начала снимка.

Чем определяется снимок:

* моментом создания снимка - номер следующей, еще не существующей транзакции (**xmax снимка**)
* списком активных транзакций на момент создания снимка (зная номер транзакции, можем понять ее состояние, но когда она точно завершилась неизвестно (в момент создания снимка или чуть позже). Поэтому нужен список активных транзакций на момент создания снимка.)
* для удобства **xmin** самой ранней активной транзакции

Просмотр снимка: функция `txid_current_snapshot()`, возвращает список xid, разделенных `:`:

* xmin - минимальная транзакция на момент создания снимка
* xmax - номер следущей (еще не существующей транзакции)
* список активных транзакций

#### 1.3.2 Горизонт событий

**xmin** самой ранней активной транзакции снимка определяет **горизонт событий** для транзакции. За горизонтом событий транзакция видит только актуальные версии строк.

Аналогично для всей БД - **горизонт событий** определяется через самый ранний **xmin** снимка всех активных транзакций. За горизонтом событий БД неактуальные версии строк больше не увидит ни одна транзакция и их можно удалять.

**Удержание горизонта событий**: любая транзакция (даже Read Committed) удерживает горизонт БД, препятствуя очищению.

Можно управлять параметрами:

* `old_snapshot_treshold` - определяет максимальное время жизни снимка. При превышении - сервер получает право удалять неактуальные версии. Если транзакция обращается к этим данным - ошибка `snapshot too old`
* `idle_in_transaction_session_timeout` - прерывает транзакции в бездействии по истечении указанного времени

Посмотреть можно через системную таблицу:

    SELECT backend_xmin FROM pg_stat_activity WHERE pid = pg_backend_pid();


#### 1.3.3 Виртуальные транзакции

Если транзакция только читает данные, она никак не может изменить видимость версий строк. Поэтому любой транзакции сначала можно выдать **виртуальный номер (virtual xid)**. 

Он выдается текущим процессом, не требует синхронизации и поэтому быстро дается. Если выполняется запись в транзакции, тогда ей уже присваивается настоящий номер.

Функция `txid_current()` возвращает номер транзакции (если виртуальный - создает реальный и возвращает его)

Функция `txid_current_if_assigned()` возвращает реальный номер, только если он назначен


#### 1.3.4 Экспорт снимка

Если несколько параллельных транзакций должны видеть одинаковую картину данных. Например `pg_dump`, работающий параллельно.

Функция `pg_export_snapshot` возвращает идентификатор снимка.

Он может быть передан в другую транзакции через `SET TRANSACTION SNAPSHOT`. Можно только в Repeatable Read или в Serializable транзакции (в Read Committed снимки на каждый оператор создаются)


### 1.4 HOT-обновления

При работе с таблицей в индексе создаются ссылки на все версии строк.

Поэтому например таким может быть индекс на строковую колонку (одна строка, разные версии):

    ctid    |   ключ
    (0, 2)  |   BAR    
    (0, 3)  |   BAZ    
    (0, 1)  |   FOO    

Проблемы при таком подходе:

* при любом изменении строки (когда новые версии появляются) необходимо обновлять все индексы, даже если изменяемые колонки не входят в индекс
* индексы хранят ссылки на устаревшие версии, нужно очищать

Режим **HOT-обновления** решает эти проблемы индексов **для колонок, которые не меняются при изменении строки**:

* в индексах создается только одна запись со ссылкой на первую версию строки
* внутри страницы создается цепочка версий:
    - измененные строки, входящие в цепочку обозначаются битом **heap hot updated**
    - строки, на которых нет ссылок в индексе обозначаются битом **heap only tuple** (т. е. только табличная версия строки)
    - версии строк связаны обычным образом через **ctid**

Если сервер из индекса попадает на строку с битом **heap hot update**, он будет идти по цепочке и проверять видимость версий

Цепочка версий HOT-обновления может располагаться только в пределах одной страницы. В этом случае получаем высокую производительность. Если на странице места нет - цепочка прерывается, версия сохраняется на другой странице и для нее создается новая запись в индексе. 

Поэтому **при частом изменении неиндексируемых колонок** можно зарезервировать свободное место на странице через параметр `fillfactor` (100% - 10%). По достижении заданного процента вставка новых строк в эту страницу будет запрещена, но могут добавляться версии строк для выстраивания цепочек.


### 1.5 Внутристраничная очистка

Может выполняться, если:

* обновление не обнаружило места для вставки новой версии строки
* страница заполнена больше, чем `fillfactor`

Работает строго в пределах одной страницы (скорость). Может вызываться как при записи, так и просто при чтении (`SELECT`).

Что делает:

* удаляет версии строк, находящиеся за горизонтом событий.
* меняет статус указателей на удаленные версии строк (конкретный статус зависит: HOT-цепочка или нет)
* карта свободного простанства не обновляется (свободные места лучше под обновления, а не вставки)
* карта видимости не обновляется
* сдвигает строки для уменьшения фрагментации

Если версии не входят в HOT-цепочку, статус указателя устанавливается в `dead`. Сами указатели не удаляются, ведь на них могут быть ссылки (из индексов например или из других страниц). Если входит в HOT-цепочку: середину цепочки можно удалять (статус `unused`, ссылок нет). Указатель на начало цепочки получает статус `redirect` (на этот указать есть ссылка в индексе) и перенаправляет на актуальную версию строки цепочки. 

