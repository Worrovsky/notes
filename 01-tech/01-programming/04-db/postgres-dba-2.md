## Содержание

<!-- MarkdownTOC autolink="true" uri_encoding="false" levels="2,3" -->

- [1. Многоверсионность](#1-Многоверсионность)
    - [1.1 Транзакции](#11-Транзакции)
    - [1.2 Страницы и версии строк](#12-Страницы-и-версии-строк)
    - [1.3 Снимки данных и горизонт событий](#13-Снимки-данных-и-горизонт-событий)
    - [1.4 HOT-обновления](#14-hot-обновления)
    - [1.5 Внутристраничная очистка](#15-Внутристраничная-очистка)
    - [1.6 Очистка](#16-Очистка)
    - [1.7 Автоочистка](#17-Автоочистка)
    - [1.8 Заморозка](#18-Заморозка)
- [2. Журналирование](#2-Журналирование)
    - [2.1 Буферный кеш](#21-Буферный-кеш)
    - [2.2 Журнал предзаписи WAL](#22-Журнал-предзаписи-wal)
    - [2.3 Контрольные точки](#23-Контрольные-точки)
- [99. Вопросы для анализа БД](#99-Вопросы-для-анализа-БД)

<!-- /MarkdownTOC -->

## 1. Многоверсионность

### 1.1 Транзакции

#### 1.1.1 Свойства транзакций

Транзакция - совокупность операций, которые переводят базу из одного корректного состояния в другое (**согласованность**), при условии, что транзакция выполнена полностью (**атомарность**) и без помех со стороны других транзакций (**изолированность**). (+ **долговечность**)

Согласованность состояния определяется ограничениями на уровне БД или семантикой приложения.

#### 1.1.2 Аномалии

Ослабление **изолированности** ведет к аномалиям:

* **грязное чтение** - транзакция Т2 читает данные незафиксированной транзакции Т1, при откате транзакции Т1 получается, что Т2 видела данные, которых не существовало.
* **неповторяющееся чтение (non-repeatable read)** - Т1 читает строку. Т2 изменяет или удаляет эту строку и фиксируется. Т1 снова читает строку и видит изменения
* **фантомное чтение** - Т1 читает набор строк по условию. Т2 добавляет строку, соответствующее условию и фиксируется. Т1 читает еще раз и видит новые строки.
* есть другие.

#### 1.1.3 Уровни изолированности

Стандарт SQL определяет уровни изолированности по аномалиям:

* **Read Uncommitted** - возможно грязное чтение и все другие аномалии
* **Read Committed** - грязное чтение невозможно, остальные возможны
* **Repeatable Read** - неповторяющееся чтение, грязное чтение невозможны, остальные возможны
* **Serializable** - никакие аномалии невозможны, как если бы последовательно транзакции выполнялись

Дополнительно: ни на каком уровне **не допускается потеря сделанных изменений в других транзакциях** (**lost updates**). Пример потерянного обновления: Т1 читает строку по условию, Т1 изменяет ее, Т2 читает ту же строку. Т2 изменяет. Т1 фиксируется. Т2 фиксируется. Изменения Т1 потеряны. БД не должны такого допускать.

Особенности PostgreSQL - более строгие ограничения:

* грязное чтение невозможно (многоверсионность), поэтому **Read Uncommitted** и **Read Committed** эквиваленты.
* **Repeatable Read** не допускает также фантомного чтения
* уровень по умолчанию - самый низший **Read Committed**

Итого:

* уровень **Read Committed**:
    - SELECT видит снимок БД на момент выполнения каждого оператора внутри транзакции
    - никогда не увидит незафиксированных изменений или изменений, внесенных паралелльными транзакциями в процессе выполнения запроса (НЕ транзакции)
    - два последовательных SELECT могут видеть разные данные, если были зафиксированные транзакции
    - если две транзакции выполняют изменение / удаление одной строки, вторая транзакция будет ожидать результата первой и работать с обновленной версией строки
    - есть варианты выполнения команды INSERT: ON CONFLICT DO UPDATE и ON CONFLICT DO NOTHING
* уровень **Repeatable Read**:
    - снимок БД фиксируется на момент первого оператора в транзакции (не BEGIN)
    - если две транзакции выполняют изменение / удаление одной строки, вторая транзакция будет ожидать результата первой, и в случае фиксации первой - выдаст ошибку.
* уровень **Serializable**:
    - точно также получаем ошибку при параллельной записи
    - чтобы работал, все транзакции должны быть на уровне Serializable

#### 1.1.4 Команды для работы с транзакциями

Выполнение в транзакции:

    BEGIN;
    ....
    ROLLBACK;
    COMMIT;

Установка уровня изолированности:

    BEGIN;
    # первая комманда после начала транзакции
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
    # или сразу
    BEGIN ISOLATION LEVEL READ UNCOMMITTED;

Просмотр уровня транзакции:

    SHOW transaction_isolation;
    # по умолчанию:
    SHOW default_transaction_isolation; 

#### 1.1.5 Примеры работы

Блокировки параллельных транзакций при записи: 

    # уровень Read Committed
    T1: BEGIN;
    T1: UPDATE t SET n = 4;
    T2: BEGIN;
    T2: UPDATE t SET n = n + 10;
    # т. к. нельзя допустить lost updates, T2 блокируется и ждет результата T1
    # аналогично для DELETE
    # при этом если удаление по условию выполняется и в результате другой транзакции это условие перестает выполнятся, удаления не произойдет
    # если 
    T1: COMMIT;
    T2: COMMIT; # здесь еще раз выполняется обновление строки
    SELECT * FROM t;
        n = 14;

Ошибка параллельных транзакций при записи:

    # уровень Repeatable Read;
    T1: BEGIN ISOLATION LEVEL REPEATABLE READ;
    T1: UPDATE t SET n = 4;
    T2: BEGIN ISOLATION LEVEL REPEATABLE READ;
    T2: UPDATE t SET n = 10;
    # Т2 ждет результата Т1
    Т1: COMMIT;
    # T2 тут же выдает ошибку: из-за запрета lost updates T2 должна перечитать данные, но уровень изоляции не позволяет этого сделать    



### 1.2 Страницы и версии строк

#### 1.2.1 Структура данных

##### 1.2.1.1 Структура страницы

Размер страницы по умолчанию 8 КБ. 

Таблицы, индексы и другие объекты используют одинаковую структуру страниц, чтобы пользоваться общим буферным кешем.

Структура страницы:

* вначале - блок указателей (24 байта) - общие сведения, размер других областей
* указатели - каждый указатель 4 байта, указывает на позицию версии строки (**tuple**) на странице
* собственно версии строк расположены в конце страницы

Косвенная адресация позволяет например перемещать строки, не ломая индексы

Страницы попадают в буферный кеш прямо с диска, без преобразований. Поэтому нет совместимости между разными платформами (разрядность, порядок байт).

При хранении данных используется выравнивание по границам машинных слов (32-битные - 4 байта, 64-х - 8 байт). Поэтому правильное расположение колонок может дать некоторую экономию.    

##### 1.2.1.2 Указатели

Содержат:

* ссылку на версию строки
* длину этой версии
* несколько бит, определяющих статус версии
    - примеры статусов: `normal`, `dead` (версия строки удалена, но указатель используется чем-то извне), `unused` (указатель и версия удалены)
    - изменяют статусы например `VACUUM`, внутристраничная очистка

##### 1.2.1.3 Версии строк

Состоят из заголовка и данных.

Заголовок:

* **xmin**, **xmax** - определяют видимость версий в терминах номеров транзакций
* **ctid** - ссылка на следующую версию строки, у актуальной версии - на себя же. Формат: (номер страницы, номер указателя в массиве)
* ряд битов **infomask**

Структура индексных страниц сильно зависит от типа индекса. Но обычно также содержит указатели на версии строк **ctid**. Не содержит никаких данных о версиях строк (нет полей xmax, xmin).




#### 1.2.2 Выполнение операций

**Вставляется строка в транзакции**

* Начинается транзакция, добавляется строка:
    - создается указатель с номером 1 на версию строки
    - в версии строки **xmin** содержит номер транзакции (100 например)
    - **xmax** пустой и бит **xmax_aborted** установлен в истину, т. е. другие транзакции будут игнорировать **xmax**
    - в журнале XACT для 100 транзакции биты не установлены (транзакция еще активна)
    - **ctin** ссылается на эту же строку
* Транзакция фиксируется
    - в журнале XACT у транзакции № 100 устанавливается бит **committed**
    - больше ничего не меняется, транзакция завершена

**Другая транзакция пытается прочитать строку**:

*  Видит версию строки с номером транзакции 100. Нужно понять в каком состоянии эта транзакция
    -  проверяет статус транзакции: активна или завершилась. Для этого есть структура в памяти ProcArray
    -  если завершилась - проверяет фиксацией или отменой по битам журнала XACT
    -  чтобы повторно не выполнять это, устанавливает информационные биты в версии строки **xmin committed** или **xmin aborted**. Последующие транзакции будут анализировать только эти биты

Почему только следующая транзакция устанавливает эти биты, а не исходная? Нужно запоминать какие строки, на каких страницах, страницы могут быть уже не в кеше.

Следствие: операции чтения могут вызывать записи на диск (когда обновляются биты во время первого чтения после записи).

**Удаление строки**

* в **хmax** записывается номер текущей транзакции (выступает также как признак блокировки, если транзакция активна)
* бит **xmax_aborted** сбрасывается
* транзакция завершается, больше ничего не происходит
* последующее чтение:
    - проверит статус транзакции в XACT
    - установит бит **xmax committed** или **xmax aborted**

**Обновление строки**

* удаляется предыдущая версия строки
    - все то же, что при удалении обычном
* записывается новая
    - аналогично обычной вставке
    - обновляется **ctid**


#### 1.2.3 Точки сохранения и вложенные транзакции

**Точка сохранения** - возможность откатить часть транзакции.

    BEGIN;
    INSERT ...
    SAVEPOINT sp;
    DELETE ...
    ROLLBACK TO sp;
    ....
    COMMIT;


Реализованы через вложенные транзакции. От начала до точки сохранения одна, от точки до конца - другая. При возврате к точке просто меняется статус в XACT.

Вложенные транзакции имеют номер больший чем основная. Могут иметь свой статус. Но при откате основной, откатываются и они.

Информация о вложенности хранится в `$PGDATA/subtrans/`

### 1.3 Снимки данных и горизонт событий

#### 1.3.1 Снимки данных

**Снимки данных** нужны для транзакций и определяют какие версии строк видны, а какие нет.

Для уровня **Read Committed** снимок создается в начале каждого оператора транзакции и активен, пока этот оператор выполняется.

Для уровней **Repeatable Read** и **Serializable** создается один раз в начале первого оператора и активен до конца транзакции.

Видна версия строки в снимке или нет: на основе **xmin** и **xmax**. Эти номера не пересекаются, поэтому в одном снимке - максимум одна версия строки.

Транзакции видные в снимке, если это та же самая транзакция или транзакция зафиксирована до начала снимка.

Чем определяется снимок:

* моментом создания снимка - номер следующей, еще не существующей транзакции (**xmax снимка**)
* списком активных транзакций на момент создания снимка (зная номер транзакции, можем понять ее состояние, но когда она точно завершилась неизвестно (в момент создания снимка или чуть позже). Поэтому нужен список активных транзакций на момент создания снимка.)
* для удобства **xmin** самой ранней активной транзакции

Просмотр снимка: функция `txid_current_snapshot()`, возвращает список xid, разделенных `:`:

* xmin - минимальная транзакция на момент создания снимка
* xmax - номер следущей (еще не существующей транзакции)
* список активных транзакций

#### 1.3.2 Горизонт событий

**xmin** самой ранней активной транзакции снимка определяет **горизонт событий** для транзакции. За горизонтом событий транзакция видит только актуальные версии строк.

Аналогично для всей БД - **горизонт событий** определяется через самый ранний **xmin** снимка всех активных транзакций. За горизонтом событий БД неактуальные версии строк больше не увидит ни одна транзакция и их можно удалять.

**Удержание горизонта событий**: любая транзакция (даже Read Committed) удерживает горизонт БД, препятствуя очищению.

Можно управлять параметрами:

* `old_snapshot_treshold` - определяет максимальное время жизни снимка. При превышении - сервер получает право удалять неактуальные версии. Если транзакция обращается к этим данным - ошибка `snapshot too old`
* `idle_in_transaction_session_timeout` - прерывает транзакции в бездействии по истечении указанного времени

Посмотреть можно через системную таблицу:

    SELECT backend_xmin FROM pg_stat_activity WHERE pid = pg_backend_pid();


#### 1.3.3 Виртуальные транзакции

Если транзакция только читает данные, она никак не может изменить видимость версий строк. Поэтому любой транзакции сначала можно выдать **виртуальный номер (virtual xid)**. 

Он выдается текущим процессом, не требует синхронизации и поэтому быстро дается. Если выполняется запись в транзакции, тогда ей уже присваивается настоящий номер.

Функция `txid_current()` возвращает номер транзакции (если виртуальный - создает реальный и возвращает его)

Функция `txid_current_if_assigned()` возвращает реальный номер, только если он назначен


#### 1.3.4 Экспорт снимка

Если несколько параллельных транзакций должны видеть одинаковую картину данных. Например `pg_dump`, работающий параллельно.

Функция `pg_export_snapshot` возвращает идентификатор снимка.

Он может быть передан в другую транзакции через `SET TRANSACTION SNAPSHOT`. Можно только в Repeatable Read или в Serializable транзакции (в Read Committed снимки на каждый оператор создаются)


### 1.4 HOT-обновления

При работе с таблицей в индексе создаются ссылки на все версии строк.

Поэтому например таким может быть индекс на строковую колонку (одна строка, разные версии):

    ctid    |   ключ
    (0, 2)  |   BAR    
    (0, 3)  |   BAZ    
    (0, 1)  |   FOO    

Проблемы при таком подходе:

* при любом изменении строки (когда новые версии появляются) необходимо обновлять все индексы, даже если изменяемые колонки не входят в индекс
* индексы хранят ссылки на устаревшие версии, нужно очищать

Режим **HOT-обновления** решает эти проблемы индексов **для колонок, которые не меняются при изменении строки**:

* в индексах создается только одна запись со ссылкой на первую версию строки
* внутри страницы создается цепочка версий:
    - измененные строки, входящие в цепочку обозначаются битом **heap hot updated**
    - строки, на которых нет ссылок в индексе обозначаются битом **heap only tuple** (т. е. только табличная версия строки)
    - версии строк связаны обычным образом через **ctid**

Если сервер из индекса попадает на строку с битом **heap hot update**, он будет идти по цепочке и проверять видимость версий

Цепочка версий HOT-обновления может располагаться только в пределах одной страницы. В этом случае получаем высокую производительность. Если на странице места нет - цепочка прерывается, версия сохраняется на другой странице и для нее создается новая запись в индексе. 

Поэтому **при частом изменении неиндексируемых колонок** можно зарезервировать свободное место на странице через параметр `fillfactor` (100% - 10%). По достижении заданного процента вставка новых строк в эту страницу будет запрещена, но могут добавляться версии строк для выстраивания цепочек.


### 1.5 Внутристраничная очистка

Может выполняться, если:

* обновление не обнаружило места для вставки новой версии строки
* страница заполнена больше, чем `fillfactor`

Работает строго в пределах одной страницы (скорость). Может вызываться как при записи, так и просто при чтении (`SELECT`).

Что делает:

* удаляет версии строк, находящиеся за горизонтом событий.
* меняет статус указателей на удаленные версии строк (конкретный статус зависит: HOT-цепочка или нет)
* карта свободного простанства не обновляется (свободные места лучше под обновления, а не вставки)
* карта видимости не обновляется
* сдвигает строки для уменьшения фрагментации

Если версии не входят в HOT-цепочку, статус указателя устанавливается в `dead`. Сами указатели не удаляются, ведь на них могут быть ссылки (из индексов например или из других страниц). Если входит в HOT-цепочку: середину цепочки можно удалять (статус `unused`, ссылок нет). Указатель на начало цепочки получает статус `redirect` (на этот указать есть ссылка в индексе) и перенаправляет на актуальную версию строки цепочки.

### 1.6 Очистка

#### 1.6.1 Обычная очистка

##### 1.6.1.1 Команда VACUUM

Выполняется командой `VACUUM`

Очищает таблицу полностью и ее индексы. Работает в фоновом режиме и 
не блокирует работу с таблицей (кроме удаления таблицы, создания индексов и т. п.) 

Что делает:

* удаляет ненужные версии строк (используя карту видимости, где указаны страницы с полностью актуальными версиями)
* очищает индексные записи, ссылающиеся на очищенные версии
* освобождает указатели
* обновляет карту свободного пространства
* обновляет карту видимости

Как работает:

* сканирует таблицу, пропуская страницы, отмеченные в карте видимости
* в прочитанных страницах выявляет ненужные версии строк и записывает их идентификаторы (в формате `(станица, № указателя)`) в специальную область памяти
* размер этой области - параметр `maintenance_work_mem` (64 КБ по умолчанию)
* если область заполнена или вся таблица просмотрена начинает очищать индексы
* для этого **полностью** читается индексная таблица и удаляются записи, ссылающиеся на версии отобранные в специальную область
* очищает строки и указатели в страницах таблицы
* если область `maintenance_work_mem` была заполнена полностью, очищает ее, заполняет идентификаторами и повторяет цикл

Таким образом при больших размерах таблицы / редкой очистке индексы могут читаться по нескольку раз, что нагружает систему. Выход: чаще выполнять очистку или увеличить `maintenance_work_mem`.

##### 1.6.1.2 Мониторинг работы VACUUM

Вариант - вызвать `VACUUM VERBOSE`

Другой способ - просмотр представления `pg_stat_progress_vacuum`

На каждый процесс очистки (в т. ч. автоочистка, но кроме `VACUUM FULL`) будет запись с информацией:

* `heap_blks_vacuumed` - число очищенных страниц
* `heap_blks_total` - общее число страниц
* `index_vacuum_count` - количество циклов очистки (если не хватает `maintenance_work_mem`)
* и др.

##### 1.6.1.3 Управление нагрузкой

Для уменьшения нагрузки можно запускать порциями, чередуя работу и паузы:

Параметры для настройки:

* `vacuum_cost_limit` - примерный объем работы для одной порции в условных единицах (200 по умолчанию)
* `vacuum_cost_delay` - время паузы в мс (0 по умолчанию - если вызвали VACUUM, значит надо)

Примерные единицы работы: 1 - обработка страницы в кеше, 10 - на диске, 20 - грязной страницы




#### 1.6.2 Полная очистка

Запускается `VACUUM FULL`.

Полностью блокирует работу с таблицей. Также очищает ненужные версии строк, но при этом перестраивает таблицу и индексы, путем создания новых файлов и заполнения их (обычная очистка просто освобождает место в файлах, не уменьшая их). 

Для перестройки таблицы требуется дополнительное место для копирования. После перестройки таблица находится в новых файлах, хотя OID сохраняется.

Если нужна очистка без блокировки, можно посмотреть стороннее расширение **pg_repack**

Похожие команды:

* **CLUSTER** дополнительно упорядочивает строки по одному индексу. Это ускорит работу (но следующие записи нарушат упорядоченное состояние, подойдет для редко изменяемых таблиц)
* **REINDEX** - перестраивает индекс
* **TRUNCATE** - очищает таблицу. В отличие от **DELETE** не просто помечает строки, а физически создает новый чистый файл для таблицы


### 1.7 Автоочистка

#### 1.7.1 Autovacuum launcher 

Запуск очистки в зависимости от количества изменений в таблицах.

Процесс **autovacuum launcher** постоянно отслеживает активность и просит **postmaster** запускать рабочие процессы **autovacuum worker**, которые проверяют таблицы и выполняют очистку. Рабочих процессов может быть несколько.

Конфигурационные параметры процесса **autovacuum launcher**:

* **autovacuum = on** - собственно включает автоочистку
* **track_counts** - включает сбор статистики, без нее не будет оснований для запуска очистки
* **autovacuum_naptime** - интервал для запуска рабочих процессов (для каждой БД отдельно отсчитывается). По умолчанию - 60 сек.
* **autovacuum_max_workers** - максимальное количество рабочих процессов на кластер (3 по умолчанию)

Рабочий процесс подключаются к базе данных, сканирует (?? или по данным анализа) таблицы и определяет таблицы для которых нужна очистка и / или анализ. В одной БД может несколько процессов работать, но с разными таблицами. 

#### 1.7.2 Настройки порога срабатывания рабочих процессов 

Порог срабатывания:

    число ненужных версий > autovacuum_vacuum_threshold + autovacuum_vacuum_scale_factor * количество строк в таблице

**autovacuum_vacuum_threshold** - допускаемый минимум мертвых версий строк, по умолчанию - 50

**autovacuum_vacuum_scale_factor** - процент строк, при котором срабатывает автоочистка (20% по умолчанию)

Число строк определяется по статистике: общее число - **pg_class.reltuples**, число ненужных - **pg_stat_all_tables.n_dead_tup** 

Порог срабатывания по умолчанию - примерно при 20% изменения таблицы. Для больших таблиц это может быть редко и занимать длительное время. Те же пороговые параметры можно для отдельной таблицы задавать (основной и TOAST отдельно) или отключать автоочистку для таблицы.

    # установка параметров:
    ALTER SYSTEM SET autovacuum_analyze_scale_factor = 0.02;
    SELECT pg_reload_conf();
    # параметры на уровне таблицы:
    ALTER TABLE tvac SET (autovacuum_enabled = on);
    ALTER TABLE tvac SET (autovacuum_vacuum_scale_factor = 0.01);
    # посмотреть параметры на уровне таблицы
    SELECT unnest(reloptions) FROM pg_class WHERE relname = 'tvac';

Аналогичные параметры есть для анализа (общие и на уровне таблицы): **autovacuum_analyze_threshold** (50 по умолчанию) и **autovacuum_analyze_scale_factor** (10%). Toast таблицы не анализируются.

#### 1.7.3 Регулирование нагрузки от autovacuum worker

Конфигурационные параметры:

* **autovacuum_vacuum_cost_limit** - **общий** объем работы для всех рабочих процессов в условных единицах (-1 по умолчанию, т. е. равен **vacuum_cost_limit** (200)). Значение 200 - мало, можно повышать до 1000-2000. Т. к. это общий объем работы, при увеличении **autovacuum_max_workers**, нужно увеличивать и его.
* **autovacuum_vacuum_cost_delay** - по умолчанию - 20 мс, при -1 равен **vacuum_cost_delay**.

Можно задавать на уровне отдельных таблиц.

Для управления памятью - **autovacuum_work_mem**. Значение по умолчанию = -1 (используется значение памяти для фоновых процессов **maintenance_work_mem** 64КБ). Эта память выделяется сразу и на каждый рабочий процесс. За счет увеличения памяти можно снизить число чтений индексов. Или чаще выполнять очистку, чтобв меньше данных обрабатывалось.

#### 1.7.4 Подходы к настройке системы очистки

Итеративный процесс поиска баланса между разрастанием таблиц и накладными расходами.

Увеличение threshold/scale_factor: разрастание таблиц, но меньшие суммарные накладные расходы. Хотя пиковые нагрузки могут быть. Уменьшение - меньше растут таблицы, увеличиваются накладные расходы.

Снижение пиковых нагрузок: уменьшение cost_limit/cost_delay. Это приводит к уменьшению скорости очистки, что может вызывать задержки в очистке. Тогда можно увеличивать число рабочих процессов max_workers

Мониторить: разрастание таблиц, очередь таблиц, ожидающих очистки, нагрузка на дисковую подсистему.






### 1.8 Заморозка

#### 1.8.1 Суть процесса заморозки 

Для номера транзакций используется 32-битный счетчик. Чтобы избежать переполнения, счетчик закольцован. Номера транзакций в половине по часовой стрелке считаются старшими и находящимися в будущем, против часовой - в прошлом. При этом нужно освобождать / помечать номера транзакций, находящиеся в прошлом, иначе окажется что старые транзакции окажутся в будущем (например при десятичном счетчике в 1 знак: 8, затем 9, затем 1, а 2 теперь в будущем?)

**Возраст транзакции** - число транзакций, прошедших с момента появления этой транзакции (всегда знаем номер текущей транзакции). Можно посмотреть через функцию:

    SELECT relfrozenxid, age(relfrozenxid) FROM pg_class WHERE relname = 't';

Заморозкой занимается процесс очистки. Находит транзакции, достаточно старые и видные во всех транзакциях и помечает их ("замораживает"). Такие строки считаются старше всех других и всегда видны в снимках. Их номера транзакций больше не проверяются и могут использоваться для новых транзакций.

**Признак заморозки**: одновременно установленные биты **xmin committed** и **xmin aborted**. Xmax замораживать не нужно: если он задан, значит эта версия не актуальна и будет удалена вскоре. В версиях < 9.4 признаком заморозки был номер транзакции = 2.

Если сервер увидит, что не заморооженные транзакции рискуют попасть в будущее (очистка по каким-то причинам не смогла заморозить) - аварийно останавливается. Нужно запускаться в монопольном режиме и выполнять очистку.

#### 1.8.2 Настройка заморозки

Конфигурационные параметры:

* **vacuum_freeze_min_age** - минимальный возраст транзакции **xmin**, при котором можно замораживать. Малое значение - ведет к накладным расходам (строку заморозили, но она потом изменилась и ее удалят, заморозка впустую). Такая очистка не смотрит на страницы, отмеченные в карте видимости (только с актуальными версиями строк)
* **vacuum_freeze_table_age** - возраст транзакции, при котором пора выполнять заморозку на всех страницах. Каждая таблица хранит номер последней замороженной транзакции `pg_class.relfrozenxid`. В карте видимости есть бит, отмечающий страницы с замороженными версиями.

Каждая таблица будет морозится раз в 

    (vacuum_freeze_table_age - vacuum_freeze_min_age)

транзакций. Т. е. большое значение **vacuum_freeze_min_age** увеличивает частоту заморозки и накладные расходы.

**autovacuum_freeze_max_age** - максимальный возраст, при котором будет принудительно запущена заморозка, даже если автоочистка отключена. Также определяет размер области для записей XACT.

Хранится на уровне БД (как минимальный номер замороженной транзакции из таблиц ):

    SELECT datfrozenxid, age(datfrozenxid) FROM pg_database WHERE datname = 'postgres';


Значения по умолчанию:

* **vacuum_freeze_min_age** - 50кк
* **vacuum_freeze_table_age** - 150кк
*  **autovacuum_freeze_max_age** - 200кк (стоит увеличить)

Параметры можно устанавливать на уровне отдельных таблиц.

#### 1.8.3 Ручная заморозка

    VACUUM FREEZE

Замораживает все версии строк, несмотря на возвраст (**vacuum_freeze_min_age = 0**)

Также строки замораживаются при `VACUUM FULL` или `CLUSTER`




## 2. Журналирование

### 2.1 Буферный кеш

#### 2.1.1 Внутреннее устройство

Для сглаживания работы дисков/памяти. Для чтения / записи процессы читают страницы в память. Буферный кеш - общая память для сервера, 

Устройство:

* массив буферов
* список свободных буферов
* хеш-таблица страниц в кеше (номер буфера по имени файла и номеру страницы)
* ссылка на следующую жертву

Каждый буфер - собственно страница и заголовок. Заголовок содержит:

* расположение страницы на диске (файл, номер страницы)
* число обращений к буферу (+1 за каждое обращение любого процесса, но не > 5)
* признак, что данные изменены (грязный буфер)
* признак закрепленности: счетчик, означает что с буфером работают

#### 2.1.2  Процесс чтения в свободный буфер

* процесс ищет страницу в буфере по хеш-таблице
* если нет, ищется свободный буфер через список свободных буферов
* в найденном свободном буфере увеличивается счетчик закреплений, счетчик обращений, читается страница с диска.
* в хеш-таблицу записывается ссылка на буфер

#### 2.1.3 Процесс чтения с вытеснением

* нужно найти страницу для вытеснения из буфера
    - начиная со ссылки на жертву, алгоритм обходит массив буферов, уменьшая счетчик обращений на 1.
    - как только найден буфер с нулевым счетчиком, он вытесняется. Таким образом часто используемые буферы вытесняются в последнюю очередь
    - чтобы слишком много циклов не накручивалось, счетчик обращений не превышает 5
* если буфер закреплен, счетчик обращения уменьшается, но буфер оставляется
* если буфер для вытеснения - грязный:
    - буфер закрепляется, чтобы другие процессы не пытались вытеснить тоже
    - записывается на диск (на самом деле в кеш ОС)
* в свободный теперь буфер читаются данные с диска
* ссылка на жертву устанавливается на следующий буфер, поэтому текущий может успеть нарастить счетчик обращений

#### 2.1.4 Массовое вытеснение

При массовой записи / чтении есть шанс забить кеш одноразовыми страницами  и вытеснить полезные страницы.

Для таких операций используются **буферные кольца**: выделяется часть кеша и вытеснение происходит только в пределах этого кольца.

При последовательном чтении, если попадаются грязные буферы: отключаются от кольца, на диск не записываются. На диск будут записаны на общих основаниях. Сделано для ускорения процесса чтения.

Подключение процессов: если во время чтения другому процессу требуются те же данные, этот процесс может подключится к тому же кольцевому буферу. По окончании чтения дочитает начало самостоятельно.

Размеры кольцевых буферов:

* последовательное чтение - 32 буфера
* очистка - 32 буфера
* массовая запись (COPY) - <= 2048 буферов



#### 2.1.5 Настройка размера кеша

Параметр **shared_buffers**. По умолчанию - 128МБ, сильно занижено, надо увеличивать.

Начать можно с 1/4 оперативной памяти. 

Можно проанализировать счетчик обращений (usage count). Большие значения у всех буферов - признак частого вытеснения. С другой стороны большой размер - накладные расходы.

Для временных таблиц буферный кеш не используется. Такие таблицы нужны только в пределах одного сеанса. Для них используется локальный кеш (параметр **temp_buffers**)


#### 2.1.6 Прогрев буферного кеша

После перезагруки сервера кеш пустой и начало работы будет сопровождаться массовым чтением с диска

Расширение **pg_prewarm** может заполнять данные определенных таблиц в кеш или загружать сохраненное ранее состояние кеша.


### 2.2 Журнал предзаписи WAL

#### 2.2.1 Основы

Задача журнала предзаписи - восстановление согласованности БД при сбоях и потере содержимого буферного кеша.

Суть: одновременно с изменением данных на странице в буферном кеше в журнале создаются запись об изменениях, достаточная для повторения этой операции. Эта запись обязательно попадает на диск до того, как страница попадет на диск. Отсюда - журнал предварительной записи (Write Ahead Log)

Что попадает в WAL - все операции, для которых есть риск потери из оперативной памяти:

* изменения страниц в буферном кеше (таблицы и индексы)
* записи о транзакциях в буфере XACT
* файловые операции (создание, удаление файлов)

Не журналируются:

* временные таблицы
* таблицы, для которых явно указано, что не нужно

#### 2.2.2 Логическое устройство

Набор записей разной длины. Каждая запись - заголовок и данные.

Заголовок содержит:

* номер транзакции, к которой относится запись
* менеджер ресурсов - компонент системы, ответственный за эту запись
* контрольную сумму

Данные имеют разную структуру, определяется менеджером ресурсов. Например для таблиц - это двоичные данные, которые нужно записать поверх страницы с определенного смещения, чтобы получить изменения.

Каждая запись идентифицируется **LSN** (Log Sequence Number) тип **pg_lsn**. Это просто 64-битное смещение до записи от начала журнала.

#### 2.2.3 Физическое устройство

Файлы в каталоге `$PGDATA/pg_wal`. Размер файла - 16МБ. Записи добавляются в один файл, когда заполняется - создается новый.

Есть кеш журнала в памяти. Размер - параметр **wal_buffers**. По умолчанию - 1/32 буферного кеша. Кеш работает по принципу кольчевого буфера: запись в начало буфера, запись на диск - с хвоста.

#### 2.2.4 Порядок работы журнала

* какая-либо страница буферного кеша изменяется
* формируется запись журнала и помещается в буфер журнала
* одновременно lsn записи помещается в заголовок страницы буферного кеша
    - текущую lsn для вставки можно узнать через `pg_current_wal_insert_lsn()`
* указатель `pg_current_wal_insert_lsn` сдвигается вперед
* например происходит фиксация транзакции
* формируется запись журнала для страницы XACT
* на страницу XACT помещается lsn
* в какой-то момент (связано с контрольными точками) записи журнала попадают на диск
    - функция `pg_current_wal_lsn()` показывает последнюю запись, попавшую на диск
* только после этого можно страницы записывать на диск
* проверяется что lsn страницы (последняя запись) меньше `pg_current_wal_lsn()`
* если вдруг страницу нужно записать на диск (например вытеснение), а записи журнала еще в буфере - журнальные буферы записываются принудительно

Пример функций:

    SELECT pg_current_wal_insert_lsn();
        0/1C349E8
    # в каком файле
    SELECT pg_walfile_name('0/1C349E8');
        000000010000000000000001
    # просмотр файлов журнала
    SELECT * FROM pg_ls_waldir() LIMIT 10;
    # просмотр lsn в заголовке страницы (pageinspect)
    SELECT lsn FROM page_header(get_raw_page('t',0));

#### 2.2.5 Восстановление после сбоя

При запуске сервера запускается процесс **startup**. Анализирует файл `$PGDATA/global/pg_control` (двоичный, просмотр через pg_controldata) и если там статус отличный от `shut down` значит произошел сбой (нормальное завершение просто запишет в этот файл статус `shut down`)

Дальше последовательно читает записи WAL и если надо, применяет их к страницам. Когда надо применять: если lsn на странице (последняя запись, связанная со страницей) меньше чем lsn записи журнала. Изменения страниц происходит как обычно в буферном кеше.

Нежурналируемые таблицы перезаписываются образами из init-файлов (очищаются по сути).

С какого места журнала начинать восстановление - контрольные точки.




### 2.3 Контрольные точки

#### 2.3.1 Обзор механизма контрольных точек 

Если страница в кеше активно используется она может не выдесняться на диск. Это значит что при воссиановлении придется просматривать много журнальных записей.

Это ведет к разрастанию журнала и увеличение времени восстановления.

Фоновый процесс **checkpointer** создает контрольные точки, периодически записывая грязные страницы на диск (в кеше при этом остаются). После завершения создания контрольной точки, записи журнала до начала контрольной точки не нужны.

#### 2.3.2 Процесс создания контрольной точки

* На диск сбрасываются буферы статуса транзакций XACT. Их 128 штук, поэтому однократная операция
* Выполняется запись страниц буферного кеша:
    - сначала все измененные страницы помечаются специальным флагом в заголовке. Так формируется набор страниц для контрольной точки
    - затем постепенно сбрасывает помеченные страницы на диск и снимает флаг. Счетчик закреплений и счетчик обращений никак не затрагивается, т. к. страницы не убираются из кеша
    - также страницу может записать серверные процессы. Сбрасывают флаг при этом, чтобы повторно не записывал **checkpointer**.
* после записи всех отмеченных страниц, создается запись в журнале о создании контрольной точки. Запись содержит LSN той записи, с которой началось создание контрольной точки. Сам факт начала формирования контрольной точки нигде не фиксировался.
* в файл `$PGDATA/global/pg_control` добавляется указатель на эту созданную запись. Таким образом определяем последнюю контрольную точку. Некоторые версии PostgreSQL еще содержат запись о предыдущей точке.

Процесс записи грязных страниц на диск растягивается по времени. За это отвечает параметр **checkpoint_completion_target**: доля времени между двумя контрольными точками, в которое происходит запись буферов. По умолчанию 0.5, можно поднимать до ~0.9, чтобы распределить нагрузку.


## 99. Вопросы для анализа БД

* Сколько строк в таблице - **pg_class.reltuples** (статистикой обновляется)
* Сколько мертвых строк - **pg_stat_all_tables.n_dead_tup**
* Когда анализ был последний раз, как часто - **pg_stat_all_tables**
* Когда очистка была, как часто - **pg_stat_all_tables**

**Размер таблицы: общий, свободный**

    SELECT pg_size_pretty(pg_table_size('t'));

* разрастание таблиц

**очередь таблиц, ожидающий очистки**
    
    можно вычислить порог

    CREATE VIEW vacuum_v AS
        WITH params AS (
          SELECT (SELECT setting::integer
                  FROM   pg_settings
                  WHERE  name = 'autovacuum_vacuum_threshold') AS vacuum_threshold,
                 (SELECT setting::float
                  FROM   pg_settings
                  WHERE  name = 'autovacuum_vacuum_scale_factor') AS vacuum_scale_factor
        )
        SELECT st.relname,
               st.n_dead_tup dead_tup,
               (p.vacuum_threshold + p.vacuum_scale_factor*c.reltuples)::integer max_dead_tup,
               st.n_dead_tup > (p.vacuum_threshold + p.vacuum_scale_factor*c.reltuples)::integer need_vacuum,
               st.last_autovacuum
        FROM   pg_stat_all_tables st,
               pg_class c,
               params p
        WHERE  c.oid = st.relid
        AND    c.relname = 'tvac';

**Просмотр параметров автоочистки, установленные на уровне таблицы**

     SELECT unnest(reloptions) FROM pg_class WHERE relname = 'tvac';

**Просмотр возраста транзакции для заморозки**

    # по всем БД
    SELECT datname, datfrozenxid, age(datfrozenxid) FROM pg_database;
    # по таблицам БД
    SELECT relname, relfrozenxid, age(relfrozenxid) FROM pg_class;

**Анализ буферного кеша**

Просмотр количества счетчика обращений у страниц. Большие значения у всех буферов - признак частого вытеснения. Можно смотреть через расширение **pg_buffercache**.

    CREATE EXTENSION pg_buffercache;
    
    SELECT usagecount, count(*) FROM pg_buffercache GROUP BY usagecount ORDER BY usagecount;

Но часто (в мониторинге) нельзя использовать - блокирует кеш для анализа.

**Как растет журнал предзаписи**

Разница между двумя вызовами `pg_current_wal_lsn()` в байтах

    SELECT '0/1C34A54'::pg_lsn - '0/1C349E8'::pg_lsn;

**Просмотр журнала предзаписи**

утилита **pg_waldump**
    
    pg_waldump -p /usr/local/pgsql/data/pg_wal -s 0/1C349E8 -e 0/1C34A54 000000010000000000000001   

**Размер журнала предзаписи**

    select pg_size_pretty(SUM(size)) from pg_ls_waldir();

**Просмотр текущего состояния сервера (pg_control)**

Утилита **pg_controldata**