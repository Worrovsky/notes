## Содержание

<!-- MarkdownTOC autolink="true" uri_encoding="false" levels="2,3" -->

- [1. Многоверсионность](#1-Многоверсионность)
    - [1.1 Транзакции](#11-Транзакции)
    - [1.2 Страницы и версии строк](#12-Страницы-и-версии-строк)
    - [1.3 Снимки данных и горизонт событий](#13-Снимки-данных-и-горизонт-событий)
    - [1.4 HOT-обновления](#14-hot-обновления)
    - [1.5 Внутристраничная очистка](#15-Внутристраничная-очистка)
    - [1.6 Очистка](#16-Очистка)
    - [1.7 Автоочистка](#17-Автоочистка)
    - [1.8 Заморозка](#18-Заморозка)
- [2. Журналирование](#2-Журналирование)
    - [2.1 Буферный кеш](#21-Буферный-кеш)
    - [2.2 Журнал предзаписи WAL](#22-Журнал-предзаписи-wal)
    - [2.3 Контрольные точки](#23-Контрольные-точки)
- [99. Вопросы для анализа БД](#99-Вопросы-для-анализа-БД)

<!-- /MarkdownTOC -->

## 1. Многоверсионность

### 1.1 Транзакции

#### 1.1.1 Свойства транзакций

Транзакция - совокупность операций, которые переводят базу из одного корректного состояния в другое (**согласованность**), при условии, что транзакция выполнена полностью (**атомарность**) и без помех со стороны других транзакций (**изолированность**). (+ **долговечность**)

Согласованность состояния определяется ограничениями на уровне БД или семантикой приложения.

#### 1.1.2 Аномалии

Ослабление **изолированности** ведет к аномалиям:

* **грязное чтение** - транзакция Т2 читает данные незафиксированной транзакции Т1, при откате транзакции Т1 получается, что Т2 видела данные, которых не существовало.
* **неповторяющееся чтение (non-repeatable read)** - Т1 читает строку. Т2 изменяет или удаляет эту строку и фиксируется. Т1 снова читает строку и видит изменения
* **фантомное чтение** - Т1 читает набор строк по условию. Т2 добавляет строку, соответствующее условию и фиксируется. Т1 читает еще раз и видит новые строки.
* есть другие.

#### 1.1.3 Уровни изолированности

Стандарт SQL определяет уровни изолированности по аномалиям:

* **Read Uncommitted** - возможно грязное чтение и все другие аномалии
* **Read Committed** - грязное чтение невозможно, остальные возможны
* **Repeatable Read** - неповторяющееся чтение, грязное чтение невозможны, остальные возможны
* **Serializable** - никакие аномалии невозможны, как если бы последовательно транзакции выполнялись

Дополнительно: ни на каком уровне **не допускается потеря сделанных изменений в других транзакциях** (**lost updates**). Пример потерянного обновления: Т1 читает строку по условию, Т1 изменяет ее, Т2 читает ту же строку. Т2 изменяет. Т1 фиксируется. Т2 фиксируется. Изменения Т1 потеряны. БД не должны такого допускать.

Особенности PostgreSQL - более строгие ограничения:

* грязное чтение невозможно (многоверсионность), поэтому **Read Uncommitted** и **Read Committed** эквиваленты.
* **Repeatable Read** не допускает также фантомного чтения
* уровень по умолчанию - самый низший **Read Committed**

Итого:

* уровень **Read Committed**:
    - SELECT видит снимок БД на момент выполнения каждого оператора внутри транзакции
    - никогда не увидит незафиксированных изменений или изменений, внесенных паралелльными транзакциями в процессе выполнения запроса (НЕ транзакции)
    - два последовательных SELECT могут видеть разные данные, если были зафиксированные транзакции
    - если две транзакции выполняют изменение / удаление одной строки, вторая транзакция будет ожидать результата первой и работать с обновленной версией строки
    - есть варианты выполнения команды INSERT: ON CONFLICT DO UPDATE и ON CONFLICT DO NOTHING
* уровень **Repeatable Read**:
    - снимок БД фиксируется на момент первого оператора в транзакции (не BEGIN)
    - если две транзакции выполняют изменение / удаление одной строки, вторая транзакция будет ожидать результата первой, и в случае фиксации первой - выдаст ошибку.
* уровень **Serializable**:
    - точно также получаем ошибку при параллельной записи
    - чтобы работал, все транзакции должны быть на уровне Serializable

#### 1.1.4 Команды для работы с транзакциями

Выполнение в транзакции:

    BEGIN;
    ....
    ROLLBACK;
    COMMIT;

Установка уровня изолированности:

    BEGIN;
    # первая комманда после начала транзакции
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
    # или сразу
    BEGIN ISOLATION LEVEL READ UNCOMMITTED;

Просмотр уровня транзакции:

    SHOW transaction_isolation;
    # по умолчанию:
    SHOW default_transaction_isolation; 

#### 1.1.5 Примеры работы

Блокировки параллельных транзакций при записи: 

    # уровень Read Committed
    T1: BEGIN;
    T1: UPDATE t SET n = 4;
    T2: BEGIN;
    T2: UPDATE t SET n = n + 10;
    # т. к. нельзя допустить lost updates, T2 блокируется и ждет результата T1
    # аналогично для DELETE
    # при этом если удаление по условию выполняется и в результате другой транзакции это условие перестает выполнятся, удаления не произойдет
    # если 
    T1: COMMIT;
    T2: COMMIT; # здесь еще раз выполняется обновление строки
    SELECT * FROM t;
        n = 14;

Ошибка параллельных транзакций при записи:

    # уровень Repeatable Read;
    T1: BEGIN ISOLATION LEVEL REPEATABLE READ;
    T1: UPDATE t SET n = 4;
    T2: BEGIN ISOLATION LEVEL REPEATABLE READ;
    T2: UPDATE t SET n = 10;
    # Т2 ждет результата Т1
    Т1: COMMIT;
    # T2 тут же выдает ошибку: из-за запрета lost updates T2 должна перечитать данные, но уровень изоляции не позволяет этого сделать    



### 1.2 Страницы и версии строк

#### 1.2.1 Структура данных

##### 1.2.1.1 Структура страницы

Размер страницы по умолчанию 8 КБ. 

Таблицы, индексы и другие объекты используют одинаковую структуру страниц, чтобы пользоваться общим буферным кешем.

Структура страницы:

* вначале - блок указателей (24 байта) - общие сведения, размер других областей
* указатели - каждый указатель 4 байта, указывает на позицию версии строки (**tuple**) на странице
* собственно версии строк расположены в конце страницы

Косвенная адресация позволяет например перемещать строки, не ломая индексы

Страницы попадают в буферный кеш прямо с диска, без преобразований. Поэтому нет совместимости между разными платформами (разрядность, порядок байт).

При хранении данных используется выравнивание по границам машинных слов (32-битные - 4 байта, 64-х - 8 байт). Поэтому правильное расположение колонок может дать некоторую экономию.    

##### 1.2.1.2 Указатели

Содержат:

* ссылку на версию строки
* длину этой версии
* несколько бит, определяющих статус версии
    - примеры статусов: `normal`, `dead` (версия строки удалена, но указатель используется чем-то извне), `unused` (указатель и версия удалены)
    - изменяют статусы например `VACUUM`, внутристраничная очистка

##### 1.2.1.3 Версии строк

Состоят из заголовка и данных.

Заголовок:

* **xmin**, **xmax** - определяют видимость версий в терминах номеров транзакций
* **ctid** - ссылка на следующую версию строки, у актуальной версии - на себя же. Формат: (номер страницы, номер указателя в массиве)
* ряд битов **infomask**

Структура индексных страниц сильно зависит от типа индекса. Но обычно также содержит указатели на версии строк **ctid**. Не содержит никаких данных о версиях строк (нет полей xmax, xmin).




#### 1.2.2 Выполнение операций

**Вставляется строка в транзакции**

* Начинается транзакция, добавляется строка:
    - создается указатель с номером 1 на версию строки
    - в версии строки **xmin** содержит номер транзакции (100 например)
    - **xmax** пустой и бит **xmax_aborted** установлен в истину, т. е. другие транзакции будут игнорировать **xmax**
    - в журнале XACT для 100 транзакции биты не установлены (транзакция еще активна)
    - **ctin** ссылается на эту же строку
* Транзакция фиксируется
    - в журнале XACT у транзакции № 100 устанавливается бит **committed**
    - больше ничего не меняется, транзакция завершена

**Другая транзакция пытается прочитать строку**:

*  Видит версию строки с номером транзакции 100. Нужно понять в каком состоянии эта транзакция
    -  проверяет статус транзакции: активна или завершилась. Для этого есть структура в памяти ProcArray
    -  если завершилась - проверяет фиксацией или отменой по битам журнала XACT
    -  чтобы повторно не выполнять это, устанавливает информационные биты в версии строки **xmin committed** или **xmin aborted**. Последующие транзакции будут анализировать только эти биты

Почему только следующая транзакция устанавливает эти биты, а не исходная? Нужно запоминать какие строки, на каких страницах, страницы могут быть уже не в кеше.

Следствие: операции чтения могут вызывать записи на диск (когда обновляются биты во время первого чтения после записи).

**Удаление строки**

* в **хmax** записывается номер текущей транзакции (выступает также как признак блокировки, если транзакция активна)
* бит **xmax_aborted** сбрасывается
* транзакция завершается, больше ничего не происходит
* последующее чтение:
    - проверит статус транзакции в XACT
    - установит бит **xmax committed** или **xmax aborted**

**Обновление строки**

* удаляется предыдущая версия строки
    - все то же, что при удалении обычном
* записывается новая
    - аналогично обычной вставке
    - обновляется **ctid**


#### 1.2.3 Точки сохранения и вложенные транзакции

**Точка сохранения** - возможность откатить часть транзакции.

    BEGIN;
    INSERT ...
    SAVEPOINT sp;
    DELETE ...
    ROLLBACK TO sp;
    ....
    COMMIT;


Реализованы через вложенные транзакции. От начала до точки сохранения одна, от точки до конца - другая. При возврате к точке просто меняется статус в XACT.

Вложенные транзакции имеют номер больший чем основная. Могут иметь свой статус. Но при откате основной, откатываются и они.

Информация о вложенности хранится в `$PGDATA/subtrans/`

### 1.3 Снимки данных и горизонт событий

#### 1.3.1 Снимки данных

**Снимки данных** нужны для транзакций и определяют какие версии строк видны, а какие нет.

Для уровня **Read Committed** снимок создается в начале каждого оператора транзакции и активен, пока этот оператор выполняется.

Для уровней **Repeatable Read** и **Serializable** создается один раз в начале первого оператора и активен до конца транзакции.

Видна версия строки в снимке или нет: на основе **xmin** и **xmax**. Эти номера не пересекаются, поэтому в одном снимке - максимум одна версия строки.

Транзакции видные в снимке, если это та же самая транзакция или транзакция зафиксирована до начала снимка.

Чем определяется снимок:

* моментом создания снимка - номер следующей, еще не существующей транзакции (**xmax снимка**)
* списком активных транзакций на момент создания снимка (зная номер транзакции, можем понять ее состояние, но когда она точно завершилась неизвестно (в момент создания снимка или чуть позже). Поэтому нужен список активных транзакций на момент создания снимка.)
* для удобства **xmin** самой ранней активной транзакции

Просмотр снимка: функция `txid_current_snapshot()`, возвращает список xid, разделенных `:`:

* xmin - минимальная транзакция на момент создания снимка
* xmax - номер следущей (еще не существующей транзакции)
* список активных транзакций

#### 1.3.2 Горизонт событий

**xmin** самой ранней активной транзакции снимка определяет **горизонт событий** для транзакции. За горизонтом событий транзакция видит только актуальные версии строк.

Аналогично для всей БД - **горизонт событий** определяется через самый ранний **xmin** снимка всех активных транзакций. За горизонтом событий БД неактуальные версии строк больше не увидит ни одна транзакция и их можно удалять.

**Удержание горизонта событий**: любая транзакция (даже Read Committed) удерживает горизонт БД, препятствуя очищению.

Можно управлять параметрами:

* `old_snapshot_treshold` - определяет максимальное время жизни снимка. При превышении - сервер получает право удалять неактуальные версии. Если транзакция обращается к этим данным - ошибка `snapshot too old`
* `idle_in_transaction_session_timeout` - прерывает транзакции в бездействии по истечении указанного времени

Посмотреть можно через системную таблицу:

    SELECT backend_xmin FROM pg_stat_activity WHERE pid = pg_backend_pid();


#### 1.3.3 Виртуальные транзакции

Если транзакция только читает данные, она никак не может изменить видимость версий строк. Поэтому любой транзакции сначала можно выдать **виртуальный номер (virtual xid)**. 

Он выдается текущим процессом, не требует синхронизации и поэтому быстро дается. Если выполняется запись в транзакции, тогда ей уже присваивается настоящий номер.

Функция `txid_current()` возвращает номер транзакции (если виртуальный - создает реальный и возвращает его)

Функция `txid_current_if_assigned()` возвращает реальный номер, только если он назначен


#### 1.3.4 Экспорт снимка

Если несколько параллельных транзакций должны видеть одинаковую картину данных. Например `pg_dump`, работающий параллельно.

Функция `pg_export_snapshot` возвращает идентификатор снимка.

Он может быть передан в другую транзакции через `SET TRANSACTION SNAPSHOT`. Можно только в Repeatable Read или в Serializable транзакции (в Read Committed снимки на каждый оператор создаются)


### 1.4 HOT-обновления

При работе с таблицей в индексе создаются ссылки на все версии строк.

Поэтому например таким может быть индекс на строковую колонку (одна строка, разные версии):

    ctid    |   ключ
    (0, 2)  |   BAR    
    (0, 3)  |   BAZ    
    (0, 1)  |   FOO    

Проблемы при таком подходе:

* при любом изменении строки (когда новые версии появляются) необходимо обновлять все индексы, даже если изменяемые колонки не входят в индекс
* индексы хранят ссылки на устаревшие версии, нужно очищать

Режим **HOT-обновления** решает эти проблемы индексов **для колонок, которые не меняются при изменении строки**:

* в индексах создается только одна запись со ссылкой на первую версию строки
* внутри страницы создается цепочка версий:
    - измененные строки, входящие в цепочку обозначаются битом **heap hot updated**
    - строки, на которых нет ссылок в индексе обозначаются битом **heap only tuple** (т. е. только табличная версия строки)
    - версии строк связаны обычным образом через **ctid**

Если сервер из индекса попадает на строку с битом **heap hot update**, он будет идти по цепочке и проверять видимость версий

Цепочка версий HOT-обновления может располагаться только в пределах одной страницы. В этом случае получаем высокую производительность. Если на странице места нет - цепочка прерывается, версия сохраняется на другой странице и для нее создается новая запись в индексе. 

Поэтому **при частом изменении неиндексируемых колонок** можно зарезервировать свободное место на странице через параметр `fillfactor` (100% - 10%). По достижении заданного процента вставка новых строк в эту страницу будет запрещена, но могут добавляться версии строк для выстраивания цепочек.


### 1.5 Внутристраничная очистка

Может выполняться, если:

* обновление не обнаружило места для вставки новой версии строки
* страница заполнена больше, чем `fillfactor`

Работает строго в пределах одной страницы (скорость). Может вызываться как при записи, так и просто при чтении (`SELECT`).

Что делает:

* удаляет версии строк, находящиеся за горизонтом событий.
* меняет статус указателей на удаленные версии строк (конкретный статус зависит: HOT-цепочка или нет)
* карта свободного простанства не обновляется (свободные места лучше под обновления, а не вставки)
* карта видимости не обновляется
* сдвигает строки для уменьшения фрагментации

Если версии не входят в HOT-цепочку, статус указателя устанавливается в `dead`. Сами указатели не удаляются, ведь на них могут быть ссылки (из индексов например или из других страниц). Если входит в HOT-цепочку: середину цепочки можно удалять (статус `unused`, ссылок нет). Указатель на начало цепочки получает статус `redirect` (на этот указать есть ссылка в индексе) и перенаправляет на актуальную версию строки цепочки.

### 1.6 Очистка

#### 1.6.1 Обычная очистка

##### 1.6.1.1 Команда VACUUM

Выполняется командой `VACUUM`

Очищает таблицу полностью и ее индексы. Работает в фоновом режиме и 
не блокирует работу с таблицей (кроме удаления таблицы, создания индексов и т. п.) 

Что делает:

* удаляет ненужные версии строк (используя карту видимости, где указаны страницы с полностью актуальными версиями)
* очищает индексные записи, ссылающиеся на очищенные версии
* освобождает указатели
* обновляет карту свободного пространства
* обновляет карту видимости

Как работает:

* сканирует таблицу, пропуская страницы, отмеченные в карте видимости
* в прочитанных страницах выявляет ненужные версии строк и записывает их идентификаторы (в формате `(станица, № указателя)`) в специальную область памяти
* размер этой области - параметр `maintenance_work_mem` (64 КБ по умолчанию)
* если область заполнена или вся таблица просмотрена начинает очищать индексы
* для этого **полностью** читается индексная таблица и удаляются записи, ссылающиеся на версии отобранные в специальную область
* очищает строки и указатели в страницах таблицы
* если область `maintenance_work_mem` была заполнена полностью, очищает ее, заполняет идентификаторами и повторяет цикл

Таким образом при больших размерах таблицы / редкой очистке индексы могут читаться по нескольку раз, что нагружает систему. Выход: чаще выполнять очистку или увеличить `maintenance_work_mem`.

##### 1.6.1.2 Мониторинг работы VACUUM

Вариант - вызвать `VACUUM VERBOSE`

Другой способ - просмотр представления `pg_stat_progress_vacuum`

На каждый процесс очистки (в т. ч. автоочистка, но кроме `VACUUM FULL`) будет запись с информацией:

* `heap_blks_vacuumed` - число очищенных страниц
* `heap_blks_total` - общее число страниц
* `index_vacuum_count` - количество циклов очистки (если не хватает `maintenance_work_mem`)
* и др.

##### 1.6.1.3 Управление нагрузкой

Для уменьшения нагрузки можно запускать порциями, чередуя работу и паузы:

Параметры для настройки:

* `vacuum_cost_limit` - примерный объем работы для одной порции в условных единицах (200 по умолчанию)
* `vacuum_cost_delay` - время паузы в мс (0 по умолчанию - если вызвали VACUUM, значит надо)

Примерные единицы работы: 1 - обработка страницы в кеше, 10 - на диске, 20 - грязной страницы




#### 1.6.2 Полная очистка

Запускается `VACUUM FULL`.

Полностью блокирует работу с таблицей. Также очищает ненужные версии строк, но при этом перестраивает таблицу и индексы, путем создания новых файлов и заполнения их (обычная очистка просто освобождает место в файлах, не уменьшая их). 

Для перестройки таблицы требуется дополнительное место для копирования. После перестройки таблица находится в новых файлах, хотя OID сохраняется.

Если нужна очистка без блокировки, можно посмотреть стороннее расширение **pg_repack**

Похожие команды:

* **CLUSTER** дополнительно упорядочивает строки по одному индексу. Это ускорит работу (но следующие записи нарушат упорядоченное состояние, подойдет для редко изменяемых таблиц)
* **REINDEX** - перестраивает индекс
* **TRUNCATE** - очищает таблицу. В отличие от **DELETE** не просто помечает строки, а физически создает новый чистый файл для таблицы


### 1.7 Автоочистка

#### 1.7.1 Autovacuum launcher 

Запуск очистки в зависимости от количества изменений в таблицах.

Процесс **autovacuum launcher** постоянно отслеживает активность и просит **postmaster** запускать рабочие процессы **autovacuum worker**, которые проверяют таблицы и выполняют очистку. Рабочих процессов может быть несколько.

Конфигурационные параметры процесса **autovacuum launcher**:

* **autovacuum = on** - собственно включает автоочистку
* **track_counts** - включает сбор статистики, без нее не будет оснований для запуска очистки
* **autovacuum_naptime** - интервал для запуска рабочих процессов (для каждой БД отдельно отсчитывается). По умолчанию - 60 сек.
* **autovacuum_max_workers** - максимальное количество рабочих процессов на кластер (3 по умолчанию)

Рабочий процесс подключаются к базе данных, сканирует (?? или по данным анализа) таблицы и определяет таблицы для которых нужна очистка и / или анализ. В одной БД может несколько процессов работать, но с разными таблицами. 

#### 1.7.2 Настройки порога срабатывания рабочих процессов 

Порог срабатывания:

    число ненужных версий > autovacuum_vacuum_threshold + autovacuum_vacuum_scale_factor * количество строк в таблице

`autovacuum_vacuum_threshold` - допускаемый минимум мертвых версий строк, по умолчанию - 50

`autovacuum_vacuum_scale_factor` - процент строк, при котором срабатывает автоочистка (20% по умолчанию)

Число строк определяется по статистике: общее число - `pg_class.reltuples`, число ненужных - `pg_stat_all_tables.n_dead_tup` 

Порог срабатывания по умолчанию - примерно при 20% изменения таблицы. Для больших таблиц это может быть редко и занимать длительное время. Те же пороговые параметры можно для отдельной таблицы задавать (основной и TOAST отдельно) или отключать автоочистку для таблицы.

    # установка параметров:
    ALTER SYSTEM SET autovacuum_analyze_scale_factor = 0.02;
    SELECT pg_reload_conf();
    # параметры на уровне таблицы:
    ALTER TABLE tvac SET (autovacuum_enabled = on);
    ALTER TABLE tvac SET (autovacuum_vacuum_scale_factor = 0.01);
    # посмотреть параметры на уровне таблицы
    SELECT unnest(reloptions) FROM pg_class WHERE relname = 'tvac';

Аналогичные параметры есть для анализа (общие и на уровне таблицы): **autovacuum_analyze_threshold** (50 по умолчанию) и **autovacuum_analyze_scale_factor** (10%). Toast таблицы не анализируются.

#### 1.7.3 Регулирование нагрузки от autovacuum worker

Конфигурационные параметры:

* `autovacuum_vacuum_cost_limit` - **общий** объем работы для всех рабочих процессов в условных единицах (-1 по умолчанию, т. е. равен **vacuum_cost_limit** (200)). Значение 200 - мало, можно повышать до 1000-2000. Т. к. это общий объем работы, при увеличении **autovacuum_max_workers**, нужно увеличивать и его.
* `autovacuum_vacuum_cost_delay` - по умолчанию - 20 мс, при -1 равен **vacuum_cost_delay**.

Можно задавать на уровне отдельных таблиц.

Для управления памятью - **autovacuum_work_mem**. Значение по умолчанию = -1 (используется значение памяти для фоновых процессов **maintenance_work_mem** 64КБ). Эта память выделяется сразу и на каждый рабочий процесс. За счет увеличения памяти можно снизить число чтений индексов. Или чаще выполнять очистку, чтобв меньше данных обрабатывалось.

#### 1.7.4 Подходы к настройке системы очистки

Итеративный процесс поиска баланса между разрастанием таблиц и накладными расходами.

Увеличение threshold/scale_factor: разрастание таблиц, но меньшие суммарные накладные расходы. Хотя пиковые нагрузки могут быть. Уменьшение - меньше растут таблицы, увеличиваются накладные расходы.

Снижение пиковых нагрузок: уменьшение cost_limit/cost_delay. Это приводит к уменьшению скорости очистки, что может вызывать задержки в очистке. Тогда можно увеличивать число рабочих процессов max_workers

Мониторить: разрастание таблиц, очередь таблиц, ожидающих очистки, нагрузка на дисковую подсистему.


### 1.8 Заморозка

#### 1.8.1 Суть процесса заморозки 

Для номера транзакций используется 32-битный счетчик. Чтобы избежать переполнения, счетчик закольцован. Номера транзакций в половине по часовой стрелке считаются старшими и находящимися в будущем, против часовой - в прошлом. При этом нужно освобождать / помечать номера транзакций, находящиеся в прошлом, иначе окажется что старые транзакции окажутся в будущем (например при десятичном счетчике в 1 знак: 8, затем 9, затем 1, а 2 теперь в будущем?)

**Возраст транзакции** - число транзакций, прошедших с момента появления этой транзакции (всегда знаем номер текущей транзакции). Можно посмотреть через функцию:

    SELECT relfrozenxid, age(relfrozenxid) FROM pg_class WHERE relname = 't';

Заморозкой занимается процесс очистки. Находит транзакции, достаточно старые и видные во всех транзакциях и помечает их ("замораживает"). Такие строки считаются старше всех других и всегда видны в снимках. Их номера транзакций больше не проверяются и могут использоваться для новых транзакций.

**Признак заморозки**: одновременно установленные биты **xmin committed** и **xmin aborted**. Xmax замораживать не нужно: если он задан, значит эта версия не актуальна и будет удалена вскоре. В версиях < 9.4 признаком заморозки был номер транзакции = 2.

Если сервер увидит, что не заморооженные транзакции рискуют попасть в будущее (очистка по каким-то причинам не смогла заморозить) - аварийно останавливается. Нужно запускаться в монопольном режиме и выполнять очистку.

#### 1.8.2 Настройка заморозки

Конфигурационные параметры:

* **vacuum_freeze_min_age** - минимальный возраст транзакции **xmin**, при котором можно замораживать. Малое значение - ведет к накладным расходам (строку заморозили, но она потом изменилась и ее удалят, заморозка впустую). Такая очистка не смотрит на страницы, отмеченные в карте видимости (только с актуальными версиями строк)
* **vacuum_freeze_table_age** - возраст транзакции, при котором пора выполнять заморозку на всех страницах. Каждая таблица хранит номер последней замороженной транзакции `pg_class.relfrozenxid`. В карте видимости есть бит, отмечающий страницы с замороженными версиями.

Каждая таблица будет морозится раз в 

    (vacuum_freeze_table_age - vacuum_freeze_min_age)

транзакций. Т. е. большое значение **vacuum_freeze_min_age** увеличивает частоту заморозки и накладные расходы.

**autovacuum_freeze_max_age** - максимальный возраст, при котором будет принудительно запущена заморозка, даже если автоочистка отключена. Также определяет размер области для записей XACT.

Хранится на уровне БД (как минимальный номер замороженной транзакции из таблиц ):

    SELECT datfrozenxid, age(datfrozenxid) FROM pg_database WHERE datname = 'postgres';


Значения по умолчанию:

* **vacuum_freeze_min_age** - 50кк
* **vacuum_freeze_table_age** - 150кк
*  **autovacuum_freeze_max_age** - 200кк (стоит увеличить)

Параметры можно устанавливать на уровне отдельных таблиц.

#### 1.8.3 Ручная заморозка

    VACUUM FREEZE

Замораживает все версии строк, несмотря на возвраст (**vacuum_freeze_min_age = 0**)

Также строки замораживаются при `VACUUM FULL` или `CLUSTER`


## 2. Журналирование

### 2.1 Буферный кеш

#### 2.1.1 Внутреннее устройство

Для сглаживания работы дисков/памяти. Для чтения / записи процессы читают страницы в память. Буферный кеш - общая память для сервера, 

Устройство:

* массив буферов
* список свободных буферов
* хеш-таблица страниц в кеше (номер буфера по имени файла и номеру страницы)
* ссылка на следующую жертву

Каждый буфер - собственно страница и заголовок. Заголовок содержит:

* расположение страницы на диске (файл, номер страницы)
* число обращений к буферу (+1 за каждое обращение любого процесса, но не > 5)
* признак, что данные изменены (грязный буфер)
* признак закрепленности: счетчик, означает что с буфером работают

#### 2.1.2  Процесс чтения в свободный буфер

* процесс ищет страницу в буфере по хеш-таблице
* если нет, ищется свободный буфер через список свободных буферов
* в найденном свободном буфере увеличивается счетчик закреплений, счетчик обращений, читается страница с диска.
* в хеш-таблицу записывается ссылка на буфер

#### 2.1.3 Процесс чтения с вытеснением

* нужно найти страницу для вытеснения из буфера
    - начиная со ссылки на жертву, алгоритм обходит массив буферов, уменьшая счетчик обращений на 1.
    - как только найден буфер с нулевым счетчиком, он вытесняется. Таким образом часто используемые буферы вытесняются в последнюю очередь
    - чтобы слишком много циклов не накручивалось, счетчик обращений не превышает 5
* если буфер закреплен, счетчик обращения уменьшается, но буфер оставляется
* если буфер для вытеснения - грязный:
    - буфер закрепляется, чтобы другие процессы не пытались вытеснить тоже
    - записывается на диск (на самом деле в кеш ОС)
* в свободный теперь буфер читаются данные с диска
* ссылка на жертву устанавливается на следующий буфер, поэтому текущий может успеть нарастить счетчик обращений

#### 2.1.4 Массовое вытеснение

При массовой записи / чтении есть шанс забить кеш одноразовыми страницами  и вытеснить полезные страницы.

Для таких операций используются **буферные кольца**: выделяется часть кеша и вытеснение происходит только в пределах этого кольца.

При последовательном чтении, если попадаются грязные буферы: отключаются от кольца, на диск не записываются. На диск будут записаны на общих основаниях. Сделано для ускорения процесса чтения.

Подключение процессов: если во время чтения другому процессу требуются те же данные, этот процесс может подключится к тому же кольцевому буферу. По окончании чтения дочитает начало самостоятельно.

Размеры кольцевых буферов:

* последовательное чтение - 32 буфера
* очистка - 32 буфера
* массовая запись (COPY) - <= 2048 буферов

#### 2.1.5 Настройка размера кеша

Параметр **shared_buffers**. По умолчанию - 128МБ, сильно занижено, надо увеличивать.

Начать можно с 1/4 оперативной памяти. 

Можно проанализировать счетчик обращений (usage count). Большие значения у всех буферов - признак частого вытеснения. С другой стороны большой размер - накладные расходы.

Для временных таблиц буферный кеш не используется. Такие таблицы нужны только в пределах одного сеанса. Для них используется локальный кеш (параметр **temp_buffers**)


#### 2.1.6 Прогрев буферного кеша

После перезагруки сервера кеш пустой и начало работы будет сопровождаться массовым чтением с диска

Расширение **pg_prewarm** может заполнять данные определенных таблиц в кеш или загружать сохраненное ранее состояние кеша.


### 2.2 Журнал предзаписи WAL

#### 2.2.1 Основы

Задача журнала предзаписи - восстановление согласованности БД при сбоях и потере содержимого буферного кеша.

Суть: одновременно с изменением данных на странице в буферном кеше в журнале создаются запись об изменениях, достаточная для повторения этой операции. Эта запись обязательно попадает на диск до того, как страница попадет на диск. Отсюда - журнал предварительной записи (Write Ahead Log)

Что попадает в WAL - все операции, для которых есть риск потери из оперативной памяти:

* изменения страниц в буферном кеше (таблицы и индексы)
* записи о транзакциях в буфере XACT
* файловые операции (создание, удаление файлов)

Не журналируются:

* временные таблицы
* таблицы, для которых явно указано, что не нужно

#### 2.2.2 Логическое устройство

Набор записей разной длины. Каждая запись - заголовок и данные.

Заголовок содержит:

* номер транзакции, к которой относится запись
* менеджер ресурсов - компонент системы, ответственный за эту запись
* контрольную сумму

Данные имеют разную структуру, определяется менеджером ресурсов. Например для таблиц - это двоичные данные, которые нужно записать поверх страницы с определенного смещения, чтобы получить изменения.

Каждая запись идентифицируется **LSN** (Log Sequence Number) тип **pg_lsn**. Это просто 64-битное смещение до записи от начала журнала.

#### 2.2.3 Физическое устройство

Файлы в каталоге `$PGDATA/pg_wal`. Размер файла - 16МБ. Записи добавляются в один файл, когда заполняется - создается новый.

Есть кеш журнала в памяти. Размер - параметр **wal_buffers**. По умолчанию - 1/32 буферного кеша. Кеш работает по принципу кольчевого буфера: запись в начало буфера, запись на диск - с хвоста.

#### 2.2.4 Порядок работы журнала

* какая-либо страница буферного кеша изменяется
* формируется запись журнала и помещается в буфер журнала
* одновременно lsn записи помещается в заголовок страницы буферного кеша
    - текущую lsn для вставки можно узнать через `pg_current_wal_insert_lsn()`
* указатель `pg_current_wal_insert_lsn` сдвигается вперед
* например происходит фиксация транзакции
* формируется запись журнала для страницы XACT
* на страницу XACT помещается lsn
* в какой-то момент (связано с контрольными точками) записи журнала попадают на диск
    - функция `pg_current_wal_lsn()` показывает последнюю запись, попавшую на диск
* только после этого можно страницы записывать на диск
* проверяется что lsn страницы (последняя запись) меньше `pg_current_wal_lsn()`
* если вдруг страницу нужно записать на диск (например вытеснение), а записи журнала еще в буфере - журнальные буферы записываются принудительно

Пример функций:

    SELECT pg_current_wal_insert_lsn();
        0/1C349E8
    # в каком файле
    SELECT pg_walfile_name('0/1C349E8');
        000000010000000000000001
    # просмотр файлов журнала
    SELECT * FROM pg_ls_waldir() LIMIT 10;
    # просмотр lsn в заголовке страницы (pageinspect)
    SELECT lsn FROM page_header(get_raw_page('t',0));

#### 2.2.5 Восстановление после сбоя

При запуске сервера запускается процесс **startup**. Анализирует файл `$PGDATA/global/pg_control` (двоичный, просмотр через pg_controldata) и если там статус отличный от `shut down` значит произошел сбой (нормальное завершение просто запишет в этот файл статус `shut down`)

Дальше последовательно читает записи WAL и если надо, применяет их к страницам. Когда надо применять: если lsn на странице (последняя запись, связанная со страницей) меньше чем lsn записи журнала. Изменения страниц происходит как обычно в буферном кеше.

Нежурналируемые таблицы перезаписываются образами из init-файлов (очищаются по сути).

С какого места журнала начинать восстановление - контрольные точки.


### 2.3 Контрольные точки

#### 2.3.1 Обзор механизма контрольных точек 

Если страница в кеше активно используется она может не выдесняться на диск. Это значит что при восстановлении придется просматривать много журнальных записей.

Это ведет к разрастанию журнала и увеличение времени восстановления.

Фоновый процесс **checkpointer** создает контрольные точки (КТ), периодически записывая грязные страницы на диск (в кеше при этом остаются). После завершения создания КТ, записи журнала до начала КТ не нужны.

Можно вручную запустить

    CHECKPOINT; 

#### 2.3.2 Процесс создания контрольной точки

* На диск сбрасываются буферы статуса транзакций XACT. Их 128 штук, поэтому однократная операция
* Выполняется запись страниц буферного кеша:
    - сначала все измененные страницы помечаются специальным флагом в заголовке. Так формируется набор страниц для контрольной точки
    - затем постепенно сбрасывает помеченные страницы на диск и снимает флаг. Счетчик закреплений и счетчик обращений никак не затрагивается, т. к. страницы не убираются из кеша
    - также страницу может записать серверные процессы. Сбрасывают флаг при этом, чтобы повторно не записывал **checkpointer**.
* после записи всех отмеченных страниц, создается запись в журнале о создании контрольной точки. Запись содержит LSN той записи, с которой началось создание контрольной точки. Сам факт начала формирования контрольной точки нигде не фиксировался.
* в файл `$PGDATA/global/pg_control` добавляется указатель на эту созданную запись. Таким образом определяем последнюю контрольную точку. Некоторые версии PostgreSQL еще содержат запись о предыдущей точке.

Процесс записи грязных страниц на диск растягивается по времени. За это отвечает параметр `checkpoint_completion_target`: доля времени между двумя контрольными точками, в которое происходит запись буферов. По умолчанию 0.5, можно поднимать до ~0.9, чтобы распределить нагрузку. Выше 0.9 поднимать опасно, может не успевать сбрасывать.

#### 2.3.3 Процесс восстановления

При старте сервер запускает процесс **startup**. Процесс проверяет статус в файле `$PGDATA/global/pg_control`. Если отличен от `shut down` - значит был сбой.

Из этого же файла читается LSN записи журнала о контрольной точки, из этой записи - LSN записи, с которой началась контрольная точка.

**startup** начинает проверять записи, начиная с начальной записи КТ. Условие применения записи к странице: LSN на странице меньше LSN записи журнала. Страницы обрабатываются в буферном кеше.

Также опрабатывает записи о файлах: создает / удаляет если нет / есть

Нежурналируемые таблицы перезаписываются образами (пустыми) из init-файлов.

Процесс **startup** завершается, а **checkpointer** создает контрольную точку, чтобы зафиксировать восстановление.

Для имитации сбоя можно остановить принудительно `pg_ctl -w -D ... stop -m immediate`.

#### 2.3.4 Частота контрольных точек

Настройка частоты КТ - компромисс между объемом журнальных файлов/ скоростью восстановления и нагрузкой на систему. Чем реже контрольные точки, тем меньше нагрузка, но больше объем журнальных файлов.

Параметр **checkpoint_timeout** задает время между контрольными точками. По умолчанию 5 мин, можно увеличивать до 30-60 минут.

Чтобы журнал сильно не рос между КТ (нагрузка резко выросла): параметр `max_wal_size` - максимальный размер журнала, после которого запускается КТ. По умолчанию - 1 ГБ.

Параметр `checkpoint_warning` определяет, что нужно выдавать предупреждения если КТ выполняется слишком часто (из-за превышения размера журнала). По умолчанию 30 сек, настроить относительно **checkpoint_timeout**. Но нужно включить логирование сообщений о КТ `log_checkpoints`.

Как выполняются КТ - см. представление `pg_stat_bgwriter`.

#### 2.3.5 Размер журнала

Сервер будет хранить файлы:

* еще не переданные через слоты репликации
* не записанные в архив при наличии непрерывной архивации
* не превышающие минимального размера `min_wal_size`

Объем, заданный в `max_wal_size` не жесткое ограничение, может превышать.

До 11 версии хранит файлы еще и за прошлую КТ, объем журнала можно оценивать как 
    
    (2 + checkpoint_completion_target) + объем между КТ

Можно задавать минимальный объем журнала. Сервер будет хранить файлы, когда нужны будут новые - скопирует (быстрее, чем с нуля создавать). Параметр `min_wal_size`, по умолчанию - 80МБ. В старых версиях количество файлов - `wal_keep_segments`, в новых по умолчанию 0.



### 2.4 Фоновая запись

#### 2.4.1 Процесс bgwriter

Процесс **bgwriter**, задача: записывать грязные страницы на диски, чтобы этим не занимались пользовательские процессы.

Алгоритм аналогичный, что при вытеснении. Использует свой указатель на следующую 'жертву', опережая указатель на 'жертву' обычных процессов.

Записывает буферы по условиям:

* грязные
* не закрепленные
* с нулевым счетчиком обращений

Таким образом записывает буферы, которые с большой вероятностью будут вытеснены вскоре.

#### 2.4.2 Настройка фоновой записи

Работает циклами, засыпая на `bgwriter_delay` (200 мс по умолчанию). 

За цикл записывает `N * bgwriter_lru_multiplier` буферов, но не больше чем `bgwriter_lru_maxpages` (100 по умолчанию). `bgwriter_lru_multiplier` по умолчанию = 2. `N` - среднее количество буферов, запрашиваемое пользовательскими процессами с прошлого запуска (алгоритм скользящего среднего, чтобы не зависеть от истории).

Если нет активности в системе - засыпает, до тех пор, пока не произойдет обращение пользовательского процесса к буфера.

Настраивать после настроек КТ. Цель: **checkpointer** и **bgwriter** должны успевать записывать грязные страницы до того, как они потребуются пользовательским процессам.

Для настройки - анализировать представление `pg_stat_bgwriter`.



### 2.5 Настройка журнала WAL

#### 2.5.1 Уровни журнала

Параметр `wal_level` определяет уровень журнала (интенсивность и объем): 

* **minimal** - восстановление после сбоя
* **replica** - восстановление из резервной копии через **pg_basebackup** + репликация. Значение по умолчанию.
* **logical** - логическая репликация

#### 2.5.2 Надежность журнала

##### 2.5.2.1 Кеширование записи на диск

Для надежной записи на диск, используются особые системные вызовы ОС (например `fsync`). Конкретный способ задан в параметре `wal_sync_method`. Подобрать подходящий можно через утилиту `pg_test_fsync`. Postgres выполняет вызов метода, чтобы быть уверенным, что запись выполнена.

Важно убедиться, что данные доходят до диска: кэш контроллера имеет резервное питания, сквозная запись установлена для дисков.

Можно отменить проверку записи - параметр **fsync**, но только для разовых операций (например при загрузке из архива).

##### 2.5.2.2 Повреждение страниц

Журнальные записи всегда содержат контрольные суммы CRC-32.

Страницы также стоит защищать контрольными суммами (при инициализации кластера `initdb -k`), несмотря на накладные расходы. Включены или нет:

    SHOW data_checksums;

Если при запросе обнаружено повреждение: выдаст сообщение и в зависимости от параметра `ignore_checksum_failure` прервёт транзакцию или продолжит.

##### 2.5.2.3 Неатомарность записи

Размер страницы - 8КБ, на диск может записываться другими блоками (файловая / операционная система). При сбое страница может записаться частично.

Для исключения таких ошибок, в журнал записывается образ всей страницы при первой записи страницы после КТ. При восстановлении такой образ безусловно записывается из журнала (защищен контрольными суммами) и к нему применяются записи. 

Параметром `full_page_writes` можно отключить запись полных страниц, но только если файловая система или железо обеспечивает атомарность.

Для сжатия размера журнала - параметр `wal_compression`

Размер можно анализировать через ` pg_waldump --stats -p /usr/local/pgsql/data/pg_wal -s`. При включенной записи полных страниц, сжатие может уменьшать больше чем в 2 раза.


#### 2.5.3 Производительность журнала

##### 2.5.3.1 Характер нагрузки

Запись в журнал - последовательная, без случайного доступа, поэтому справляются обычные HDD. Имеет смысл размещать на отдельных дисках (`$PGDATA/pg_wal` сделать символьной ссылкой).

Исключение - если при потоковой репликации **walsender** не успевает читать данные из буфера журнала и вынужден читать с диска.

##### 2.5.3.2 Синхонная запись

**Синхронная запись**: транзакция ждет окончания записи WAL на диск, только после этого завершается. **Асинхронная запись** - отдельный фоновый процесс пишет WAL на диск.

Параметр `synchronous_commit` включает синхронную запись.

Синхронизация - дорогая операция, для оптимизации: ожидает завершения активных транзакций и синхронизирует из разом. Параметр `commit_delay` (0 мс по умолчанию)- пауза, если есть не менее `commit_siblings` (5 по умолчанию) активных транзакций. Имеет смысл включать если много мелких транзакций.

Синхронная запись обеспечивает долговечность транзакции: если транзакция завершена, значит запись о ней есть в журнале, но влияет на производительность

##### 2.5.3.3 Асинхронная запись

Отдельный процесс **wal_writer**, паузы каждые `wal_writer_delay` (200 мс по умолчанию).

Процесс пробегает по буферу WAL и записывает только полностью заполненные страницы. Если таких нет - записывает текущую (не полностью заполненную страницу).

Асинхронная запись: больше производительность, но есть риск потерять зафиксированные изменения, если с последней записи прошло меньше `3 * wal_writer_delay`

Для отдельных важных транзакций можно устанавливать `synchronous_commit`.



## 99. Вопросы для анализа БД

* Сколько строк в таблице - **pg_class.reltuples** (статистикой обновляется)
* Сколько мертвых строк - **pg_stat_all_tables.n_dead_tup**
* Когда анализ был последний раз, как часто - **pg_stat_all_tables**
* Когда очистка была, как часто - **pg_stat_all_tables**

**Размер таблицы: общий, свободный**

    SELECT pg_size_pretty(pg_table_size('t'));

* разрастание таблиц

**очередь таблиц, ожидающий очистки**
    
    можно вычислить порог

    CREATE VIEW vacuum_v AS
        WITH params AS (
          SELECT (SELECT setting::integer
                  FROM   pg_settings
                  WHERE  name = 'autovacuum_vacuum_threshold') AS vacuum_threshold,
                 (SELECT setting::float
                  FROM   pg_settings
                  WHERE  name = 'autovacuum_vacuum_scale_factor') AS vacuum_scale_factor
        )
        SELECT st.relname,
               st.n_dead_tup dead_tup,
               (p.vacuum_threshold + p.vacuum_scale_factor*c.reltuples)::integer max_dead_tup,
               st.n_dead_tup > (p.vacuum_threshold + p.vacuum_scale_factor*c.reltuples)::integer need_vacuum,
               st.last_autovacuum
        FROM   pg_stat_all_tables st,
               pg_class c,
               params p
        WHERE  c.oid = st.relid
        AND    c.relname = 'tvac';

**Просмотр параметров автоочистки, установленные на уровне таблицы**

     SELECT unnest(reloptions) FROM pg_class WHERE relname = 'tvac';

**Просмотр возраста транзакции для заморозки**

    # по всем БД
    SELECT datname, datfrozenxid, age(datfrozenxid) FROM pg_database;
    # по таблицам БД
    SELECT relname, relfrozenxid, age(relfrozenxid) FROM pg_class;

**Анализ буферного кеша**

Просмотр количества счетчика обращений у страниц. Большие значения у всех буферов - признак частого вытеснения. Можно смотреть через расширение **pg_buffercache**.

    CREATE EXTENSION pg_buffercache;
    
    SELECT usagecount, count(*) FROM pg_buffercache GROUP BY usagecount ORDER BY usagecount;

Но часто (в мониторинге) нельзя использовать - блокирует кеш для анализа.

**Как растет журнал предзаписи**

Разница между двумя вызовами `pg_current_wal_lsn()` в байтах

    SELECT '0/1C34A54'::pg_lsn - '0/1C349E8'::pg_lsn;

**Просмотр журнала предзаписи**

утилита **pg_waldump**
    
    pg_waldump -p /usr/local/pgsql/data/pg_wal -s 0/1C349E8 -e 0/1C34A54 000000010000000000000001   

**Размер журнала предзаписи**

    select pg_size_pretty(SUM(size)) from pg_ls_waldir();

**Просмотр текущего состояния сервера (pg_control)**

Утилита **pg_controldata**

**Имя файла WAL по LSN**

    SELECT pg_walfile_name('0/1C34A54');

**Имитация сбоя для запуска восстановления**

    `pg_ctl -w -D ... stop -m immediate`

**Просмотр состояния контрольной точки**

    pg_controldata
        ...
        Latest checkpoint location:           0/1BF5734
        Prior checkpoint location:            0/1BF5668
        Latest checkpoint's REDO location:    0/1BF56FC
        Latest checkpoint's REDO WAL file:    000000010000000000000001
        ...

**Просмотр статистики работы checkpointer и bgwriter**

    SELECT * FROM pg_stat_bgwriter \gx

        checkpoints_timed     | 0   # КТ по расписанию
        checkpoints_req       | 1   # по требованию (из-за размера или вручную)
        checkpoint_write_time | 4
        checkpoint_sync_time  | 17
        buffers_checkpoint    | 442  # страницы, сброшенные при КТ
        buffers_clean         | 0    # страницы, сброшенные фоновой записью
        maxwritten_clean      | 0    
        buffers_backend       | 444  # страницы, сброшенные польз. процессами
        buffers_backend_fsync | 0
        buffers_alloc         | 630
        stats_reset           | 2019-08-12 17:15:48.881345+03

Стремиться, чтобы `buffers_backend << buffers_checkpoint + buffers_clean`

Большое значение `checkpoints_req` означает, что КТ часто выполняются не по расписанию

**Где находятся файлы таблицы или другого объекта**

    SELECT pg_relation_filepath('<имя объекта>');

**Размер журнала WAL**

    pg_waldump --stats -p /usr/local/pgsql/data/pg_wal -s

Пример (FPI - записи `full_page_writes`): 

    Type      N   (%)     Record size  (%)  FPI size  (%)   Combined size (%)
    XLOG      1719 (2,00) 84231     (1,50)  13840388 (100,00) 13924619 (71,62)
    Tran-tion 14040(16,30) 477440   (8,52)  0        (0,00)   477440   (2,46)