## Содержание

<!-- MarkdownTOC autolink="true" uri_encoding="false" levels="2,3" -->

- [1. Многоверсионность](#1-Многоверсионность)
    - [1.1 Транзакции](#11-Транзакции)
    - [1.2 Страницы и версии строк](#12-Страницы-и-версии-строк)
    - [1.3 Снимки данных и горизонт событий](#13-Снимки-данных-и-горизонт-событий)

<!-- /MarkdownTOC -->

## 1. Многоверсионность

### 1.1 Транзакции

#### 1.1.1 Свойства транзакций

Транзакция - совокупность операций, которые переводят базу из одного корректного состояния в другое (**согласованность**), при условии, что транзакция выполнена полностью (**атомарность**) и без помех со стороны других транзакций (**изолированность**). (+ **долговечность**)

Согласованность состояния определяется ограничениями на уровне БД или семантикой приложения.

#### 1.1.2 Аномалии

Ослабление **изолированности** ведет к аномалиям:

* **грязное чтение** - транзакция Т2 читает данные незафиксированной транзакции Т1, при откате транзакции Т1 получается, что Т2 видела данные, которых не существовало.
* **неповторяющееся чтение (non-repeatable read)** - Т1 читает строку. Т2 изменяет или удаляет эту строку и фиксируется. Т1 снова читает строку и видит изменения
* **фантомное чтение** - Т1 читает набор строк по условию. Т2 добавляет строку, соответствующее условию и фиксируется. Т1 читает еще раз и видит новые строки.
* есть другие.

#### 1.1.3 Уровни изолированности

Стандарт SQL определяет уровни изолированности по аномалиям:

* **Read Uncommitted** - возможно грязное чтение и все другие аномалии
* **Read Committed** - грязное чтение невозможно, остальные возможны
* **Repeatable Read** - неповторяющееся чтение, грязное чтение невозможны, остальные возможны
* **Serializable** - никакие аномалии невозможны, как если бы последовательно транзакции выполнялись

Дополнительно: ни на каком уровне **не допускается потеря сделанных изменений в других транзакциях** (**lost updates**). Пример потерянного обновления: Т1 читает строку по условию, Т1 изменяет ее, Т2 читает ту же строку. Т2 изменяет. Т1 фиксируется. Т2 фиксируется. Изменения Т1 потеряны. БД не должны такого допускать.

Особенности PostgreSQL - более строгие ограничения:

* грязное чтение невозможно (многоверсионность), поэтому **Read Uncommitted** и **Read Committed** эквиваленты.
* **Repeatable Read** не допускает также фантомного чтения
* уровень по умолчанию - самый низший **Read Committed**

Итого:

* уровень **Read Committed**:
    - SELECT видит снимок БД на момент выполнения каждого оператора внутри транзакции
    - никогда не увидит незафиксированных изменений или изменений, внесенных паралелльными транзакциями в процессе выполнения запроса (НЕ транзакции)
    - два последовательных SELECT могут видеть разные данные, если были зафиксированные транзакции
    - если две транзакции выполняют изменение / удаление одной строки, вторая транзакция будет ожидать результата первой и работать с обновленной версией строки
    - есть варианты выполнения команды INSERT: ON CONFLICT DO UPDATE и ON CONFLICT DO NOTHING
* уровень **Repeatable Read**:
    - снимок БД фиксируется на момент первого оператора в транзакции (не BEGIN)
    - если две транзакции выполняют изменение / удаление одной строки, вторая транзакция будет ожидать результата первой, и в случае фиксации первой - выдаст ошибку.
* уровень **Serializable**:
    - точно также получаем ошибку при параллельной записи
    - чтобы работал, все транзакции должны быть на уровне Serializable

#### 1.1.4 Команды для работы с транзакциями

Выполнение в транзакции:

    BEGIN;
    ....
    ROLLBACK;
    COMMIT;

Установка уровня изолированности:

    BEGIN;
    # первая комманда после начала транзакции
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
    # или сразу
    BEGIN ISOLATION LEVEL READ UNCOMMITTED;

Просмотр уровня транзакции:

    SHOW transaction_isolation;
    # по умолчанию:
    SHOW default_transaction_isolation; 

#### 1.1.5 Примеры работы

Блокировки параллельных транзакций при записи: 

    # уровень Read Committed
    T1: BEGIN;
    T1: UPDATE t SET n = 4;
    T2: BEGIN;
    T2: UPDATE t SET n = n + 10;
    # т. к. нельзя допустить lost updates, T2 блокируется и ждет результата T1
    # аналогично для DELETE
    # при этом если удаление по условию выполняется и в результате другой транзакции это условие перестает выполнятся, удаления не произойдет
    # если 
    T1: COMMIT;
    T2: COMMIT; # здесь еще раз выполняется обновление строки
    SELECT * FROM t;
        n = 14;

Ошибка параллельных транзакций при записи:

    # уровень Repeatable Read;
    T1: BEGIN ISOLATION LEVEL REPEATABLE READ;
    T1: UPDATE t SET n = 4;
    T2: BEGIN ISOLATION LEVEL REPEATABLE READ;
    T2: UPDATE t SET n = 10;
    # Т2 ждет результата Т1
    Т1: COMMIT;
    # T2 тут же выдает ошибку: из-за запрета lost updates T2 должна перечитать данные, но уровень изоляции не позволяет этого сделать    



### 1.2 Страницы и версии строк

#### 1.2.1 Структура данных

##### 1.2.1.1 Структура страницы

Размер страницы по умолчанию 8 КБ. 

Таблицы, индексы и другие объекты используют одинаковую структуру страниц, чтобы пользоваться общим буферным кешем.

Структура страницы:

* вначале - блок указателей (24 байта) - общие сведения, размер других областей
* указатели - каждый указатель 4 байта, указывает на позицию версии строки (**tuple**) на странице
* собственно версии строк расположены в конце страницы

Косвенная адресация позволяет например перемещать строки, не ломая индексы

Страницы попадают в буферный кеш прямо с диска, без преобразований. Поэтому нет совместимости между разными платформами (разрядность, порядок байт).

При хранении данных используется выравнивание по границам машинных слов (32-битные - 4 байта, 64-х - 8 байт). Поэтому правильное расположение колонок может дать некоторую экономию.    

##### 1.2.1.2 Указатели

Содержат:

* ссылку на версию строки
* длину этой версии
* несколько бит, определяющих статус версии

##### 1.2.1.3 Версии строк

Состоят из заголовка и данных.

Заголовок:

* **xmin**, **xmax** - определяют видимость версий в терминах номеров транзакций
* **ctid** - ссылка на следующую версию строки, у актуальной версии - на себя же. Формат: (номер страницы, номер указателя в массиве)
* ряд битов **infomask**

Структура индексных страниц сильно зависит от типа индекса. Но обычно также содержит указатели на версии строк **ctid**. Не содержит никаких данных о версиях строк (нет полей xmax, xmin).




#### 1.2.2 Выполнение операций

**Вставляется строка в транзакции**

* Начинается транзакция, добавляется строка:
    - создается указатель с номером 1 на версию строки
    - в версии строки **xmin** содержит номер транзакции (100 например)
    - **xmax** пустой и бит **xmax_aborted** установлен в истину, т. е. другие транзакции будут игнорировать **xmax**
    - в журнале XACT для 100 транзакции биты не установлены (транзакция еще активна)
    - **ctin** ссылается на эту же строку
* Транзакция фиксируется
    - в журнале XACT у транзакции № 100 устанавливается бит **committed**
    - больше ничего не меняется, транзакция завершена

**Другая транзакция пытается прочитать строку**:

*  Видит версию строки с номером транзакции 100. Нужно понять в каком состоянии эта транзакция
    -  проверяет статус транзакции: активна или завершилась. Для этого есть структура в памяти ProcArray
    -  если завершилась - проверяет фиксацией или отменой по битам журнала XACT
    -  чтобы повторно не выполнять это, устанавливает информационные биты в версии строки **xmin_committed** или **xmin_aborted**. Последующие транзакции будут анализировать только эти биты

Почему только следующая транзакция устанавливает эти биты, а не исходная? Нужно запоминать какие строки, на каких страницах, страницы могут быть уже не в кеше.

Следствие: операции чтения могут вызывать записи на диск (когда обновляются биты во время первого чтения после записи).

**Удаление строки**

* в **хmax** записывается номер текущей транзакции (выступает также как признак блокировки, если транзакция активна)
* бит **xmax_aborted** сбрасывается
* транзакция завершается, больше ничего не происходит
* последующее чтение:
    - проверит статус транзакции в XACT
    - установит бит **xmax_committed** или **xmax_aborted**

**Обновление строки**

* удаляется предыдущая версия строки
    - все то же, что при удалении обычном
* записывается новая
    - аналогично обычной вставке
    - обновляется **ctid**


#### 1.2.3 Точки сохранения и вложенные транзакции

**Точка сохранения** - возможность откатить часть транзакции.

    BEGIN;
    INSERT ...
    SAVEPOINT sp;
    DELETE ...
    ROLLBACK TO sp;
    ....
    COMMIT;


Реализованы через вложенные транзакции. От начала до точки сохранения одна, от точки до конца - другая. При возврате к точке просто меняется статус в XACT.

Вложенные транзакции имеют номер больший чем основная. Могут иметь свой статус. Но при откате основной, откатываются и они.

Информация о вложенности хранится в `$PGDATA/subtrans/`

### 1.3 Снимки данных и горизонт событий

#### 1.3.1 Снимки данный

**Снимки данных** нужны для транзакций и определяют какие версии строк видны, а какие нет.

Для уровня **Read Committed** снимок создается в начале каждого оператора транзакции и активен, пока этот оператор выполняется.

Для уровней **Repeatable Read** и **Serializable** создается один раз в начале первого оператора и активен до конца транзакции.

Видна версия строки в снимке или нет: на основе **xmin** и **xmax**. Эти номера не пересекаются, поэтому в одном снимке - максимум одна версия строки.

Транзакции видные в снимке, если это та же самая транзакция или транзакция зафиксирована до начала снимка.

Чем определяется снимок:

* моментом создания снимка - номер следующей, еще не существующей транзакции (**xmax снимка**)
* списком активных транзакций на момент создания снимка (зная номер транзакции, можем понять ее состояние, но когда она точно завершилась неизвестно (в момент создания снимка или чуть позже). Поэтому нужен список активных транзакций на момент создания снимка.)
* для удобства **xmin** самой ранней активной транзакции

Просмотр снимка: функция `txid_current_snapshot()`, возвращает список xid, разделенных `:`:

* xmin - минимальная транзакция на момент создания снимка
* xmax - номер следущей (еще не существующей транзакции)
* список активных транзакций

#### 1.3.2 Горизонт событий

**xmin** самой ранней активной транзакции снимка определяет **горизонт событий** для транзакции. За горизонтом событий транзакция видит только актуальные версии строк.

Аналогично для всей БД - **горизонт событий** определяется через самый ранний **xmin** снимка всех активных транзакций. За горизонтом событий БД неактуальные версии строк больше не увидит ни одна транзакция и их можно удалять.

**Удержание горизонта событий**: любая транзакция (даже Read Committed) удерживает горизонт БД, препятствуя очищению.

Можно управлять параметрами:

* `old_snapshot_treshold` - определяет максимальное время снимка. При превышении - сервер получает право удалять неактуальные версии. Если транзакция обращается к этим данным - ошибка `snapshot too old`
* `idle_in_transaction_session_timeout` - прерывает транзакции в бездействии по истечении указанного времени

Посмотреть можно через системную таблицу:

    SELECT backend_xmin FROM pg_stat_activity WHERE pid = pg_backend_pid();


#### 1.3.3 Виртуальные транзакции

Если транзакция только читает данные, она никак не может изменить видимость версий строк. Поэтому любой транзакции сначала можно выдать **виртуальный номер (virtual xid)**. 

Он выдается текущим процессом, не требует синхронизации и поэтому быстро дается.

Если выполняется запись в транзакции, тогда ей уже присваивается настроящий номер.

Функция `txid_current()` возвращает номер транзакции (если виртуальный - создает реальный и возвращает его)

Функция `txid_current_if_assigned()` возвращает реальный номер, только если он назначен


#### 1.3.4 Экспорт снимка

Если несколько параллельных транзакций должны видеть одинаковую картинц данных. Например `pg_dump`, работающий параллельно.

Функция `pg_export_snapshot` возвращает идентификатор снимка.

Он может быть передан в другую транзакции через `SET TRANSACTION SNAPSHOT`. Можно только в Repeatable Read или в Serializable транзакции (в Read Committed снимки на каждый оператор созадются)

