
## Содержание

<!-- MarkdownTOC autolink="true" uri_encoding="false" levels="2,3" -->

- [1. Установка и настройка](#1-Установка-и-настройка)
    - [1.1 Установка сервера](#11-Установка-сервера)
    - [1.2 Настройка переменных окружения](#12-Настройка-переменных-окружения)
    - [1.3 Начало работы](#13-Начало-работы)
    - [1.3.4 Команда pg_ctlcluster](#134-Команда-pg_ctlcluster)
    - [1.3.5 Где мои логи, чувак?](#135-Где-мои-логи-чувак)
- [2. Утилита psql](#2-Утилита-psql)
    - [2.1 Подключение к серверу](#21-Подключение-к-серверу)
    - [2.2 Основные команды](#22-Основные-команды)
    - [2.3 Выполнение скриптов при запуске](#23-Выполнение-скриптов-при-запуске)
    - [2.4 Форматирование вывода](#24-Форматирование-вывода)
    - [2.5 Разное](#25-Разное)
    - [2.6 Переменные psql и переменные окружения](#26-Переменные-psql-и-переменные-окружения)
- [3. Конфигурация](#3-Конфигурация)
    - [3.2 Файл postgresql.conf](#32-Файл-postgresqlconf)
    - [3.3 Файл postgresql.auto.conf](#33-Файл-postgresqlautoconf)
    - [3.4 Представление pg_file_settings](#34-Представление-pg_file_settings)
    - [3.5 Представление pg_settings](#35-Представление-pg_settings)
    - [3.6 Пользовательские параметры](#36-Пользовательские-параметры)
- [4. Архитектура](#4-Архитектура)
    - [4.1 Многоверсионность](#41-Многоверсионность)
    - [4.2 Уровни изоляции](#42-Уровни-изоляции)
    - [4.3 Буферный кеш и журналирование](#43-Буферный-кеш-и-журналирование)
- [5. Организация данных](#5-Организация-данных)
    - [5.1 Базы данных и схемы](#51-Базы-данных-и-схемы)
    - [5.2 Системный каталог](#52-Системный-каталог)
    - [5.3 Табличные пространства](#53-Табличные-пространства)
    - [5.4 Низкий уровень \(структура файлов\)](#54-Низкий-уровень-структура-файлов)
- [6. Администрирование](#6-Администрирование)
    - [6.1 Мониторинг](#61-Мониторинг)
    - [6.2 Сопровождение](#62-Сопровождение)
- [7. Управление доступом](#7-Управление-доступом)
    - [7.1 Роли и их атрибуты](#71-Роли-и-их-атрибуты)
    - [7.2 Привилегии](#72-Привилегии)
    - [7.3 Политики защиты строк \(RLS\)](#73-Политики-защиты-строк-rls)
    - [7.4 Подключение и аутентификация](#74-Подключение-и-аутентификация)
- [8. Резервное копирование](#8-Резервное-копирование)
    - [8.1 Логическое резервирование](#81-Логическое-резервирование)
    - [8.2 Физическое резервирование](#82-Физическое-резервирование)

<!-- /MarkdownTOC -->


## 1. Установка и настройка

### 1.1 Установка сервера

[Инструкция с оф. сайта](https://www.postgresql.org/download/linux/ubuntu/)

    # Настраиваем репозиторий для apt-get
    sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
    
    # получаеи ключ для репозитория
    wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
    
    # собственно установка
    # здесь явно версия 10 указано, можно без указания, тогда актуальную 
    sudo apt-get update
    sudo apt-get -y install postgresql-10

Процесс установки:

* устанавливает в `/usr/lib/postgresql/` и утилиты в `/usr/bin/`
* создает пользователя `postgres` и группу `postgres`
* создает конфигурационные файлы в `/etc/postgresql/` и в `/etc/postgresql-common/` (напр. в `postgresql.conf` задана директория для БД)
* создает кластер БД в директории БД `var/lib/postgresql/10/main`, владелец - группа `postgres` через комманду `initdb`
* логи выводятся в `/var/log/postgresql/postgresql-10-main.log`
* также запускает сервер

### 1.2 Настройка переменных окружения

Все переменные не обязательны, просто для удобства

Добавить в `PATH` каталог с установленным PostgreSQL

**Вариант 1** (для конкретного пользователя):

    # зависит от оболочки, для bash
    # в файл ~/bashrc
    export PATH=$PATH:/usr/lib/postgresql/10/bin

**Вариант 2**

Через каталог `/etc/profile.d`: добавить туда скрипт с раcширением `.sh`

Это будет работать для всех пользователей, но только если они явно логинятся в систему (через `sudo su postgres` не буден работать) (см. login shell / non-login shell по ссылке ниже)

    sudo nano /etc/profile.d
        => PATH=$PATH:/usr/lib/postgresql/10/bin
    # сохранить

**Вариант 3**

Еще вариант - редактирование `/etc/environment`

[Подробно про переменные](https://stackoverflow.com/questions/14637979/how-to-permanently-set-path-on-linux-unix)

Можно создать переменную PGDATA (путь к директории БД (напр. `var/lib/postgresql/10/main`) )


### 1.3 Начало работы

#### 1.3.1 Пользователи ОС для сервера Postgres

Лучше использовать созданного в процессе установки пользователя `postgres` с одноименной группой. У него уже настроены необходимые разрешения.

Можно создать еще пользователя (зачем?): 

* `sudo adduser new_user`
* включить его в группу 134 ssl-cert (так у стандартного)
* дать новому пользователю права на `/var/run/postgresql` (через включение его в группу `postgres` ??)

#### 1.3.2 **Создание кластера БД**

Кластер - группа баз данных, управляемых одним экземпляром сервера Postgres

Для создания кластера необходимо:

* создать директорию для кластера БД, назначить владельцем пользователя `postgres`
    - `mkdir /var/lib/postgresql/10/testcluster`
    - `sudo chown postgres /var/lib/postgresql/10/testcluster`
    - `ls -l` покажет владельцев
* инициализировать кластер БД (от имени пользователя)
    - `sudo su postgres`
    - `initdb -k -D  /var/lib/postgresql/10/testcluster`
    - здесь `-k` включает подсчет контрольной суммы страниц (для обнаружения повреждений БД (влияет на производительность))
* вывод результата инициализации должен показать команду для запуска сервера

#### 1.3.3 Запуск / остановка

Если была стандартная установка сервер уже запущен.

Способы запуска:

* **pg_ctl** - низкоуровневая
    - `pg_ctl -D <каталог кластера> start`
* **pg_ctlcluster** - обертка над **pg ctl**, запускает по имени кластера
    - `pg_ctlcluster <версия кластера> <имя> start`

Кластера создаются по разному. При установке например, настройки хранятся в `/etc/postgresql/10/main` (в т. ч. конфигурационный файл). При создании кластера через `initdb -k -D ...` все настройки хранятся в том же каталоге, что и данные. 

Если конфигурационный файл расположен внутри кластера, можно запустить через `pg_ctl -D ... start`.

Если конфигурационный файл отдельно расположен, нужно указывать путь к нему `pg_ctl -D /var/lib/postgresql/10/main -o "-c config_file=/etc/postgresql/10/main/postgresql.conf" start`. Здесь через `-o` параметры передаются в команду `postgres` 

### 1.3.4 Команда pg_ctlcluster

* обертка для **pg_ctl**
* запускает по имени кластера
* внутри проверяет версию кластера и т. п. и запускает подходящую команду `pg_ctl`
* логи по умолчанию пишутся в `/var/logs/postgresql-<версия>-<имя кластера>`
* команды: start, stop, reload, status
* можно передавать параметры в вызываемую **pg_ctl**
* настройки может сохранять в `/etc/postgresql/<версия>/<имя>` или в директории кластера, в т. ч. **postgresql.conf** 

### 1.3.5 Где мои логи, чувак?

Смотрим переменную `log_destination` (метод логгирования):

    SHOW log_destination;

Там несколько вариантов может быть:

* `stderr` - по умолчанию
* `csvlog` - в формате csv
* `syslog` - пересылка логов сервисом, много настроек куда и как.
* `eventlog` - только для Win

Если `stderr`, также скорее всего куда-то перенаправляются.

Например при запуске через `pg_ctl -D ... start` вывод идет в терминал. Можно указать файл при запуске `pg_ctl -D ... -l mylog`. 

Стоит проверить переменную `logging_collector`

    SHOW logging_collector;

Если включен, значит см. переменные `log_directory` (если относительный - в каталоге кластера), `log_filename`.

Если выключен, системное расположение используется:

    # определить PID процесса
    # так например текущего psql
    select pg_backend_pid();
        => 31314
    # можно через top корневого postgres
    # затем проверить симлинк
    \! ls -l /proc/31314/fd/2
        => /var/log/postgresql/...
    # или из обычного терминала
    ls -l ....


**TODO**:

Просмотр процессов в терминале (м. б. top ?)

Запуск по умолчанию: systemd??? отключить, управление????

## 2. Утилита psql

### 2.1 Подключение к серверу

 Это терминальный клиент для работы с сервером PostgreSQL.

    psql -d <имя БД в кластере> -U <роль> -h <узел> -p <порт> 
    # после этого переход в режим ввода

Можно пробовать подключаться без указания параметров, тогда имя БД и роль будут браться по имени текущего пользователя (поэтому от имени пользователя `postgres` надо):

    sudo su postgres 
    psql

### 2.2 Основные команды

Команды начинаются с `\`.

Основные команды:

* `\c` - подключение к новой БД
* `\conninfo` - информация о текущем подключении 
* `\?` - справка по командам psql
* `\h` - список команд SQL
* `\h <имя комманды>` - синтаксис конкретной команды
* `\q` - выход

### 2.3 Выполнение скриптов при запуске

Можно настроить скрипты, выполняемые при запуске `psql`. Для этого общесистемный файл `psqlrc` или пользовательский `~/.psqlrc`. 

Общесистемный файл расположен в каталоге с настройками. Посмотреть расположение этого каталога `pg_config --sysconfdir`

Например так из оболочки под пользователем `postgres`

    # отображение времени выполнения запроса
    echo "\timing on" >> ~/.psqlrc
  
    # просмотрщик для результатов запросов
    echo "\setenv PAGER 'less -X'" >> ~/.psqlrc
    # можно флаг N еще добавить для вывода строк или в процессе работы переключать через `-N`. См. `man less`

### 2.4 Форматирование вывода

Полный список атрибутов можно посмотреть:

    \pset

Есть краткие команды:

* `\a` - переключение режима с выравнивания и без
* `\t` - переключение режима с выводом заголовков, итоговой строки и без
* `\x` - переключение режима вывода колонок в строки / в колонки

### 2.5 Разное

Выполнение команд оболочки: через `\!`

    \! pwd
    \! uptime

Запись в файл:

    # переключили в режим вывода в файл
    \o some_file 
    # здесь любые команды, результат выводится в файл
    ....
    # переключаем обратно
    \o 
    # можно посмотреть файл
    \! cat some_file

Запуск команд из файла:

    \i some-file
    # или из оболочки
    psql <some-file
    psql -f some-file

### 2.6 Переменные psql и переменные окружения

Аналог переменных окружения.

Устанавливаются через `\set` / `\unset`. Просмотр через `\echo`, полный список через `\set`

В переменную можно записать результат запроса:

    # внимание на отсутствие ;
    select now() as cur_time \gset
    \echo cur_time

В переменные можно записать текст запроса и выполнять его через переменную:

    \set cur_time 'select now();'
    # запуск
    :cur_time
    # просмотр переменной
    \echo :cur_time

Приглашения ввода:

    \set PROMPT1 '%n@%/%R%# '
    \set PROMPT2 '%n@%/%R%# '

Можно записать это в файлы `psqlrc`, тогда будет доступ всегда при запуске.

Работа с системными переменными из psql:
    
    # установка
    \setenv PAGER 'less -XSN'
    # просмотр
    \! echo $PAGER



## 3. Конфигурация

Разные параметры конфигурации можно устанавливать:

* для всего сеанса сервера
* для отдельной БД 
* для пользователя
* во время работы клиентского сеанса

### 3.2 Файл postgresql.conf

Главный источник параметров - файл `postgresql.conf`. Может находится или в каталоге с данными, или отдельно (напр. `/etc/postgresql`)

Посмотреть расположение (в pqsl):
    
    # команда SQL
    SHOW config_file;
    # показать все параметры
    SHOW ALL;

При изменении в файле, нужно чтобы сервер перечитал этот файл. Есть разные способы:
    
    # 1. через утилиты pg_ctl / pg_ctlcluster
    $ pg_ctl reload
    # 2. послать сигнал главному процессу сервера postmaster
    $ kill -HUP
    # 3. через psql
    => SELECT pg_reload_conf();

Для некоторых параметров может требоваться перезагрузка

### 3.3 Файл postgresql.auto.conf

Предназначен для редактирования конфигурационных параметров посредством команд SQL. Доступ к файлу не нужен:

    # установка значения (добавляет строку в файл)
    ALTER SYSTEM SET <параметр> TO <значение>;
    # удаление параметр (строку файла)
    ALTER SYSTEM RESET <параметр>;
    # удаление всех параметров из файла
    ALTER SYSTEM RESET ALL;

Файл считывается после `postgresql.conf`, т. е. настройки `postgresql.auto.conf` имеют приоритет

Всегда расположен в каталоге кластера БД.

Напрямую редактировать не стоит.

Чтобы изменения вступили в силу, также нужно чтобы сервер перечитал конфигурацию

### 3.4 Представление pg_file_settings

Одно из системных представлений.

    SELECT * FROM pg_file_settings;

Показывает сводное содержимое файлов конфигурации. Показывает, что есть в файлах, а не то, что сервер использует в данный момент. Для просмотра состояния сервера см. **pg_settiings**.

Колонки:

* `sourcefile` - файл-источник параметра (напр. `postgresql.conf`)
* `sourceline` - строка в файле
* `applied` - true/false может ли это изменение быть применено успешно
* `error` - описание ошибки

Если конфигурационный файл содержит синтаксические ошибки, представление будет содержать одну или нескольно строк с описанием ошибки.

### 3.5 Представление pg_settings

Показывает действующие значения конфигурационных параметров

    SELECT * FROM pg_settings;

Колонки:

* `name`, `setting`, `unit` - имя параметра, значение и единица измерения
* `boot_val` - значение по умолчанию
* `reset_val` - если во время сеанса будет вызвана команда `ALTER SYSTEM RESET`
* `source` - источник значения параметра
* `pending_restart` - значение изменено (например через конфигурационный файл) и требуется перезагрузка сервера
* минимальное и максимальное значение параметра

Колонка **context** описавает как можно изменить значение параметра:

* **internal** - это внутренний параметр, изменить непосредственно нельзя (пересобрать сервер может быть)
* **postmaster** - для изменения требуется перезапуск сервера
* **sighub** - можно без перезапуска, перечитав конфигурацию (reload)
* **superuser** - можно изменять в файле конфигурации или в сеансе ( команда SQL `SET`), но только суперпользователю. Параметры установленные через `SET` имеют больший приоритет, чем в файле конфигурации
* **user** - аналогично, но любой пользователь




### 3.6 Пользовательские параметры

Можно создавать свои параметры теми же способами, что и предопределенные:

* редактирование файла `postgresql.conf`
* через SQL команду `ALTER SYSTEM SET`
* установка на время сеанса через команду `SET`
* установка в запросе через функцию `set_config()`

Главное правило: имя должно содержать `.`, чтобы не путать с системными параметрами.

    SELECT CASE WHEN current_setting('myapp.currency_code', true) IS NULL THEN
                set_config('myapp.currency_code', 'RUB', false)
            ELSE
                current_setting('myapp.currency_code')
            END;




## 4. Архитектура

### 4.1 Многоверсионность

#### 4.1.1 Суть многоверсионности

Введена для решения проблем при многопоточном доступе. Если несколько процессов одновременно хотят записать данные в одну строку, вынуждены ставить блокировку и процессы будут ждать. Если есть читающий и пишущий процесс тоже нужна блокировка, чтобы не нарушить консистентность, но это будет влиять на производительность.

Поэтому Postgres каждую строку таблицы БД хранит в нескольких версиях. Строка имеет отметку о начале действия и конце действия. В качестве меток выступают номера транзакций (они выдаются по нарастающей, поэтому могут играть роль отметок времени).

Так например INSERT создает строку с началом действия. UPDATE устанавливает конец действия и создает новую строку. DELETE устанавливает конец действия.

Чтение выполняется через **снимок данных**. Определяются еще активные транзакции и выбираются действующие версии строк. 

Для хранения информации о транзакциях используется специальный файл в каталоге данных (**pg_xact**). Также есть буфер в памяти. Два бита на каждую транзакцию: зафиксирована и отменена. При этом сами данные не меняются, поэтому работает быстро.

Итого: блокировки на строки для чтений не устанавливаются никогда (ни для чтение-чтение, ни для чтение-запись). Блокировки устанавливаются только на запись-запись. Блокировки могут устанавливаться на таблицы: запрет удаления пока идет чтение, запрет чтения при перестроении таблицы.

Можно это увидеть через запросы:

    SELECT *, xmin, xmax FROM t;

Также можно посмотреть текущую транзакцию:

    BEGIN;
    SELECT txid_current();


#### 4.1.2 Очистка

Получается, что в таблице хранится несколько версий строки. Это ведет к разрастанию таблиц со временем, хотя среди этих версий будут версии больше не нужные.

Периодически запускается процесс очистки (vacuum). 

Два варианта:

* **частичная очистка** - помечает ненужные версии, фактически они остаются в файле, но на их место можно записывать новые строки. Этот процесс работает параллельно с основным процессом сервера. Но размер БД не уменьшается.
* **полная очистка** - перестраивает файл БД, удаляя ненужные строки и уменьшая размер. Но при этом блокирует таблицу.

Есть процесс `autovacuum launcher`:

* отслеживает работу с таблица и решает когда нужна очистка
* запускает дочерние процессы по очистке




### 4.2 Уровни изоляции

**Read uncommitted** - разрешает чтение незафиксированных транзакций. PostgreSQL не поддерживает.

**Read committed** - снимок строится на момент начала оператора. Поэтому одинаковые запросы внутри транзакции могут давать разные результаты. Это режим по умолчанию.

**Repeatable read** - снимок строится на момент первого оператора транзакции.

**Serializable** - полная изоляция. Как будто транзакции выполняются последовательно.



### 4.3 Буферный кеш и журналирование

#### 4.3.1 Буферный кеш

Буферный кеш: для согласования скорости работы оперативной памяти и дисков. Кеш состоит из массива буферов, содержащих страницы данных. Размер страницы задается при сборке PostgreSQL (8 кб обычно).

Любой запрос данных - сначала обращение к буферному кешу. Если нет в кеше, тогда обращение к ОС для чтения с диска (ОС свои кеши имеет).

На буферный кеш также устанавливаются блокировки при совместном доступе.

Если кеш заполнен, страницы нужно **вытеснять** из буфера и тогда можно заменять новыми. Если страница изменялась (**грязный буфер**), её нужно записать на диск. В первую очередь вытесняются страницы, которые дольше других не использовались.

#### 4.3.2 Журнал предварительной записи

Буферный кеш улучшает производительность, но возникает проблема потери кеша при сбоях. Для решения - журналирование: записи об операциях, позволяющие выполнить операции повторно при необходимости.

Записи об операциях создаются сразу на диск до выполнения самой операции - поэтому **журнал предварительной записи** (WAL). Располагается в `PGDATA/pg_wal`

Под журналирование попадают таблицы, индексы, состояние транзакций (xact), не попадают - временные и нежурналируемые таблицы (при сбоях данные в таких таблицах не восстанавливаются).

Обычно запись в журнал быстрее выполняется чем запись страниц в файл данных: запись в журнал это последовательная запись, а не произвольная. Справляются обычные HDD.

Два режима журналирования:

* **Синхронный**: запись в журнал выполняется сразу явно на диск (не в буфер ОС). При этом транзакция будет ждать окончания записи, это не быстрая операция.
* **Асинхронный**: на диск записи журнала переносятся отдельным фоновым заданием `walwriter`. Производительность повышается, но есть риск потерять записи журнала, хотя согласованность данных все равно обеспечивается.

Настраивается свойством `synchronous_commit`

Журнал можно применять и для других целей. Зависит от уровня ведения:

* **Minimal** - гарантия восстановления после сбоя
* **Replica** - значение по умолчанию, резервное копирование и репликация
* **Logical** - логическая репликация

Просмотр текущего объема журнала (вернет указатель на текущую запись в байтах, можно вычесть два указателя, чтобы получить изменение размера):

    SELECT pg_current_wal_lsn() AS pos1 \gset
    ...
    SELECT pg_current_wal_lsn() AS pos2 \gset
    SELECT :'pos2'::pg_lsn - :'pos1'::pg_lsn;

Посмотреть содержимое каталога PGDATA/pg_wal (это файлы по 16 МБ):

     SELECT * FROM pg_ls_waldir() ORDER BY name;

#### 4.3.3 Контрольные точки

Если произошел сбой, сервер после запуска начинает восстановление. Читаются и последовательно выполняются записи журнала, которые не попали на диск. 

Чтобы не просматривать весь журнал, формируются **контрольные точки**: в процессе работы сбрасываются все грязные буферы. Т. е. гарантируется, что до контрольной точки все изменения есть на диске.

Процесс создания контрольной точки может занимать длительное время: 50% - 90% времени между контрольными точками. Это нормально: не сильно влияет на производительность.

#### 4.3.4 Процессы, обслуживающие буферный кеш и журнал

**walwriter** - выполняет асинхронную запись журнала на диск. При синхронной записи это делает процесс, обслуживающий транзакцию

**checkpointer** - создает контрольные точки, сбрасывая грязные буферы на диск

**bgwriter** - фоновый процесс, также сбрасывает грязные буферы, которые с большой вероятностью будут вытеснены вскоре. Освобождает основные процессы от этой работы.

**обслуживающие процессы**, вытесняющие оставшиеся грязные буферы

Посмотреть дочерние процессы главного процесса:

    ps -o pid,command --ppid `head -n 1 $PGDATA/postmaster.pid`




## 5. Организация данных

### 5.1 Базы данных и схемы

#### 5.1.1 Шаблонные базы данных

##### 5.1.1.1 Зачем нужны

При инициализации кластера (команда `initdb`) создаются три одинаковые базы данных.

* **postgres** - используется при подключении по умолчанию пользователем postgres. Особо не нужна, но удалять не рекомендуется (наличии подразумевается некоторыми утилитами)
* **template1** - шаблон для создания любой новой базы. В эту базу можно добавлять объекты и расширения, они будут попадать в любую новую базу
*  **template0** - никогда не должна меняться. Используется для восстановления из архива утилитой pg_dump. Также при создании новой БД с кодировкой отличной от кодировки кластера.

Так например полный синтаксис создания БД (по факту копирование происходит):

    CREATE DATABASE <name> TEMPLATE <template_name>;

По умолчанию в качестве шаблона - **tempalte1**

Можно создать собственный шаблон (см. [здесь](https://postgrespro.ru/docs/postgresql/10/manage-ag-templatedbs.html))

##### 5.1.1.2 Разные команды 

    # просмотр списка баз:
    psql -l

    # подключение к БД:
    \с имя_бд

    # просмотр баз данных изнутри БД через представление pg_database
    # имя, шаблон или нет, разрешено подключение, лимит подключений
    SELECT datname, datistemplate, datallowconn, datconnlimit FROM pg_database;

    # создание БД (поключен к другой)
    CREATE DATABASE db; # можно выбрать шаблон явно

    # удаление (подключен должен быть к другой)
    DROP DATABASE db;

    # переименование (подключен к другой)
    ALTER DATABASE db RENAME TO db1;

    # просмотр размера БД
    SELECT pg_database_size('appdb');
    SELECT pg_size_pretty(pg_database_size('appdb'));

#### 5.1.2 Схемы

##### 5.1.2.1 Для чего нужны

Схемы - это пространство имен для объектов БД. Используется для разделения объектов на логические группы, избежания конфликтов имен. Каждый объект внутри БД принадлежит какой-то схеме. Если явно не указано - есть схема по умолчанию с именем `public`. Ничем особенным не отличается: просто есть по умолчанию и включается по умолчанию в путь поиска.

[подробнее](https://postgrespro.ru/docs/postgresql/10/ddl-schemas.html)

В общем такая иерархия: кластер содержит базы данных, базы данных содержат схемы, внутри схем расположены объекты. Клиент подключается одновременно только к одной БД, но внутри может работать с объектами любых схем.

К объектам можно обращаться по полному квалифицированному имени `схема.имя_объекта`. Такое имя однозначно идентифицирует объект. 

##### 5.1.2.2 Путь поиска

Если имя схемы не указано объект будет определятся с использованием **пути поиска (search_path)**. Это обычный конфигурационный параметр. Содержит перечень схем, по которым выполняется поиск по порядку. В пути могут находиться несуществующие схемы или те, на которые у пользователя нет прав. Такие исключаются из просмотра.

Значение по умолчанию: `$user, public`. `$user` - схема с именем текущего пользователя, пока ее явно не создали, отсутствует.

Неявно включаются:

* схема `pg_temp_nnn` - схема временных таблиц на время сеанса или транзакции
* `pg_catalog` - служебные объекты

Если эти схемы явно не указаны, тогда будут на первом месте, если явно указали - тогда там, где заявлены.

##### 5.1.2.3 Команды, функции работы со схемами

    CREATE SCHEMA имя_схемы;

    DROP SCHEMA имя_схемы;

    # удаление не пустой схемы:
    DROP SCHEMA имя_схемы CASCADE;

Любые операции над таблицами можно с указанием схемы:

    CREATE TABLE myschema.mytable (...);

Изменение схемы: 

    ALTER TABLE t SET SCHEMA new_schema;

Просмотр списка схем:

    \dn # от data namespace

Просмотр пути поиска:

    SHOW search_path;

Просмотр "эффективного" пути поиска:

    SELECT current_schemas(true);

Таблицы и их схемы:

    \dt # 

Установка пути поиска:

    # на время сеанса
    SET search_path = ...;
    # можно через файлы psqlrc, но это будет действовать для всего кластера
    
    # лучше устанавливать для БД
    ALTER DATABASE имя SET search_path = ..; 



### 5.2 Системный каталог

**Системный каталог** - набор таблиц/представлений с описанием объектов БД и кластера.

Расположен в схеме `pg_catalog`. Альтернативный вариант - `information_schema`.

В каждой БД создается свой набор системных таблиц. Часть этих таблиц будет общими для всех баз кластера. Например `pg_database`.

Правила наименования: 
    
    pg_<имя таблицы>.<префикс из 3-х символов><имя колонки>

Например: pg_database.datname

Содержимое хранится в нижнем регистре.

Таблицы системного каталога в качестве первичного ключа используют особый тип **OID**. Это целочисленный тип с автоинкрементом. Поэтому легко можно переименовывать сущности БД, т. к. имя - просто атрибут.

Для некоторых таблиц есть специальные представления/функции для преобразования OID в текстовое представление (имя сущности) и обратно. Это **Reg-типы**.

В общем случае к данным системного каталога можно обращаться через SQL команды или команды psql (обычно с `d` начинаются, с суффиксом `S` - системные)

    # все системные объекты
    \dS
    # базы данных
    SELECT * FROM pg_database;
    # схемы
    SELECT * FROM pg_namespace;
    # здесь например колонка nspowner - OID пользователя


Важная таблица **pg_class**: содержит описание разных объектов (таблиц, представлений, индексов и др.), описываемых термином *отношения* (*relations*). Колонка `relkind` уточняет этот тип.

Для отдельных типов есть более удобные представления:

    SELECT * FROM pg_tables;
    SELECT * FROM pg_views;

Есть аналогичные команды:

    \dt
    \dv
    # модификатор + дает больше информации
    \dt+
    # для конкретного объекта по имени
    \d mytable

Для изучения структуры системного каталога можно включить вывод запросов, выполняющихся при использовании команд:

    \set ECHO_HIDDEN on
    \dt

Пример преобразования OID:

    SELECT a.attname, a.atttypid FROM pg_attribute a
        WHERE a.attrelid = 'employees'::regclass AND a.attnum > 0;




### 5.3 Табличные пространства

#### 5.3.1 Основы

**Табличные пространства** определяют физическое расположение данных в файловой системе. Например одно ТП на медленных дисках для редко используемых данных, другое - на быстрых.

При инициализации кластера создаются 2 ТП:

* **pg_default** - пространство по умолчанию, где создаются объекты, если не указано явно
* **pg_global** - для хранения объектов системного каталога, общих для кластера

В одном ТП может быть несколько баз данных. Одна БД может хранить данные в нескольких ТП.

По сути ТП это указатель на каталог файловой системы: 

* `pg_global` - `$PGDATA/global/`
* `pg_default` - `$PGDATA/base/`

При создании своего ТП, указываем каталог явно. Допонительно PostgreSQL создает симлинки в `$PGDATA/pg_tblspc/`

Внутри `$PGDATA/base/` еще деление по БД. Если создается пользовательское ТП, внутри автоматически создаются директории под версию сервера (для переносимости)

Внутри каталогов хранятся объекты: каждый объект в своем файле.

#### 5.3.2 Команды для работы с ТП

Просмотр:
    
    # покажет размер и расположение (для стандартных - пустое)
    \db+

    SELECT * FROM pg_tablespace;

    # где таблицы находятся
    SELECT tablename, tablespace FROM pg_tables;

Работа с ТП:

    # создаем новое
    # нужен пустой каталог, владелец - пользователь postgres
    CREATE TABLESPACE new_ts LOCATION '/home/postgres/new_ts_dir';

    # создаем базу в новом ТП
    # тогда все таблицы этой БД по умолчанию будут в этом ТП
    CREATE DATABASE db TABLESPACE new_ts;

    # но можно явно задавать
    CREATE TABLE t() TABLESPACE pg_default;

Можно перемещать между ТП, при этом копирование файлов происходит и объект блокируется на время перемещения.

    ALTER TABLE t1 SET TABLESPACE pg_default;
    # или все объекты
    ALTER TABLE ALL IN TABLESPACE pg_default SET TABLESPACE ts;

    # можно для всей БД (находясь в другой)
    ALTER DATABASE db SET TABLESPACE pg_default;

Просмотр размера:

    SELECT pg_size_pretty( pg_tablespace_size('ts') );

Удалять можно только пустые ТП. Как с БД использовать `CASCADE` нельзя, т. к. несколько баз может использовать, а подключены только к одной
    
    DROP TABLESPACE ts;


### 5.4 Низкий уровень (структура файлов)

#### 5.4.1 Слои, сегменты

Каждому объекту БД (таблица, индекс и т. п.) соответствует несколько **слоев** (**forks**). Каждому слою соответствует файл. Если файл вырастает больше 1 ГБ, создается следующий файл слоя. Такие файлы - **сегменты**.

Имена файлов состоят из OID объекта, префикса слоя и номера сегмента. Например `13131_fsm.1` - сегмент 1 слоя fsm объекта с OID = 13131.

Таким образом одной таблице будет соответствовать минимум 3 файла, индексу - 2. Все они будут расположены в одном каталоге (если в одном пространстве). Т. к. файловые системы могут не очень работать с большим количеством файлов в одном каталоге, есть возможность оптимизации (разноска по пространствам ??).

Файлы делятся на страницы / блоки размером что и страницы буферного кеша (8 КБ  обычно). Собственно эти страницы файлов и попадают в буферный кеш.

Виды слоев:

* **основной** - собственно данные
    - например версии строк таблицы, строки индексов
    - существует у всех объктов
    - имена без префикса
* **слой инициализации** - есть у нежурналируемых объектов, например временных таблиц
    - используется для замены основного слоя при сбое
    - префикс `_init`
* **free space map (карта свободного пространства)**
    - показывает свободные строки, возникающие после очистки
    - для ускорения процесса вставки новых строк
    - появится только после очистки `VACUUM`
    - префикс `_fsm`
* **visibility map (карта видимости)**
    - отмечает страницы, в которых только актуальные версии строк
    - для оптимизации очистки и поиска
    - есть только для таблиц
    - префикс `_vm`

#### 5.4.2 Хранение длинных строк и таблицы TOAST

Любая версия строки (файл, собственно строка, большое число) должна помещаться на страницу файла.

Для длинных строк применяются разные стратегии: попытается сжать и/или вынесет в отдельную **TOAST-таблицу**. Такие таблицы расположены в пространстве `pg_toast` или `pg_toast_temp_N` для временных. По умолчанию не видны, но можно посмотреть:

    SELECT chunk_id, chunk_seq, length(chunk_data) FROM pg_toast.pg_toast_16428`);

Для таблиц TOAST также правило строка на файл, поэтому может разбивать на части. Версионность для таких таблиц своя, поэтому несколько версий строки основного файла могут ссылаться на одну строку таблицы TOAST.

#### Команды для работы с файлами, слоями, TOAST

Базовый каталог объекта можно получить по его имени:
    
    SELECT pg_relation_filepath('my_table');
        => base/16499/16502

Или получить OID объекта:
    
    SELECT OID FROM pg_database WHERE datname = 'my_table';

Также можно использовать утилиту `oid2name` (входит в стандартную установку)

Размеры объектов:

    # по слоям:
    SELECT pg_relation_size('t','main') main, pg_relation_size('t','fsm') fsm;
    
    # таблица без индексов
    SELECT pg_table_size('t');
    
    # индекс таблицы
    SELECT pg_indexes_size('t');
    
    # размер всей таблицы
    SELECT pg_total_relation_size('t');

Работа с TOAST:

    # есть ли у таблицы соответствующая TOAST-таблица:
    # смотрим колокну в таблице pg_class
    SELECT reltoastrelid FROM pg_class WHERE relname='t'
    # можно дополнительно реквизиты самой таблицы TOAST
    SELECT * FROM pg_class WHERE oid = ..;

Стратегии работы с длинными строками можно посмотреть через `\d+ <имя таблицы>`, колонка `Storage`:

* **plain** - тип фиксированной длины, TOAST не используется
* **main** - приоритет сжатия
* **extended** - попытается сжать, если результата не увидит - отдельное хранение 
* **external** - сразу отдельное хранение

Можно поменять стратегию (начнет действовать для новых данных):

    ALTER TABLE t ALTER COLUMN n SET STORAGE extended;



## 6. Администрирование

### 6.1 Мониторинг

#### 6.1.1 Стандартные средства ОС

Стандартные стредства ОС:

* процессы:
    - `ps aux |grep ^postgres`
* ресурсы: iostat, vmstat, sar, top
* дисковое пространство: df, du, quota

#### 6.1.2 Внутренняя статистика

Внутренняя статистика PostgreSQL:

* собственно статистика, собираемая сервером и хранящаяся внутри
    - текущая активность процессов
    - разнообразная статистика, собираемая через **stats collector**
* логи

Просмотр текущей активности всех процессов: представление **pg_stat_activity** (autovacuum, client backend, walwriter и т. п.) и другие. Настройка: параметр `track_activities`, включена по умолчанию, отключать не следует. 

Аналогичная команда ОС:
    
    ps -o pid,command --ppid `head -n 1 $PGDATA/postmaster.pid`

Сбор статистики может выполняться фоновым процессом **stats collector**. Каждый обслуживающий процесс сервера собирает статистику о своей работе и передает её коллектору. Коллектор периодически (обычно раз в 0.5 сек) сбрасывает статистику во временные файлы в `$PGDATA/pg_stat_tmp` (можно в память перенести для повышения производительности). По запросу последняя версия статистики читается из этого каталога. При остановке сервера сбрасывается в каталог `$PGDATA/pg_stat`. Счетчики статистики обнуляются по команде или при восстановлении после сбоя.

Можно подключать расширения (входящие в поставку и внешние), позволяющие собирать дополнительную информацию: pg_stat_statements (по запросам), pg_stat_plans (по планам запросов) и др.

#### 6.1.3 Логи

Основной параметр - `log_destination`: список приемников сообщений (stderr, syslog, csvlog)

Дополнительно можно включить процесс - коллектор сообщений (параметр `logging_collector`). Этот коллектор будет записывать логи в файлы, определяемые параметрами `log_directory` и `log_filename`. Можно ротацию настраивать. Особенность коллектора - гарантирует запись сообщения (в отличие от syslog), поэтому при нагрузке процессы могут ждать ответа от коллектора -> снижение производительности.

По умолчанию минимально настроен вывод логов. Можно включать (разные варианты: для БД, для кластера, на время сеанса):

* `log_min_messages` - уровень логгирования
* `log_min_duration_statement` - команды, выполнявшиеся больше заданного времени
* `log_duration` - время выполнения команд
* `log_statement` - сами команды
* и др.

Анализ логов: 

* средства ОС: grep, awk, cat, tail и т. п.
* внешние утилиты, например **pgBadger** (требует настройки логов)

#### 6.1.4 Примеры работы статистики

Имитация работы: утилита `pgbench`:

    # создаем тестовую базу
    CREATE DATABASE testdb;
    # инициализируем утилиту (создает таблицы)
    \q
    pgbench -i testdb

    # сброс статистики
    SELECT pg_stat_reset(); # это сброс на уровне базы данных
    SELECT pg_stat_reset_shared('bgwriter'); # это на уровне кластера

    # запуск теста
    pgbench -T 10 testdb 
    # в выводе tps - число транзакций в секунду

**Статистика обращения к таблицам (`pg_stat_all_tables`)**
    
    SELECT * FROM pg_stat_all_tables WHERE schemaname = 'public' \gx
        relid               | 16398
        schemaname          | public
        relid               | 16398
        schemaname          | public
        relname             | pgbench_history
        seq_scan            | 0
        seq_tup_read        | 0
        idx_scan            | 
        idx_tup_fetch       | 
        n_tup_ins           | 7697
        n_tup_upd           | 0
        n_tup_del           | 0
        n_tup_hot_upd       | 0
        n_live_tup          | 7697
        n_dead_tup          | 0
        n_mod_since_analyze | 0
        last_vacuum         | 2021-08-19 10:47:04.814125+03
        last_autovacuum     | 
        last_analyze        | 2021-08-19 10:47:04.814536+03
        last_autoanalyze    | 2021-08-19 10:55:51.677843+03
        vacuum_count        | 1
        autovacuum_count    | 0
        analyze_count       | 1
        autoanalyze_count   | 2
   
Покажет: 

* количество вставок, удалений, апдейтов
* количество последовательный чтений таблицы (без использования индекса) `seq_scan`
* количество чтений с использованием индекса `idx_scan`
* количество операций очистки и время последних

**Статистика в терминах страниц буферного кеша (`pg_statio_all_tables `)**

    SELECT * FROM pg_statio_all_tables WHERE schemaname = 'public' \gx
        relid           | 16404
        schemaname      | public
        relname         | pgbench_accounts
        heap_blks_read  | 1671
        heap_blks_hit   | 38086
        idx_blks_read   | 276
        idx_blks_hit    | 34293
        toast_blks_read | 
        toast_blks_hit  | 
        tidx_blks_read  | 
        tidx_blks_hit   | 

Показывает сколько страниц пришлось считать с диска (`..._read`),  а сколько оказалось в кеше (`..._hit`)  

Аналогичная статистика есть конкретно по индексам `pg_stat_all_indexes` и `pg_statio_all_indexes`

**Сводная статистика по БД**

    SELECT * FROM pg_stat_database WHERE datname='testdb' \gx
        datid          | 16397
        datname        | testdb
        numbackends    | 1
        xact_commit    | 7890
        xact_rollback  | 1
        blks_read      | 2334
        blks_hit       | 121880
        tup_returned   | 364146
        tup_fetched    | 19929
        tup_inserted   | 107808
        tup_updated    | 23117
        tup_deleted    | 0
        conflicts      | 0
        temp_files     | 0
        temp_bytes     | 0
        deadlocks      | 0
        blk_read_time  | 0
        blk_write_time | 0
        stats_reset    | 2021-08-19 10:45:36.957315+03

Здесь есть данные по транзакциям и блокировкам.

**Статистика по процессам фоновой записи и контрольных точек**

    # SELECT * FROM pg_stat_bgwriter \gx
        checkpoints_timed     | 179
        checkpoints_req       | 4
        checkpoint_write_time | 307801
        checkpoint_sync_time  | 11
        buffers_checkpoint    | 3814
        buffers_clean         | 0
        maxwritten_clean      | 0
        buffers_backend       | 1753
        buffers_backend_fsync | 0
        buffers_alloc         | 3519
        stats_reset           | 2021-08-17 09:39:49.806519+03

`buffers_clean` - количество страниц, записанных фоновой записью;
`buffers_checkpoint` - количество страниц, записанных контрольной точкой;
`buffers_backend` - количество страниц, записанных серверными процессами.

**Текущие активности и блокировки**

Например есть активная транзакция, другой процесс те же данные пытается изменить и попадает на блокировку.

    SELECT pid, query, state, wait_event, wait_event_type
        , pg_blocking_pids(pid) 
    FROM pg_stat_activity WHERE backend_type = 'client backend' \gx
        pid              | 30562
        query            | UPDATE t SET n = n + 1;
        state            | idle in transaction
        wait_event       | ClientRead
        wait_event_type  | Client
        pg_blocking_pids | {}
        -----------------------------------
        pid              | 30614
        query            | UPDATE t SET n = n + 2;
        state            | active
        wait_event       | transactionid
        wait_event_type  | Lock
        pg_blocking_pids | {30562}

Здесь выбираем все клиентские запросы, смотрим из состояние. Функция `pg_blocking_pids` показывает процессы, которые заблокировали указанный.

Завершить клиентский процесс можно функциями `pg_cancel_backend(pid)`  и `pg_terminate_backend(pid)`. Завершать через `kill -9` не стоит, т. к. эти процессы порождает главный серверный процесс и он следит за их состоянием. Внешнее завершение может посчитать нарушением работоспособности.














### 6.2 Сопровождение

#### 6.2.1 Процедуры очистки (vacuum, autovacuum, полная очистка)

Варианты запуска **vacuum**:

* `VACUUM <имя таблицы>` - очистка таблицы
* `VACUUM` - очистка всей БД
* `$ vacuumdb` - консольная утилита

Работает параллельно с другими транзакциями. Не минимизирует место, занимаемое объектами, не уменьшает размер файлов, просто помечает строки как свободные.

Частый запуск может сказаться на производительности системы, редкий ведет к росту файлов.

Ещё есть фоновый процесс **autovacuum launcher**. Мониторит активность работы с таблицами и при необходимости запускает дочерние процессы **autovacuum worker**, которые выполняют очистку.

Третий вариант - **полная очистка**:

* `VACUUM FULL <имя таблицы>`
* `VACUUM FULL` - вся БД
* `$ vacuumdb --full`
* `TRUNCATE` - похожим образом работает

Блокирует таблицу и индексы полностью, освобождая место. SQL команда `TRUNCATE` подобным образом работает, в отличие от `DELETE`, которая только помечает объекты.

#### 6.2.2 Обновление статистики

Обычно обновлением статистики занимается процесс **autovacuum**. При необходимости можно явно запустить:

* `ANALYZE <таблица>`
* `$ vacuumdb --analyze-only`
* `VACUUM ANALYZE <таблица>` - очистка + обновление статистики
* `$ vacuumdb --analyze` 

При обновлении статистики читается случайная выборка данных определенного размера. Размер можно настраивать

#### 6.2.3 Заморозка номеров транзакций

Счетчик транзакций, используемый в версиях строк, 32-битный. Возможно переполнение. 

Для освобождения номеров процесс автоочисти помечает очень старые транзакции как замороженные и их номера могут присваиваться новым транзакциям. Т. е. пространство номером закольцовано и периодически из него освобождаются номера для повторного использования. 

Сервер может остановить свою работу, если обнаружит сбои в работе механизма заморозки. Придется стартовать заново и выполнять очистку.

#### 6.2.4 Мониторинг индексов

Индексы - сложные структуры, могут сильно расти в размерах.

Выявление проблем:

* `pg_stat_all_ indexes.idx_scan` - не используемые
* `pg_relation_size()` - разрастание
* расширение `pgstattuple`

Перестроение индексов:

* `REINDEX <индекс/таблица/схема/..>` - перестраивает индекс, блокирует таблицу
* `VACUUM FULL` - вместе с очисткой выполняет перестроение

Можно попытаться создать индекс в неблокирующем режиме:

    # создаем индекс параллельно с работой, может из-за блокировок неудачно
    CREATE INDEX <имя> ON .. CONCURRENTLY;
    # удаляем старый 
    DROP INDEX <имя> CONCURRENTLY;






#### 6.2.5 Оценка разрастания таблиц и индексов

Через расширение **pgstattuple**

     CREATE EXTENSION pgstattuple;

    # создаем таблицу
    CREATE TABLE t(id serial, s text);
    # разные манипуляции ...

    SELECT * FROM pgstattuple('t') \gx
        table_len          | 4423680
        tuple_count        | 100000
        tuple_len          | 3388895
        tuple_percent      | 76.61
        dead_tuple_count   | 0
        dead_tuple_len     | 0
        dead_tuple_percent | 0
        free_space         | 16552
        free_percent       | 0.37 

Вот пример после вставки одной строки в пустую таблицу:

    table_len          | 8192       # это размер по умолчанию (1 страница 8 КБ)
    tuple_count        | 1
    tuple_len          | 28
    tuple_percent      | 0.34       # процент, занятый данными
    dead_tuple_count   | 0
    dead_tuple_len     | 0
    dead_tuple_percent | 0
    free_space         | 8128
    free_percent       | 99.22

Вот после удаления строки:

    table_len          | 8192
    tuple_count        | 0
    tuple_len          | 0
    tuple_percent      | 0
    dead_tuple_count   | 1           # освободится после очистки
    dead_tuple_len     | 28
    dead_tuple_percent | 0.34
    free_space         | 8128
    free_percent       | 99.22






## 7. Управление доступом

### 7.1 Роли и их атрибуты  

#### 7.1.1 Роли

Роль это пользователь СУБД. Но в тоже время может быть групповой ролью (включать в себя другие роли). 

Не связана с пользователями ОС.

Привязаны к кластеру. Одна роль может быть владельцем объектов в разных базах. При создании кластера создается одна роль-суперпользователь. Есть псевдороль **public**, в которую неявно включаются все другие роли.

#### 7.1.2 Атрибуты ролей

Атрибуты роли определяют полномочия:

* **LOGIN** - имеет право подключения к БД, т. е. пользователь
* **SUPERUSER** - нет проверок на права доступа, право входа в систему проверяется все равно
* **CREATEDB** - право создания баз данных
* **CREATEROLE** - право создания ролей 

Обычно есть противоположные атрибуты: `NOLOGIN` и т. п.

Управление аттрибутами:

    CREATE ROLE имя [аттрибуты];
    ALTER ROLE имя ...

Для обычной работы можно создать пользователя с `CREATEDB` и `CREATEROLE`, чтобы избежать использования роли суперпользователя.

#### 7.1.3 Групповые роли

Для упрощения управления правами: права действуют на всех участников группы.

    CREATE ROLE group_role;
    # включаем в эту группу роли:
    GRANT group_role TO роль1, ...;
    # исключаем
    REVOKE group_role FROM роль1;

При включении можно дать право управления групповой ролью (право включать/исключать другие роли):
    
    GRANT группа TO роль2 WITH ADMIN OPTION;
    # отзыв этого права:
    REVOKE ADMIN OPTION FOR группа FROM роль2;

Членом группы может быть другая группа. Между групповой и негрупповой ролью принципиальных различий нет.

Право включать и исключать роли в/из групповой роли имеют:

* сама групповая роль
* роль с атрибутом `SUPERUSER`
* роль с атрибутом `CREATEROLE` (кроме включения в суперпользовательскую группу)

Как роль может использовать права групповой роли:

* явно переключившись на групповую роль `SET ROLE`, членом которой является роль (при этом при создании объектов владельцем будет групповая)
* если у роли установлен атрибут **INHERIT** (по умолчанию), она автоматически наследует права групповых (в т. ч. по иерархии наследования)


#### 7.1.4 Примеры работы с ролями

**Создание**:

    # создаем роль с возможностью логина и создания других ролей
    CREATE ROLE alice LOGIN CREATEROLE;

    # заходим под новым пользователем
    \c - alice

    # может создавать другие роли
    CREATE ROLE bob;

**Просмотр списка ролей**:

    \du
    # или
    SELECT * FROM pg_user;

**Установка настроек для пользователя**:

Срабатывают при начале сеанса

    # логгируем все действия пользователя
    ALTER ROLE alice SET log_min_duration_statement=0;

    # или только для конкретной БД
    ALTER ROLE alice IN DATABASE postgres SET log_min_duration_statement=0;

**Переключение между ролями**:
    
    # переключение на суперпользователя  
    \c - postgres
    
    # включение в группу
    GRANT postgres TO alice;
    
    # переключение на пользователя
    \с - alice
    # переключение на роль
    SET ROLE postgres;
    # сброс
    RESET ROLE;

    # просмотр текущей роли: кто начал сессию и под какой ролью сейчас
    SELECT session_user, current_user;
        session_user | current_user 
        --------------+--------------
        alice        | postgres

**Удаление ролей**:

Удалить можно, если нет объектов во владении

    DROP ROLE alice;

Можно передать другой роли все объекты (но могут быть в другой БД)
    
    REASSIGN OWNED BY alice TO bob;

### 7.2 Привилегии

#### 7.2.1 Механизм привилегий

Определяют права доступа ролей к объектам. Различаются для разных объектов.

Привелегии для таблиц:

* `SELECT`, `INSERT`, `UPDATE` - право на чтение, вставку, изменение (можно для столбцов отдельных)
* `DELETE` - удаление строк
* `TRUNCATE` - очистка таблицы
* `TRIGGER` - создание триггеров

Для табличных пространств:

* `CREATE` - право на создание в этом ТП

Для БД:

* `CREATE` - право создавать объекты
* `CONNECT` - право подключения

Роли с точки зрения привилегий:

* Суперпользователи - полный доступ, никакие проверки не выполняются
* Владельцы объектов - выполняется проверка привилегий
    - изначально получают полный набор привилегий
    - плюс права на выдачу/отмену привилегий (в т. ч. у себя)
* Остальные - доступ только по выданным привилегиям

#### 7.2.2 Управление привилегиями

Выдача привилегий:

    GRANT <привилегии> ON <объект> TO <роль>;

Отзыв привилегии:

    REVOKE <привилегии> ON <объект> FROM <роль>;

Выдавать/отзывать привилегии может:

* суперпользователь
* владелец объекта (в т. ч. себе)
* роль, которой привилегии были выданы с правом передачи 

Выдача привилегий с правом передачи:

     GRANT <привилегии> ON <объект> TO <роль> WITH GRANT OPTION;

Отзыв права передачи (если по иерархии передавалась - ключевое слово CASCADE)

    REVOKE GRANT OPTION FOR привилегии> ON <объект> FROM <роль> CASCADE;

Отзыв привилегий может сделать тот, кто выдавал (или суперпользователь). Если роли в иерархии выдавали привилегии - отзыв с `CASCADE`.  


#### 7.2.3 Привилегии от групповых ролей

Роль получает привилегии от групповых ролей в которые входит. 

Если у роли есть атрибут **INHERIT** (по умолчанию так), она автоматически имеет привилегии групповых ролей (в т.ч. роли `public`), в которые входит.

Если у роли атрибут **NOINHERIT**,  тогда необходимо явное переключение через `SET ROLE`. При этом все действия выполняются от имени групповой роли (например, она будет владельцем создаваемых объектов)

#### 7.2.4 Привилегии роли public

По умолчанию роль public (а значит все роли) получают следующие привилегии:

* `CONNECT` (подключение к БД)
* `TEMPORARY` (создание временных таблиц)
* `CREATE` и `USAGE` для схемы public
* `USAGE` для схемы pg_catalog
* `EXECUTE` для функций




#### 7.2.5 Организация ролей для веб приложения

Веб-приложение организует пул соединений, которые подключаются к серверу через одного специального пользователя (не суперпользователя). Под каждого пользователя приложения заводить роль нет смысла, да и сервер не справиться скорее всего.

#### 7.2.6 Команды для работы с привилегиями

**Просмотр привилегий для схем**

    \dn+
         Name  |  Owner   |  Access privileges   | Description 
        -------+----------+----------------------+-------------
         alice | postgres | postgres=UC/postgres+| 
               |          | alice=UC/postgres    | 

Формат: `роль=привилегии/кем даны`

    U - usage
    C - create

**Просмотр привилегий для таблиц**

    \dp+
        Schema | Name | Type  |  Access privileges  | Column privileges |  
        --------+------+-------+---------------------+------------------
        alice  | t1   | table | alice=arwdDxt/alice+|                   | 
               |      |       | bob=r/alice         |                   | 

Если колонка `Access privileges` пустая - это владелец с полным набором привилегий. `*` в привилегии означает, что есть права на передачу.

Формат такой же:

    a = insert
    r = select
    w = update
    d = delete
    D = truncate
    x = reference
    t = trigger

### 7.3 Политики защиты строк (RLS)

Политики защиты строк (RLS, Row Level Security) - управление доступок на уровне отдельных строк. Политики - дополнительный механизм, роли все равно проверяются.

Политики работают через предикаты - логические выражения. Два вида предикатов:

* для существующих строк - используется операторами SELECT, UPDATE, DELETE. Если предикат возвращает ложь, строка не попадает в выборку. Если параметр `row_security = off`, тогда еще и ошибка будет зафиксирована. 
* для новых строк - для операторов INSERT и UPDATE. Если предикат ложен - ошибка фиксируется.

При создании политики можно установить для каких ролей она будет работать и для каких операторов (по умолчанию для всех). Для объектов нужно явно включать использование политик.

Не применяются:

* при проверке ограничений целостности
* для суперпользователей
* для ролей с атрибутом **BYPASSRLS**
* для владельца таблицы, хотя можно включить

Несколько политик могут относится к **разрешительным (permissive)** или **ограничительным (restricted)**. Для разрешительных достаточно срабатывания одного предиката, для ограничительных - должны все быть истинными.

Посмотреть политики можно в через `\dp+`

Политики добавляют накладные расходы к запросам.




### 7.4 Подключение и аутентификация

#### 7.4.1 Конфигурационный файл pg_hba.conf 

Задачи при подключении:

* Идентификация - определение имени пользователя БД. При внешней аутентификации может быть отличным от того, что указал пользователь
* Аутентификация - пользователь тот, за кого себя выдает? Например через пароль.
* Авторизация - есть ли права на подключение?

Конфигурационный файл **pg_hba.conf** (host-based authentication). Обычно в `$PGDATA`, но можно уточнить через конфигурационный параметр `hba_file` (`SHOW hba_file;`). При изменении - сервер должен перечитать. Посмотреть можно через представление

    SELECT * FROM pg_hba_file_rules;

Это же представление можно использовать для проверки корректности файла после изменений.

Состоит из записей. Строки обрабатываются сверху вниз. Строки проверяются по порядку, могут ли они применятся к запрашиваемому подключению. Если может - выполняется аутентификация по указанному методу. Если успешно - разрешается подключение. Если не успешно - подключение запрещается, другие строки не рассматриваются.

По умолчанию безусловно разрешены все локальные подключения (сетевые и через сокеты).

#### 7.4.2 Поля конфигурационного файла

Поля файла:

* **Тип подключения**:
    - *local* - локальное подключение через доменный сокет (без сетевого)
    - *host* - любое подключение по TCP/IP. Сервер по умолчанию слушает только localhost, поэтому потребуется настраивать параметр `listen_address`
    - *hostssl* - подключения с шифрованием ssl. Также см. параметр `ssl`
    - *hostnosll* - только нешифрованные соединения
* **Имя базы данных** (можно список через зпт):
    - *all* - любая
    - *sameuser* - та же, что имя пользователя
    - *samerole*
    - просто имя БД
* **Адрес узла**:
    - *all* - любой IP
    - IP-адрес / маска подсети
    - *samehost* - соответствует IP-адресу сервера (если 127.0.0.1 не разрешен)
    - *samenet* - любой адрес из любой подсети к которой подключен сервер
    - доменное имя или часть, начиная с точки
* **Имя роли/пользователя**:
    - *all* - любая
    - имя роли 
    - +роль - входящие в указанную роль
    - можно список или ссылку на файл через `@`
* **Метод аутентификации**:
    - простые
        + **trust** - безусловная, без проверки
        + **reject** - всегда отказ
    - по паролю
        + **md5** - по паролю, хранится в БД, шифруется md5 (слабое шифрование)
        + **scram-sha-256** - аналогично, но другой алгоритм шифрования
        + **ldap**
    - внешние
        + **peer** - запрос у ядра ОС при локальных подключениях. Просто проверяет пользователя ОС по имени, если залогинен можно доверять
        + **cert** - через сертификаты
        + **gss** - Kerberos

Для внешней аутентификации может понадобится соответствие между именами пользователей в этой внешней системе и в СУБД. Для этого файл `pg_ident.conf`. Его расположение - параметр `ident_file` (`SHOW ident_file;`).

#### 7.4.3 Работа с паролями

    CREATE | ALTER ROLE ... PASSWORD 'пароль' | VALID_UNTIL дата_время

Метод шифрования должен соответствовать методу аутентификации. См. параметр `password_encryption`.

Если установлена аутентификация по паролю, пользователю с пустым паролем будет отказано. 

Хранятся в таблице `pg_authid`.

Ввод пароля можно автоматизировать через переменную `$PGPASSWORD`, но нерекомендуется из соображений безопасности.

Также можно через файл `~/.pgpass`. Файл должен иметь доступ только от владельца. 




## 8. Резервное копирование

### 8.1 Логическое резервирование

#### 8.1.1 Суть, плюсы/минусы 

**Логическое резервирование** - набор команд SQL, которые восстанавливают кластер, базу данных или отдельный объект с нуля.

Плюсы/минусы:

* гибкость: архив - это текстовый файл, можно редактировать
* можно восстанавливать на кластере другой версии. Таким образом можно выполнять миграцию между версиями
* можно на другой архитектуре (ОС, файловая система)
* минус - долго выполняется
* минус - архив только на момент выгрузки (в отличие от например непрерывного копирования)

#### 8.1.2 Команда COPY

[docs](https://postgrespro.ru/docs/postgresql/10/sql-copy)

SQL команда `COPY` записывает таблицу (или результат произвольного запроса) в файл / консоль. 

Другой вариант считывает файл и записывает результат в таблицу (добавлением новых строк).

Работает быстрее чем набор команд `INSERT`.

Два варианта:

* серверная команда SQL `COPY`: файл должен быть доступен пользователю postgres на сервере
* клиентская команда psql `\COPY`: файл должен быть доступен на клиенте тому, кто запускал psql

#### 8.1.3 Утилиты pg_dump и pg_restore

[pg_dump](https://postgrespro.ru/docs/postgresql/10/app-pgdump)
[pg_restore](https://postgrespro.ru/docs/postgresql/10/app-pgrestore)

Результат работы - в файл / консоль либо SQL-скрипт, либо архив в специальном формате с оглавлением. Поддерживает распараллеливание. Можно настроить перечень выгружаемых объектов. 

Для загрузки: еслии это скрипт - просто через psql выполняем (`psql -f`). 

Если архив с оглавлением - утилита **pg_restore**. При восстановлении также можно настроить список загружаемых объектов. 

Перед восстановлением нужно создать БД из шаблона `template0`. Также необходимо создать табличные пространства и роли (они относятся к кластеру и не выгружаются при создании копии). Также не выгружается статистика. После восстановления можно запустить через `ANALYZE`.


#### 8.1.4 Утилита pg_dumpall

Сохраняет весь кластер, включая роли и табличные пространства. 

Подключается к каждой БД и выгружает ее через pg_dump. Также выгружает глобальные объекты кластера.

Есть смысл запускать от имени суперпользователя, т. к. подключается ко всем БД.

Выгружает только в скрипты, т. е. не работает параллельно, поэтому проблемы с большими базами. Можно выгрузить только глобальные объекты (ключ `--globals-only`), а остальное через pg_dump.

Восстановление - через `psql`

### 8.2 Физическое резервирование

#### 8.2.1 Суть физического резервирования

Используется механизм восстановления после сбоев. Для этого нужны:

* копия файлов кластера
* набор журналов предзаписи, необходимых для восстановления согласованности (если копия делалась при корректно остановленном сервере - журнал не нужен)

Плюсы/минусы:

* быстрая скорость
* можно восстанавливать кластер на любой момент времени
* но резервирование/восстановление всего кластера целиком, нельзя отдельные журналы
* восстановление только на той же версии и архитектуре

[docs](https://postgrespro.ru/docs/postgresql/10/backup-file)

#### 8.2.2 Горячее / холодное копирование

Если копия создается при остановленном сервере - это **холодная копия**. Если сервер остановлен корректно - журнал предзаписи не нужен, иначе - с последней контрольной точки.

Копия на работающем сервере - **горячая копия**. Файлы, скопированные с такого кластера, будут в несогласованном состоянии. Нужны журналы предзаписи минимум за время копирования файловой системы.

#### 8.2.3 Утилита pg_basebackup и автономные копии

##### 8.2.3.1 Утилита pg_basebackup

В начале создает контрольную точку и переключает журнал на новый файл.

Затем копируются файлы кластера, затем снова переключается журнал на новый файл.

Теперь можно скопировать журнал, который создался за время между переключениями и получаем **автономную копию** (содержит все необходимое для восстановления).

Можно развернуть копию и запустить сервер. При запуске восстановит согласованность по журналу, если надо.

##### 8.2.3.2 Протокол репликации

pg_basebackup подключается к серверу по специальному протоколу для сохранения журнала WAL. Это может выполняться параллельно с копированием файлов.

Чтобы сервер не удалил файлы журнала, используется **слот репликации**.

Нужны настройки, чтобы это работало:

* роль должна быть с атрибутом **REPLICATION** или суперпользователем и должен быть настроен доступ в `pg_hba.conf`.
* параметр **wal_senders** определяет количество процессов, обслуживающих протокол репликации (в > 10 версии = 10 по умолчанию)
* **wal_level** должен быть равен `replica`

PostgreSQL 10 и выше по умолчанию обеспечивает это на локальном подлючении


#### 8.2.4 Архивы журналов

##### 8.2.4.1 Варианты архивирования журнала

Если есть файловая копия, то постоянно сохраняя журнал предзаписи, можем восстановить кластер на любой произвольный момент.

Два способа архивирования журнала:

* **файловый архив** - сам сервер записывает файлы журнала по мере заполнения в отдельное место. Нужны доп. настройки. Файл журнала попадает в архив только когда заполнен.
* **потоковый архив** - отдельной утилитой файлы журнала читаются по протоколу репликации. Задержки минимальны.

##### 8.2.4.2 Файловый архив

**Файловый архив** выполняется фоновым процессом `archiver`.

В параметре `archive_command` задается произвольная команда shell. 

Параметр `achive_mode` включает механизм архивирования. 

Когда сегмент журнала заполняется, вызывается команда из `archive_command`. Если она выполняется успешно (возвращает 0), сегмент считается скопированным и удаляется. Если нет - остается и сервер будет периодически пытаться вызвать команду, пока не вернет 0. 

При низкой активности сервера можно настроить `archive_timeout`, чтобы сохранять не реже заданного времени. Можно вручную вызвать `pg_switch_log()`.

##### 8.2.4.3 Потоковый архив

Утилита **pg_receivewal** записывает сегменты журнала в архив, получая их по протоколу репликации.

Обычно запускается на отдельном сервере и подключается к целевому серверу с параметрами, указанными в ключах. Использует слои репликации, чтобы не потерять записи.

Утилита формирует файлы как это делает сервер. Незаполненные сегменты записываются с префиксом `.partial`. Архивирование начнется с сегментом, следующим за тем, который уже есть в архиве. Если архив пуст - с текущего сегмента.

Утилита не запускается автоматически или как демон.

Также использует процессы `wal_sender` (настроить связанные параметры).


 

#### 8.2.5 Резервная копия + архив журнала

Архивная копия делается также через **pg_basebackup**, но с отключением архивирования журнала.

Для восстановления создается файл `$PGDATA/recovery.conf`, который управляет восстановлением. В этом файле находится команда `restore_command`, обратная `archive_command`, которая копирует файлы журнала из архива в каталог сервера.

Также указывается желаемая точка восстановления.